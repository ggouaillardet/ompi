<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - ompi.info - opal/mca/btl/sm/btl_sm.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">opal/mca/btl/sm</a> - btl_sm.h<span style="font-size: 80%;"> (source / <a href="btl_sm.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">ompi.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">17</td>
            <td class="headerCovTableEntry">41</td>
            <td class="headerCovTableEntryLo">41.5 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2015-07-30 14:35:26</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">3</td>
            <td class="headerCovTableEntryLo">33.3 %</td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */</a>
<span class="lineNum">       2 </span>            : /*
<span class="lineNum">       3 </span>            :  * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
<span class="lineNum">       4 </span>            :  *                         University Research and Technology
<span class="lineNum">       5 </span>            :  *                         Corporation.  All rights reserved.
<span class="lineNum">       6 </span>            :  * Copyright (c) 2004-2012 The University of Tennessee and The University
<span class="lineNum">       7 </span>            :  *                         of Tennessee Research Foundation.  All rights
<span class="lineNum">       8 </span>            :  *                         reserved.
<span class="lineNum">       9 </span>            :  * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
<span class="lineNum">      10 </span>            :  *                         University of Stuttgart.  All rights reserved.
<span class="lineNum">      11 </span>            :  * Copyright (c) 2004-2005 The Regents of the University of California.
<span class="lineNum">      12 </span>            :  *                         All rights reserved.
<span class="lineNum">      13 </span>            :  * Copyright (c) 2006-2007 Voltaire. All rights reserved.
<span class="lineNum">      14 </span>            :  * Copyright (c) 2009-2010 Cisco Systems, Inc.  All rights reserved.
<span class="lineNum">      15 </span>            :  * Copyright (c) 2010-2015 Los Alamos National Security, LLC.
<span class="lineNum">      16 </span>            :  *                         All rights reserved.
<span class="lineNum">      17 </span>            :  * Copyright (c) 2010-2012 IBM Corporation.  All rights reserved.
<span class="lineNum">      18 </span>            :  * $COPYRIGHT$
<span class="lineNum">      19 </span>            :  *
<span class="lineNum">      20 </span>            :  * Additional copyrights may follow
<span class="lineNum">      21 </span>            :  *
<span class="lineNum">      22 </span>            :  * $HEADER$
<span class="lineNum">      23 </span>            :  */
<span class="lineNum">      24 </span>            : /**
<span class="lineNum">      25 </span>            :  * @file
<span class="lineNum">      26 </span>            :  */
<span class="lineNum">      27 </span>            : #ifndef MCA_BTL_SM_H
<span class="lineNum">      28 </span>            : #define MCA_BTL_SM_H
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : #include &quot;opal_config.h&quot;
<span class="lineNum">      31 </span>            : #include &lt;stddef.h&gt;
<span class="lineNum">      32 </span>            : #include &lt;stdlib.h&gt;
<span class="lineNum">      33 </span>            : #include &lt;string.h&gt;
<span class="lineNum">      34 </span>            : #include &lt;stdint.h&gt;
<span class="lineNum">      35 </span>            : #ifdef HAVE_SCHED_H
<span class="lineNum">      36 </span>            : #include &lt;sched.h&gt;
<span class="lineNum">      37 </span>            : #endif  /* HAVE_SCHED_H */
<span class="lineNum">      38 </span>            : #if OPAL_BTL_SM_HAVE_KNEM
<span class="lineNum">      39 </span>            : #include &quot;knem_io.h&quot;
<span class="lineNum">      40 </span>            : #endif /* OPAL_BTL_SM_HAVE_KNEM */
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : #include &quot;opal/util/bit_ops.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;opal/class/opal_free_list.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;opal/mca/btl/btl.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;opal/util/proc.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;opal/mca/common/sm/common_sm.h&quot;
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span>            : BEGIN_C_DECLS
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            : /*
<span class="lineNum">      51 </span>            :  * Shared Memory FIFOs
<span class="lineNum">      52 </span>            :  *
<span class="lineNum">      53 </span>            :  * The FIFO is implemented as a circular queue with head and tail pointers
<span class="lineNum">      54 </span>            :  * (integer indices).  For efficient wraparound indexing, the size of the
<span class="lineNum">      55 </span>            :  * queue is constrained to be a power of two and we &quot;&amp;&quot; indices with a &quot;mask&quot;.
<span class="lineNum">      56 </span>            :  *
<span class="lineNum">      57 </span>            :  * More than one process can write to the FIFO head.  Therefore, there is a head
<span class="lineNum">      58 </span>            :  * lock.  One cannot write until the head slot is empty, indicated by the special
<span class="lineNum">      59 </span>            :  * queue entry SM_FIFO_FREE.
<span class="lineNum">      60 </span>            :  *
<span class="lineNum">      61 </span>            :  * Only the receiver can read the FIFO tail.  Therefore, the tail lock is
<span class="lineNum">      62 </span>            :  * required only in multithreaded applications.  If a tail read returns the
<span class="lineNum">      63 </span>            :  * SM_FIFO_FREE value, that means the FIFO is empty.  Once a non-FREE value
<span class="lineNum">      64 </span>            :  * has been read, the queue slot is *not* automatically reset to SM_FIFO_FREE.
<span class="lineNum">      65 </span>            :  * Rather, read tail slots are reset &quot;lazily&quot; (see &quot;lazy_free&quot; and &quot;num_to_clear&quot;)
<span class="lineNum">      66 </span>            :  * to reduce the number of memory barriers and improve performance.
<span class="lineNum">      67 </span>            :  *
<span class="lineNum">      68 </span>            :  * Since the FIFO lives in shared memory that is mapped differently into
<span class="lineNum">      69 </span>            :  * each address space, the &quot;queue&quot; pointer is relative (each process must
<span class="lineNum">      70 </span>            :  * add its own offset) and the queue_recv pointer is meaningful only in the
<span class="lineNum">      71 </span>            :  * receiver's address space.
<span class="lineNum">      72 </span>            :  *
<span class="lineNum">      73 </span>            :  * Since multiple processes access different parts of the FIFO structure in
<span class="lineNum">      74 </span>            :  * different ways, we introduce padding to keep different parts on different
<span class="lineNum">      75 </span>            :  * cachelines.
<span class="lineNum">      76 </span>            :  */
<span class="lineNum">      77 </span>            : 
<span class="lineNum">      78 </span>            : #define SM_FIFO_FREE  (void *) (-2)
<span class="lineNum">      79 </span>            : /* We can't use opal_cache_line_size here because we need a
<span class="lineNum">      80 </span>            :    compile-time constant for padding the struct.  We can't really have
<span class="lineNum">      81 </span>            :    a compile-time constant that is portable, either (e.g., compile on
<span class="lineNum">      82 </span>            :    one machine and run on another).  So just use a big enough cache
<span class="lineNum">      83 </span>            :    line that should hopefully be good in most places. */
<span class="lineNum">      84 </span>            : #define SM_CACHE_LINE_PAD 128
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span>            : struct sm_fifo_t {
<span class="lineNum">      87 </span>            :     /* This queue pointer is used only by the heads. */
<span class="lineNum">      88 </span>            :     volatile void **queue;
<span class="lineNum">      89 </span>            :     char pad0[SM_CACHE_LINE_PAD - sizeof(void **)];
<span class="lineNum">      90 </span>            :     /* This lock is used by the heads. */
<span class="lineNum">      91 </span>            :     opal_atomic_lock_t head_lock;
<span class="lineNum">      92 </span>            :     char pad1[SM_CACHE_LINE_PAD - sizeof(opal_atomic_lock_t)];
<span class="lineNum">      93 </span>            :     /* This index is used by the head holding the head lock. */
<span class="lineNum">      94 </span>            :     volatile int head;
<span class="lineNum">      95 </span>            :     char pad2[SM_CACHE_LINE_PAD - sizeof(int)];
<span class="lineNum">      96 </span>            :     /* This mask is used &quot;read only&quot; by all processes. */
<span class="lineNum">      97 </span>            :     unsigned int mask;
<span class="lineNum">      98 </span>            :     char pad3[SM_CACHE_LINE_PAD - sizeof(int)];
<span class="lineNum">      99 </span>            :     /* The following are used only by the tail. */
<span class="lineNum">     100 </span>            :     volatile void **queue_recv;
<span class="lineNum">     101 </span>            :     opal_atomic_lock_t tail_lock;
<span class="lineNum">     102 </span>            :     volatile int tail;
<span class="lineNum">     103 </span>            :     int num_to_clear;
<span class="lineNum">     104 </span>            :     int lazy_free;
<span class="lineNum">     105 </span>            :     char pad4[SM_CACHE_LINE_PAD - sizeof(void **) -
<span class="lineNum">     106 </span>            :               sizeof(opal_atomic_lock_t) -
<span class="lineNum">     107 </span>            :               sizeof(int) * 3];
<span class="lineNum">     108 </span>            : };
<span class="lineNum">     109 </span>            : typedef struct sm_fifo_t sm_fifo_t;
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            : /*
<span class="lineNum">     112 </span>            :  * Shared Memory resource managment
<span class="lineNum">     113 </span>            :  */
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span>            : #if OPAL_ENABLE_PROGRESS_THREADS == 1
<span class="lineNum">     116 </span>            : #define DATA (char)0
<span class="lineNum">     117 </span>            : #define DONE (char)1
<span class="lineNum">     118 </span>            : #endif
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span>            : typedef struct mca_btl_sm_mem_node_t {
<span class="lineNum">     121 </span>            :     mca_mpool_base_module_t* sm_mpool; /**&lt; shared memory pool */
<span class="lineNum">     122 </span>            : } mca_btl_sm_mem_node_t;
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span>            : /**
<span class="lineNum">     125 </span>            :  * Shared Memory (SM) BTL module.
<span class="lineNum">     126 </span>            :  */
<span class="lineNum">     127 </span>            : struct mca_btl_sm_component_t {
<span class="lineNum">     128 </span>            :     mca_btl_base_component_3_0_0_t super;  /**&lt; base BTL component */
<span class="lineNum">     129 </span>            :     int sm_free_list_num;              /**&lt; initial size of free lists */
<span class="lineNum">     130 </span>            :     int sm_free_list_max;              /**&lt; maximum size of free lists */
<span class="lineNum">     131 </span>            :     int sm_free_list_inc;              /**&lt; number of elements to alloc when growing free lists */
<span class="lineNum">     132 </span>            :     int sm_max_procs;                  /**&lt; upper limit on the number of processes using the shared memory pool */
<span class="lineNum">     133 </span>            :     int sm_extra_procs;                /**&lt; number of extra procs to allow */
<span class="lineNum">     134 </span>            :     char* sm_mpool_name;               /**&lt; name of shared memory pool module */
<span class="lineNum">     135 </span>            :     mca_mpool_base_module_t **sm_mpools; /**&lt; shared memory pools (one for each memory node) */
<span class="lineNum">     136 </span>            :     mca_mpool_base_module_t *sm_mpool; /**&lt; mpool on local node */
<span class="lineNum">     137 </span>            :     void* sm_mpool_base;               /**&lt; base address of shared memory pool */
<span class="lineNum">     138 </span>            :     size_t eager_limit;                /**&lt; first fragment size */
<span class="lineNum">     139 </span>            :     size_t max_frag_size;              /**&lt; maximum (second and beyone) fragment size */
<span class="lineNum">     140 </span>            :     opal_mutex_t sm_lock;
<span class="lineNum">     141 </span>            :     mca_common_sm_module_t *sm_seg;   /**&lt; description of shared memory segment */
<span class="lineNum">     142 </span>            :     volatile sm_fifo_t **shm_fifo;     /**&lt; pointer to fifo 2D array in shared memory */
<span class="lineNum">     143 </span>            :     char **shm_bases;                  /**&lt; pointer to base pointers in shared memory */
<span class="lineNum">     144 </span>            :     uint16_t *shm_mem_nodes;           /**&lt; pointer to mem noded in shared memory */
<span class="lineNum">     145 </span>            :     sm_fifo_t **fifo;                  /**&lt; cached copy of the pointer to the 2D
<span class="lineNum">     146 </span>            :                                           fifo array.  The address in the shared
<span class="lineNum">     147 </span>            :                                           memory segment sm_ctl_header is a relative,
<span class="lineNum">     148 </span>            :                                           but this one, in process private memory, is
<span class="lineNum">     149 </span>            :                                           a real virtual address */
<span class="lineNum">     150 </span>            :     uint16_t *mem_nodes;               /**&lt; cached copy of mem nodes of each local rank */
<span class="lineNum">     151 </span>            :     unsigned int fifo_size;            /**&lt; number of FIFO queue entries */
<span class="lineNum">     152 </span>            :     unsigned int fifo_lazy_free;       /**&lt; number of reads before lazy fifo free is triggered */
<span class="lineNum">     153 </span>            :     int nfifos;                        /**&lt; number of FIFOs per receiver */
<span class="lineNum">     154 </span>            :     int32_t num_smp_procs;             /**&lt; current number of smp procs on this host */
<span class="lineNum">     155 </span>            :     int32_t my_smp_rank;               /**&lt; My SMP process rank.  Used for accessing
<span class="lineNum">     156 </span>            :                                         *   SMP specfic data structures. */
<span class="lineNum">     157 </span>            :     opal_free_list_t sm_frags_eager;   /**&lt; free list of sm first */
<span class="lineNum">     158 </span>            :     opal_free_list_t sm_frags_max;     /**&lt; free list of sm second */
<span class="lineNum">     159 </span>            :     opal_free_list_t sm_frags_user;
<span class="lineNum">     160 </span>            :     opal_free_list_t sm_first_frags_to_progress;  /**&lt; list of first
<span class="lineNum">     161 </span>            :                                                     fragments that are
<span class="lineNum">     162 </span>            :                                                     awaiting resources */
<span class="lineNum">     163 </span>            :     struct mca_btl_base_endpoint_t **sm_peers;
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span>            :     opal_free_list_t pending_send_fl;
<span class="lineNum">     166 </span>            :     int num_outstanding_frags;         /**&lt; number of fragments sent but not yet returned to free list */
<span class="lineNum">     167 </span>            :     int num_pending_sends;             /**&lt; total number on all of my pending-send queues */
<span class="lineNum">     168 </span>            :     int mem_node;
<span class="lineNum">     169 </span>            :     int num_mem_nodes;
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span>            : #if OPAL_ENABLE_PROGRESS_THREADS == 1
<span class="lineNum">     172 </span>            :     char sm_fifo_path[PATH_MAX];   /**&lt; path to fifo used to signal this process */
<span class="lineNum">     173 </span>            :     int  sm_fifo_fd;               /**&lt; file descriptor corresponding to opened fifo */
<span class="lineNum">     174 </span>            :     opal_thread_t sm_fifo_thread;
<span class="lineNum">     175 </span>            : #endif
<span class="lineNum">     176 </span>            :     struct mca_btl_sm_t      **sm_btls;
<span class="lineNum">     177 </span>            :     struct mca_btl_sm_frag_t **table;
<span class="lineNum">     178 </span>            :     size_t sm_num_btls;
<span class="lineNum">     179 </span>            :     size_t sm_max_btls;
<span class="lineNum">     180 </span>            : 
<span class="lineNum">     181 </span>            : #if OPAL_BTL_SM_HAVE_KNEM
<span class="lineNum">     182 </span>            :     /* Knem capabilities info */
<span class="lineNum">     183 </span>            :     struct knem_cmd_info knem_info;
<span class="lineNum">     184 </span>            : #endif
<span class="lineNum">     185 </span>            : #if OPAL_BTL_SM_HAVE_KNEM || OPAL_BTL_SM_HAVE_CMA
<span class="lineNum">     186 </span>            :     /** registration handles to hold knem cookies */
<span class="lineNum">     187 </span>            :     opal_free_list_t registration_handles;
<span class="lineNum">     188 </span>            : #endif /* OPAL_BTL_SM_HAVE_KNEM */
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            :     /** MCA: should we be using knem or not?  neg=try but continue if
<span class="lineNum">     191 </span>            :         not available, 0=don't try, 1=try and fail if not available */
<span class="lineNum">     192 </span>            :     int use_knem;
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span>            :     /** MCA: minimal message size (bytes) to offload on DMA engine
<span class="lineNum">     195 </span>            :         when using knem */
<span class="lineNum">     196 </span>            :     unsigned int knem_dma_min;
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span>            :     /** MCA: how many simultaneous ongoing knem operations to
<span class="lineNum">     199 </span>            :         support */
<span class="lineNum">     200 </span>            :     int knem_max_simultaneous;
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span>            :     /** If we want DMA and DMA is supported, this will be loaded with
<span class="lineNum">     203 </span>            :         KNEM_FLAG_DMA.  Otherwise, it'll be 0. */
<span class="lineNum">     204 </span>            :     int knem_dma_flag;
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            :     /** MCA: should we be using CMA or not?
<span class="lineNum">     207 </span>            :         0 = no, 1 = yes */
<span class="lineNum">     208 </span>            :     int use_cma;
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span>            :     /* /// well-known file names for sm and sm mpool init /// */
<span class="lineNum">     211 </span>            :     char *sm_mpool_ctl_file_name;
<span class="lineNum">     212 </span>            :     char *sm_mpool_rndv_file_name;
<span class="lineNum">     213 </span>            :     char *sm_ctl_file_name;
<span class="lineNum">     214 </span>            :     char *sm_rndv_file_name;
<span class="lineNum">     215 </span>            : };
<span class="lineNum">     216 </span>            : typedef struct mca_btl_sm_component_t mca_btl_sm_component_t;
<span class="lineNum">     217 </span>            : OPAL_MODULE_DECLSPEC extern mca_btl_sm_component_t mca_btl_sm_component;
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span>            : /**
<span class="lineNum">     220 </span>            :  * SM BTL Interface
<span class="lineNum">     221 </span>            :  */
<span class="lineNum">     222 </span>            : struct mca_btl_sm_t {
<span class="lineNum">     223 </span>            :     mca_btl_base_module_t  super;       /**&lt; base BTL interface */
<span class="lineNum">     224 </span>            :     bool btl_inited;  /**&lt; flag indicating if btl has been inited */
<span class="lineNum">     225 </span>            :     mca_btl_base_module_error_cb_fn_t error_cb;
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            : #if OPAL_BTL_SM_HAVE_KNEM
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span>            :     /* File descriptor for knem */
<span class="lineNum">     230 </span>            :     int knem_fd;
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            :     /* Array of knem status items for non-blocking knem requests */
<span class="lineNum">     233 </span>            :     knem_status_t *knem_status_array;
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            :     /* Array of fragments currently being moved by knem non-blocking
<span class="lineNum">     236 </span>            :        operations */
<span class="lineNum">     237 </span>            :     struct mca_btl_sm_frag_t **knem_frag_array;
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span>            :     /* First free/available location in knem_status_array */
<span class="lineNum">     240 </span>            :     int knem_status_first_avail;
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span>            :     /* First currently-being used location in the knem_status_array */
<span class="lineNum">     243 </span>            :     int knem_status_first_used;
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            :     /* Number of status items currently in use */
<span class="lineNum">     246 </span>            :     int knem_status_num_used;
<span class="lineNum">     247 </span>            : #endif /* OPAL_BTL_SM_HAVE_KNEM */
<span class="lineNum">     248 </span>            : };
<span class="lineNum">     249 </span>            : typedef struct mca_btl_sm_t mca_btl_sm_t;
<span class="lineNum">     250 </span>            : OPAL_MODULE_DECLSPEC extern mca_btl_sm_t mca_btl_sm;
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span>            : struct btl_sm_pending_send_item_t
<span class="lineNum">     253 </span>            : {
<span class="lineNum">     254 </span>            :     opal_free_list_item_t super;
<span class="lineNum">     255 </span>            :     void *data;
<span class="lineNum">     256 </span>            : };
<span class="lineNum">     257 </span>            : typedef struct btl_sm_pending_send_item_t btl_sm_pending_send_item_t;
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span>            : /***
<span class="lineNum">     260 </span>            :  * FIFO support for sm BTL.
<span class="lineNum">     261 </span>            :  */
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span>            : /***
<span class="lineNum">     264 </span>            :  * One or more FIFO components may be a pointer that must be
<span class="lineNum">     265 </span>            :  * accessed by multiple processes.  Since the shared region may
<span class="lineNum">     266 </span>            :  * be mmapped differently into each process's address space,
<span class="lineNum">     267 </span>            :  * these pointers will be relative to some base address.  Here,
<span class="lineNum">     268 </span>            :  * we define macros to translate between relative addresses and
<span class="lineNum">     269 </span>            :  * virtual addresses.
<span class="lineNum">     270 </span>            :  */
<span class="lineNum">     271 </span>            : #define VIRTUAL2RELATIVE(VADDR ) ((long)(VADDR)  - (long)mca_btl_sm_component.shm_bases[mca_btl_sm_component.my_smp_rank])
<a name="272"><span class="lineNum">     272 </span>            : #define RELATIVE2VIRTUAL(OFFSET) ((long)(OFFSET) + (long)mca_btl_sm_component.shm_bases[mca_btl_sm_component.my_smp_rank])</a>
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span><span class="lineCov">          2 : static inline int sm_fifo_init(int fifo_size, mca_mpool_base_module_t *mpool,</span>
<span class="lineNum">     275 </span>            :                                sm_fifo_t *fifo, int lazy_free)
<span class="lineNum">     276 </span>            : {
<span class="lineNum">     277 </span>            :     int i, qsize;
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span>            :     /* figure out the queue size (a power of two that is at least 1) */
<span class="lineNum">     280 </span><span class="lineCov">          2 :     qsize = opal_next_poweroftwo_inclusive (fifo_size);</span>
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span>            :     /* allocate the queue in the receiver's address space */
<span class="lineNum">     283 </span><span class="lineCov">          2 :     fifo-&gt;queue_recv = (volatile void **)mpool-&gt;mpool_alloc(</span>
<span class="lineNum">     284 </span>            :             mpool, sizeof(void *) * qsize, opal_cache_line_size, 0, NULL);
<span class="lineNum">     285 </span><span class="lineCov">          2 :     if(NULL == fifo-&gt;queue_recv) {</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :         return OPAL_ERR_OUT_OF_RESOURCE;</span>
<span class="lineNum">     287 </span>            :     }
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span>            :     /* initialize the queue */
<span class="lineNum">     290 </span><span class="lineCov">       8194 :     for ( i = 0; i &lt; qsize; i++ )</span>
<span class="lineNum">     291 </span><span class="lineCov">       8192 :         fifo-&gt;queue_recv[i] = SM_FIFO_FREE;</span>
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            :     /* shift queue address to be relative */
<span class="lineNum">     294 </span><span class="lineCov">          2 :     fifo-&gt;queue = (volatile void **) VIRTUAL2RELATIVE(fifo-&gt;queue_recv);</span>
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span>            :     /* initialize the locks */
<span class="lineNum">     297 </span><span class="lineCov">          2 :     opal_atomic_init(&amp;(fifo-&gt;head_lock), OPAL_ATOMIC_UNLOCKED);</span>
<span class="lineNum">     298 </span><span class="lineCov">          2 :     opal_atomic_init(&amp;(fifo-&gt;tail_lock), OPAL_ATOMIC_UNLOCKED);</span>
<span class="lineNum">     299 </span><span class="lineCov">          2 :     opal_atomic_unlock(&amp;(fifo-&gt;head_lock));  /* should be unnecessary */</span>
<span class="lineNum">     300 </span><span class="lineCov">          2 :     opal_atomic_unlock(&amp;(fifo-&gt;tail_lock));  /* should be unnecessary */</span>
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span>            :     /* other initializations */
<span class="lineNum">     303 </span><span class="lineCov">          2 :     fifo-&gt;head = 0;</span>
<span class="lineNum">     304 </span><span class="lineCov">          2 :     fifo-&gt;mask = qsize - 1;</span>
<span class="lineNum">     305 </span><span class="lineCov">          2 :     fifo-&gt;tail = 0;</span>
<span class="lineNum">     306 </span><span class="lineCov">          2 :     fifo-&gt;num_to_clear = 0;</span>
<span class="lineNum">     307 </span><span class="lineCov">          2 :     fifo-&gt;lazy_free = lazy_free;</span>
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span><span class="lineCov">          2 :     return OPAL_SUCCESS;</span>
<span class="lineNum">     310 </span>            : }
<a name="311"><span class="lineNum">     311 </span>            : </a>
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span><span class="lineNoCov">          0 : static inline int sm_fifo_write(void *value, sm_fifo_t *fifo)</span>
<span class="lineNum">     314 </span>            : {
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :     volatile void **q = (volatile void **) RELATIVE2VIRTUAL(fifo-&gt;queue);</span>
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span>            :     /* if there is no free slot to write, report exhausted resource */
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :     opal_atomic_rmb();</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :     if ( SM_FIFO_FREE != q[fifo-&gt;head] )</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :         return OPAL_ERR_OUT_OF_RESOURCE;</span>
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span>            :     /* otherwise, write to the slot and advance the head index */
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :     q[fifo-&gt;head] = value;</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :     opal_atomic_wmb();</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :     fifo-&gt;head = (fifo-&gt;head + 1) &amp; fifo-&gt;mask;</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :     return OPAL_SUCCESS;</span>
<span class="lineNum">     327 </span>            : }
<a name="328"><span class="lineNum">     328 </span>            : </a>
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span><span class="lineNoCov">          0 : static inline void *sm_fifo_read(sm_fifo_t *fifo)</span>
<span class="lineNum">     331 </span>            : {
<span class="lineNum">     332 </span>            :     void *value;
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            :     /* read the next queue entry */
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :     value = (void *) fifo-&gt;queue_recv[fifo-&gt;tail];</span>
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :     opal_atomic_rmb();</span>
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span>            :     /* if you read a non-empty slot, advance the tail pointer */
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :     if ( SM_FIFO_FREE != value ) {</span>
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :         fifo-&gt;tail = ( fifo-&gt;tail + 1 ) &amp; fifo-&gt;mask;</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :         fifo-&gt;num_to_clear += 1;</span>
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span>            :         /* check if it's time to free slots, which we do lazily */
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :         if ( fifo-&gt;num_to_clear &gt;= fifo-&gt;lazy_free ) {</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :             int i = (fifo-&gt;tail - fifo-&gt;num_to_clear ) &amp; fifo-&gt;mask;</span>
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :             while ( fifo-&gt;num_to_clear &gt; 0 ) {</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :                 fifo-&gt;queue_recv[i] = SM_FIFO_FREE;</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :                 i = (i+1) &amp; fifo-&gt;mask;</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :                 fifo-&gt;num_to_clear -= 1;</span>
<span class="lineNum">     353 </span>            :             }
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :             opal_atomic_wmb();</span>
<span class="lineNum">     355 </span>            :         }
<span class="lineNum">     356 </span>            :     }
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :     return value;</span>
<span class="lineNum">     359 </span>            : }
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span>            : /**
<span class="lineNum">     362 </span>            :  * shared memory component progress.
<span class="lineNum">     363 </span>            :  */
<span class="lineNum">     364 </span>            : extern int mca_btl_sm_component_progress(void);
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span>            : 
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span>            : /**
<span class="lineNum">     369 </span>            :  * Register a callback function that is called on error..
<span class="lineNum">     370 </span>            :  *
<span class="lineNum">     371 </span>            :  * @param btl (IN)     BTL module
<span class="lineNum">     372 </span>            :  * @return             Status indicating if cleanup was successful
<span class="lineNum">     373 </span>            :  */
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span>            : int mca_btl_sm_register_error_cb(
<span class="lineNum">     376 </span>            :     struct mca_btl_base_module_t* btl,
<span class="lineNum">     377 </span>            :     mca_btl_base_module_error_cb_fn_t cbfunc
<span class="lineNum">     378 </span>            : );
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span>            : /**
<span class="lineNum">     381 </span>            :  * Cleanup any resources held by the BTL.
<span class="lineNum">     382 </span>            :  *
<span class="lineNum">     383 </span>            :  * @param btl  BTL instance.
<span class="lineNum">     384 </span>            :  * @return     OPAL_SUCCESS or error status on failure.
<span class="lineNum">     385 </span>            :  */
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span>            : extern int mca_btl_sm_finalize(
<span class="lineNum">     388 </span>            :     struct mca_btl_base_module_t* btl
<span class="lineNum">     389 </span>            : );
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span>            : /**
<span class="lineNum">     393 </span>            :  * PML-&gt;BTL notification of change in the process list.
<span class="lineNum">     394 </span>            :  * PML-&gt;BTL Notification that a receive fragment has been matched.
<span class="lineNum">     395 </span>            :  * Called for message that is send from process with the virtual
<span class="lineNum">     396 </span>            :  * address of the shared memory segment being different than that of
<span class="lineNum">     397 </span>            :  * the receiver.
<span class="lineNum">     398 </span>            :  *
<span class="lineNum">     399 </span>            :  * @param btl (IN)
<span class="lineNum">     400 </span>            :  * @param proc (IN)
<span class="lineNum">     401 </span>            :  * @param peer (OUT)
<span class="lineNum">     402 </span>            :  * @return     OPAL_SUCCESS or error status on failure.
<span class="lineNum">     403 </span>            :  *
<span class="lineNum">     404 </span>            :  */
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span>            : extern int mca_btl_sm_add_procs(
<span class="lineNum">     407 </span>            :     struct mca_btl_base_module_t* btl,
<span class="lineNum">     408 </span>            :     size_t nprocs,
<span class="lineNum">     409 </span>            :     struct opal_proc_t **procs,
<span class="lineNum">     410 </span>            :     struct mca_btl_base_endpoint_t** peers,
<span class="lineNum">     411 </span>            :     struct opal_bitmap_t* reachability
<span class="lineNum">     412 </span>            : );
<span class="lineNum">     413 </span>            : 
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span>            : /**
<span class="lineNum">     416 </span>            :  * PML-&gt;BTL notification of change in the process list.
<span class="lineNum">     417 </span>            :  *
<span class="lineNum">     418 </span>            :  * @param btl (IN)     BTL instance
<span class="lineNum">     419 </span>            :  * @param proc (IN)    Peer process
<span class="lineNum">     420 </span>            :  * @param peer (IN)    Peer addressing information.
<span class="lineNum">     421 </span>            :  * @return             Status indicating if cleanup was successful
<span class="lineNum">     422 </span>            :  *
<span class="lineNum">     423 </span>            :  */
<span class="lineNum">     424 </span>            : extern int mca_btl_sm_del_procs(
<span class="lineNum">     425 </span>            :     struct mca_btl_base_module_t* btl,
<span class="lineNum">     426 </span>            :     size_t nprocs,
<span class="lineNum">     427 </span>            :     struct opal_proc_t **procs,
<span class="lineNum">     428 </span>            :     struct mca_btl_base_endpoint_t **peers
<span class="lineNum">     429 </span>            : );
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span>            : /**
<span class="lineNum">     433 </span>            :  * Allocate a segment.
<span class="lineNum">     434 </span>            :  *
<span class="lineNum">     435 </span>            :  * @param btl (IN)      BTL module
<span class="lineNum">     436 </span>            :  * @param size (IN)     Request segment size.
<span class="lineNum">     437 </span>            :  */
<span class="lineNum">     438 </span>            : extern mca_btl_base_descriptor_t* mca_btl_sm_alloc(
<span class="lineNum">     439 </span>            :     struct mca_btl_base_module_t* btl,
<span class="lineNum">     440 </span>            :     struct mca_btl_base_endpoint_t* endpoint,
<span class="lineNum">     441 </span>            :     uint8_t order,
<span class="lineNum">     442 </span>            :     size_t size,
<span class="lineNum">     443 </span>            :     uint32_t flags
<span class="lineNum">     444 </span>            : );
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span>            : /**
<span class="lineNum">     447 </span>            :  * Return a segment allocated by this BTL.
<span class="lineNum">     448 </span>            :  *
<span class="lineNum">     449 </span>            :  * @param btl (IN)      BTL module
<span class="lineNum">     450 </span>            :  * @param segment (IN)  Allocated segment.
<span class="lineNum">     451 </span>            :  */
<span class="lineNum">     452 </span>            : extern int mca_btl_sm_free(
<span class="lineNum">     453 </span>            :     struct mca_btl_base_module_t* btl,
<span class="lineNum">     454 </span>            :     mca_btl_base_descriptor_t* segment
<span class="lineNum">     455 </span>            : );
<span class="lineNum">     456 </span>            : 
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span>            : /**
<span class="lineNum">     459 </span>            :  * Pack data
<span class="lineNum">     460 </span>            :  *
<span class="lineNum">     461 </span>            :  * @param btl (IN)      BTL module
<span class="lineNum">     462 </span>            :  * @param peer (IN)     BTL peer addressing
<span class="lineNum">     463 </span>            :  */
<span class="lineNum">     464 </span>            : struct mca_btl_base_descriptor_t* mca_btl_sm_prepare_src(
<span class="lineNum">     465 </span>            :     struct mca_btl_base_module_t* btl,
<span class="lineNum">     466 </span>            :     struct mca_btl_base_endpoint_t* endpoint,
<span class="lineNum">     467 </span>            :     struct opal_convertor_t* convertor,
<span class="lineNum">     468 </span>            :     uint8_t order,
<span class="lineNum">     469 </span>            :     size_t reserve,
<span class="lineNum">     470 </span>            :     size_t* size,
<span class="lineNum">     471 </span>            :     uint32_t flags
<span class="lineNum">     472 </span>            : );
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span>            : /**
<span class="lineNum">     476 </span>            :  * Initiate an inlined send to the peer or return a descriptor.
<span class="lineNum">     477 </span>            :  *
<span class="lineNum">     478 </span>            :  * @param btl (IN)      BTL module
<span class="lineNum">     479 </span>            :  * @param peer (IN)     BTL peer addressing
<span class="lineNum">     480 </span>            :  */
<span class="lineNum">     481 </span>            : extern int mca_btl_sm_sendi( struct mca_btl_base_module_t* btl,
<span class="lineNum">     482 </span>            :                              struct mca_btl_base_endpoint_t* endpoint,
<span class="lineNum">     483 </span>            :                              struct opal_convertor_t* convertor,
<span class="lineNum">     484 </span>            :                              void* header,
<span class="lineNum">     485 </span>            :                              size_t header_size,
<span class="lineNum">     486 </span>            :                              size_t payload_size,
<span class="lineNum">     487 </span>            :                              uint8_t order,
<span class="lineNum">     488 </span>            :                              uint32_t flags,
<span class="lineNum">     489 </span>            :                              mca_btl_base_tag_t tag,
<span class="lineNum">     490 </span>            :                              mca_btl_base_descriptor_t** descriptor );
<span class="lineNum">     491 </span>            : 
<span class="lineNum">     492 </span>            : /**
<span class="lineNum">     493 </span>            :  * Initiate a send to the peer.
<span class="lineNum">     494 </span>            :  *
<span class="lineNum">     495 </span>            :  * @param btl (IN)      BTL module
<span class="lineNum">     496 </span>            :  * @param peer (IN)     BTL peer addressing
<span class="lineNum">     497 </span>            :  */
<span class="lineNum">     498 </span>            : extern int mca_btl_sm_send(
<span class="lineNum">     499 </span>            :     struct mca_btl_base_module_t* btl,
<span class="lineNum">     500 </span>            :     struct mca_btl_base_endpoint_t* endpoint,
<span class="lineNum">     501 </span>            :     struct mca_btl_base_descriptor_t* descriptor,
<span class="lineNum">     502 </span>            :     mca_btl_base_tag_t tag
<span class="lineNum">     503 </span>            : );
<span class="lineNum">     504 </span>            : 
<span class="lineNum">     505 </span>            : #if OPAL_BTL_SM_HAVE_KNEM || OPAL_BTL_SM_HAVE_CMA
<span class="lineNum">     506 </span>            : /*
<span class="lineNum">     507 </span>            :  * Synchronous knem/cma get
<span class="lineNum">     508 </span>            :  */
<span class="lineNum">     509 </span>            : int mca_btl_sm_get_sync (mca_btl_base_module_t *btl, struct mca_btl_base_endpoint_t *endpoint, void *local_address,
<span class="lineNum">     510 </span>            :                          uint64_t remote_address, mca_btl_base_registration_handle_t *local_handle,
<span class="lineNum">     511 </span>            :                          mca_btl_base_registration_handle_t *remote_handle, size_t size, int flags,
<span class="lineNum">     512 </span>            :                          int order, mca_btl_base_rdma_completion_fn_t cbfunc, void *cbcontext, void *cbdata);
<span class="lineNum">     513 </span>            : #endif /* OPAL_BTL_SM_HAVE_KNEM || OPAL_BTL_SM_HAVE_CMA */
<span class="lineNum">     514 </span>            : 
<span class="lineNum">     515 </span>            : #if OPAL_BTL_SM_HAVE_KNEM
<span class="lineNum">     516 </span>            : /*
<span class="lineNum">     517 </span>            :  * Asynchronous knem get
<span class="lineNum">     518 </span>            :  */
<span class="lineNum">     519 </span>            : int mca_btl_sm_get_async (mca_btl_base_module_t *btl, struct mca_btl_base_endpoint_t *endpoint, void *local_address,
<span class="lineNum">     520 </span>            :                           uint64_t remote_address, mca_btl_base_registration_handle_t *local_handle,
<span class="lineNum">     521 </span>            :                           mca_btl_base_registration_handle_t *remote_handle, size_t size, int flags,
<span class="lineNum">     522 </span>            :                           int order, mca_btl_base_rdma_completion_fn_t cbfunc, void *cbcontext, void *cbdata);
<span class="lineNum">     523 </span>            : 
<span class="lineNum">     524 </span>            : #endif /* OPAL_BTL_SM_HAVE_KNEM */
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span>            : extern void mca_btl_sm_dump(struct mca_btl_base_module_t* btl,
<span class="lineNum">     527 </span>            :                             struct mca_btl_base_endpoint_t* endpoint,
<span class="lineNum">     528 </span>            :                             int verbose);
<span class="lineNum">     529 </span>            : 
<span class="lineNum">     530 </span>            : /**
<span class="lineNum">     531 </span>            :  * Fault Tolerance Event Notification Function
<span class="lineNum">     532 </span>            :  * @param state Checkpoint Stae
<span class="lineNum">     533 </span>            :  * @return OPAL_SUCCESS or failure status
<span class="lineNum">     534 </span>            :  */
<span class="lineNum">     535 </span>            : int mca_btl_sm_ft_event(int state);
<span class="lineNum">     536 </span>            : 
<span class="lineNum">     537 </span>            : #if OPAL_ENABLE_PROGRESS_THREADS == 1
<span class="lineNum">     538 </span>            : void mca_btl_sm_component_event_thread(opal_object_t*);
<span class="lineNum">     539 </span>            : #endif
<span class="lineNum">     540 </span>            : 
<span class="lineNum">     541 </span>            : #if OPAL_ENABLE_PROGRESS_THREADS == 1
<span class="lineNum">     542 </span>            : #define MCA_BTL_SM_SIGNAL_PEER(peer) \
<span class="lineNum">     543 </span>            : { \
<span class="lineNum">     544 </span>            :     unsigned char cmd = DATA; \
<span class="lineNum">     545 </span>            :     if(write(peer-&gt;fifo_fd, &amp;cmd, sizeof(cmd)) != sizeof(cmd)) { \
<span class="lineNum">     546 </span>            :         opal_output(0, &quot;mca_btl_sm_send: write fifo failed: errno=%d\n&quot;, errno); \
<span class="lineNum">     547 </span>            :     } \
<span class="lineNum">     548 </span>            : }
<span class="lineNum">     549 </span>            : #else
<span class="lineNum">     550 </span>            : #define MCA_BTL_SM_SIGNAL_PEER(peer)
<span class="lineNum">     551 </span>            : #endif
<span class="lineNum">     552 </span>            : 
<span class="lineNum">     553 </span>            : #if OPAL_BTL_SM_HAVE_KNEM | OPAL_BTL_SM_HAVE_CMA
<span class="lineNum">     554 </span>            : struct mca_btl_base_registration_handle_t {
<span class="lineNum">     555 </span>            :     union {
<span class="lineNum">     556 </span>            :         struct {
<span class="lineNum">     557 </span>            :             uint64_t cookie;
<span class="lineNum">     558 </span>            :             intptr_t base_addr;
<span class="lineNum">     559 </span>            :         } knem;
<span class="lineNum">     560 </span>            :         pid_t pid;
<span class="lineNum">     561 </span>            :     } data;
<span class="lineNum">     562 </span>            : };
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span>            : struct mca_btl_sm_registration_handle_t {
<span class="lineNum">     565 </span>            :     opal_free_list_item_t super;
<span class="lineNum">     566 </span>            :     mca_btl_base_registration_handle_t btl_handle;
<span class="lineNum">     567 </span>            : };
<span class="lineNum">     568 </span>            : typedef struct mca_btl_sm_registration_handle_t mca_btl_sm_registration_handle_t;
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span>            : mca_btl_base_registration_handle_t *mca_btl_sm_register_mem (struct mca_btl_base_module_t* btl,
<span class="lineNum">     571 </span>            :                                                              struct mca_btl_base_endpoint_t* endpoint,
<span class="lineNum">     572 </span>            :                                                              void *base, size_t size, uint32_t flags);
<span class="lineNum">     573 </span>            : 
<span class="lineNum">     574 </span>            : int mca_btl_sm_deregister_mem (struct mca_btl_base_module_t* btl, mca_btl_base_registration_handle_t *handle);
<span class="lineNum">     575 </span>            : 
<span class="lineNum">     576 </span>            : #endif
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span>            : END_C_DECLS
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span>            : #endif
<span class="lineNum">     581 </span>            : 
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
