<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - master-ibm-intel-check - opal/mca/memory/linux/arena.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">opal/mca/memory/linux</a> - arena.c<span style="font-size: 80%;"> (source / <a href="arena.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">master-ibm-intel-check</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">239</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2015-07-31 16:35:34</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">13</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Malloc implementation for multiple threads without lock contention.</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 2001 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            :    This file is part of the GNU C Library.
<span class="lineNum">       4 </span>            :    Contributed by Wolfram Gloger &lt;wg@malloc.de&gt;, 2001.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            :    The GNU C Library is free software; you can redistribute it and/or
<span class="lineNum">       7 </span>            :    modify it under the terms of the GNU Library General Public License as
<span class="lineNum">       8 </span>            :    published by the Free Software Foundation; either version 2 of the
<span class="lineNum">       9 </span>            :    License, or (at your option) any later version.
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            :    The GNU C Library is distributed in the hope that it will be useful,
<span class="lineNum">      12 </span>            :    but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      13 </span>            :    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
<span class="lineNum">      14 </span>            :    Library General Public License for more details.
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            :    You should have received a copy of the GNU Library General Public
<span class="lineNum">      17 </span>            :    License along with the GNU C Library; see the file COPYING.LIB.  If not,
<span class="lineNum">      18 </span>            :    write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
<span class="lineNum">      19 </span>            :    Boston, MA 02111-1307, USA.  */
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : /* $Id: arena.c,v 1.9 2004/11/05 14:42:23 wg Exp $ */
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : /* Compile-time constants.  */
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            : #define HEAP_MIN_SIZE (32*1024)
<span class="lineNum">      26 </span>            : #ifndef HEAP_MAX_SIZE
<span class="lineNum">      27 </span>            : #define HEAP_MAX_SIZE (1024*1024) /* must be a power of two */
<span class="lineNum">      28 </span>            : #endif
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : /* HEAP_MIN_SIZE and HEAP_MAX_SIZE limit the size of mmap()ed heaps
<span class="lineNum">      31 </span>            :    that are dynamically created for multi-threaded programs.  The
<span class="lineNum">      32 </span>            :    maximum size must be a power of two, for fast determination of
<span class="lineNum">      33 </span>            :    which heap belongs to a chunk.  It should be much larger than the
<span class="lineNum">      34 </span>            :    mmap threshold, so that requests with a size just below that
<span class="lineNum">      35 </span>            :    threshold can be fulfilled without creating too many heaps.  */
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : #ifndef THREAD_STATS
<span class="lineNum">      39 </span>            : #define THREAD_STATS 0
<span class="lineNum">      40 </span>            : #endif
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : /* If THREAD_STATS is non-zero, some statistics on mutex locking are
<span class="lineNum">      43 </span>            :    computed.  */
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : /***************************************************************************/
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : #define top(ar_ptr) ((ar_ptr)-&gt;top)
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            : /* A heap is a single contiguous memory region holding (coalesceable)
<span class="lineNum">      50 </span>            :    malloc_chunks.  It is allocated with mmap() and always starts at an
<span class="lineNum">      51 </span>            :    address aligned to HEAP_MAX_SIZE.  Not used unless compiling with
<span class="lineNum">      52 </span>            :    USE_ARENAS. */
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            : typedef struct _heap_info {
<span class="lineNum">      55 </span>            :   mstate ar_ptr; /* Arena for this heap. */
<span class="lineNum">      56 </span>            :   struct _heap_info *prev; /* Previous heap. */
<span class="lineNum">      57 </span>            :   size_t size;   /* Current size in bytes. */
<span class="lineNum">      58 </span>            :   size_t pad;    /* Make sure the following data is properly aligned. */
<span class="lineNum">      59 </span>            : } heap_info;
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            : /* Thread specific data */
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            : static tsd_key_t arena_key;
<span class="lineNum">      64 </span>            : static mutex_t list_lock;
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            : #if THREAD_STATS
<span class="lineNum">      67 </span>            : static int stat_n_heaps;
<span class="lineNum">      68 </span>            : #define THREAD_STAT(x) x
<span class="lineNum">      69 </span>            : #else
<span class="lineNum">      70 </span>            : #define THREAD_STAT(x) do ; while(0)
<span class="lineNum">      71 </span>            : #endif
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            : /* Mapped memory in non-main arenas (reliable only for NO_THREADS). */
<span class="lineNum">      74 </span>            : static unsigned long arena_mem;
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span>            : /* Already initialized? */
<span class="lineNum">      77 </span>            : int __malloc_initialized = -1;
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            : /**************************************************************************/
<span class="lineNum">      80 </span>            : 
<span class="lineNum">      81 </span>            : #if USE_ARENAS
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span>            : /* arena_get() acquires an arena and locks the corresponding mutex.
<span class="lineNum">      84 </span>            :    First, try the one last locked successfully by this thread.  (This
<span class="lineNum">      85 </span>            :    is the common case and handled with a macro for speed.)  Then, loop
<span class="lineNum">      86 </span>            :    once over the circularly linked list of arenas.  If no arena is
<span class="lineNum">      87 </span>            :    readily available, create a new one.  In this latter case, `size'
<span class="lineNum">      88 </span>            :    is just a hint as to how much memory will be required immediately
<span class="lineNum">      89 </span>            :    in the new arena. */
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span>            : #define arena_get(ptr, size) do { \
<span class="lineNum">      92 </span>            :   Void_t *vptr = NULL; \
<span class="lineNum">      93 </span>            :   ptr = (mstate)tsd_getspecific(arena_key, vptr); \
<span class="lineNum">      94 </span>            :   if(ptr &amp;&amp; !mutex_trylock(&amp;ptr-&gt;mutex)) { \
<span class="lineNum">      95 </span>            :     THREAD_STAT(++(ptr-&gt;stat_lock_direct)); \
<span class="lineNum">      96 </span>            :   } else \
<span class="lineNum">      97 </span>            :     ptr = arena_get2(ptr, (size)); \
<span class="lineNum">      98 </span>            : } while(0)
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            : /* find the heap and corresponding arena for a given ptr */
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            : #define heap_for_ptr(ptr) \
<span class="lineNum">     103 </span>            :  ((heap_info *)((unsigned long)(ptr) &amp; ~(HEAP_MAX_SIZE-1)))
<span class="lineNum">     104 </span>            : #define arena_for_chunk(ptr) \
<span class="lineNum">     105 </span>            :  (chunk_non_main_arena(ptr) ? heap_for_ptr(ptr)-&gt;ar_ptr : &amp;main_arena)
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span>            : #else /* !USE_ARENAS */
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span>            : /* There is only one arena, main_arena. */
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            : #if THREAD_STATS
<span class="lineNum">     112 </span>            : #define arena_get(ar_ptr, sz) do { \
<span class="lineNum">     113 </span>            :   ar_ptr = &amp;main_arena; \
<span class="lineNum">     114 </span>            :   if(!mutex_trylock(&amp;ar_ptr-&gt;mutex)) \
<span class="lineNum">     115 </span>            :     ++(ar_ptr-&gt;stat_lock_direct); \
<span class="lineNum">     116 </span>            :   else { \
<span class="lineNum">     117 </span>            :     (void)mutex_lock(&amp;ar_ptr-&gt;mutex); \
<span class="lineNum">     118 </span>            :     ++(ar_ptr-&gt;stat_lock_wait); \
<span class="lineNum">     119 </span>            :   } \
<span class="lineNum">     120 </span>            : } while(0)
<span class="lineNum">     121 </span>            : #else
<span class="lineNum">     122 </span>            : #define arena_get(ar_ptr, sz) do { \
<span class="lineNum">     123 </span>            :   ar_ptr = &amp;main_arena; \
<span class="lineNum">     124 </span>            :   (void)mutex_lock(&amp;ar_ptr-&gt;mutex); \
<span class="lineNum">     125 </span>            : } while(0)
<span class="lineNum">     126 </span>            : #endif
<span class="lineNum">     127 </span>            : #define arena_for_chunk(ptr) (&amp;main_arena)
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            : #endif /* USE_ARENAS */
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span>            : /**************************************************************************/
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            : #ifndef NO_THREADS
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span>            : /* atfork support.  */
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span>            : static __malloc_ptr_t (*save_malloc_hook) __MALLOC_P ((size_t __size,
<span class="lineNum">     138 </span>            :                                                        __const __malloc_ptr_t));
<span class="lineNum">     139 </span>            : # if !defined _LIBC || !defined USE_TLS || (defined SHARED &amp;&amp; !USE___THREAD)
<span class="lineNum">     140 </span>            : static __malloc_ptr_t (*save_memalign_hook) __MALLOC_P ((size_t align,
<span class="lineNum">     141 </span>            :                                                          size_t __size,
<span class="lineNum">     142 </span>            :                                                        __const __malloc_ptr_t));
<span class="lineNum">     143 </span>            : # endif
<span class="lineNum">     144 </span>            : static void           (*save_free_hook) __MALLOC_P ((__malloc_ptr_t __ptr,
<span class="lineNum">     145 </span>            :                                                      __const __malloc_ptr_t));
<span class="lineNum">     146 </span>            : static Void_t*        save_arena;
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            : /* Magic value for the thread-specific arena pointer when
<span class="lineNum">     149 </span>            :    malloc_atfork() is in use.  */
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span>            : #define ATFORK_ARENA_PTR ((Void_t*)-1)
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span>            : /* The following hooks are used while the `atfork' handling mechanism
<span class="lineNum">     154 </span>            :    is active. */
<a name="155"><span class="lineNum">     155 </span>            : </a>
<span class="lineNum">     156 </span>            : static Void_t*
<span class="lineNum">     157 </span><span class="lineNoCov">          0 : malloc_atfork(size_t sz, const Void_t *caller)</span>
<span class="lineNum">     158 </span>            : {
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :   Void_t *vptr = NULL;</span>
<span class="lineNum">     160 </span>            :   Void_t *victim;
<span class="lineNum">     161 </span>            : 
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :   tsd_getspecific(arena_key, vptr);</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :   if(vptr == ATFORK_ARENA_PTR) {</span>
<span class="lineNum">     164 </span>            :     /* We are the only thread that may allocate at all.  */
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :     if(save_malloc_hook != malloc_check) {</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :       return _int_malloc(&amp;main_arena, sz);</span>
<span class="lineNum">     167 </span>            :     } else {
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :       if(top_check()&lt;0)</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :       victim = _int_malloc(&amp;main_arena, sz+1);</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :       return mem2mem_check(victim, sz);</span>
<span class="lineNum">     172 </span>            :     }
<span class="lineNum">     173 </span>            :   } else {
<span class="lineNum">     174 </span>            :     /* Suspend the thread until the `atfork' handlers have completed.
<span class="lineNum">     175 </span>            :        By that time, the hooks will have been reset as well, so that
<span class="lineNum">     176 </span>            :        mALLOc() can be used again. */
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :     (void)mutex_lock(&amp;list_lock);</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :     (void)mutex_unlock(&amp;list_lock);</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :     return public_mALLOc(sz);</span>
<span class="lineNum">     180 </span>            :   }
<span class="lineNum">     181 </span>            : }
<a name="182"><span class="lineNum">     182 </span>            : </a>
<span class="lineNum">     183 </span>            : static void
<span class="lineNum">     184 </span><span class="lineNoCov">          0 : free_atfork(Void_t* mem, const Void_t *caller)</span>
<span class="lineNum">     185 </span>            : {
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :   Void_t *vptr = NULL;</span>
<span class="lineNum">     187 </span>            :   mstate ar_ptr;
<span class="lineNum">     188 </span>            :   mchunkptr p;                          /* chunk corresponding to mem */
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :   if (mem == 0)                              /* free(0) has no effect */</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :   p = mem2chunk(mem);         /* do not bother to replicate free_check here */</span>
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span>            : #if HAVE_MMAP
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :   if (chunk_is_mmapped(p))                       /* release mmapped memory. */</span>
<span class="lineNum">     197 </span>            :   {
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :     munmap_chunk(p);</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     200 </span>            :   }
<span class="lineNum">     201 </span>            : #endif
<span class="lineNum">     202 </span>            : 
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :   ar_ptr = arena_for_chunk(p);</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :   tsd_getspecific(arena_key, vptr);</span>
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :   if(vptr != ATFORK_ARENA_PTR)</span>
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :     (void)mutex_lock(&amp;ar_ptr-&gt;mutex);</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :   _int_free(ar_ptr, mem);</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :   if(vptr != ATFORK_ARENA_PTR)</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :     (void)mutex_unlock(&amp;ar_ptr-&gt;mutex);</span>
<span class="lineNum">     210 </span>            : }
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span>            : /* The following two functions are registered via thread_atfork() to
<span class="lineNum">     213 </span>            :    make sure that the mutexes remain in a consistent state in the
<span class="lineNum">     214 </span>            :    fork()ed version of a thread.  Also adapt the malloc and free hooks
<span class="lineNum">     215 </span>            :    temporarily, because the `atfork' handler mechanism may use
<span class="lineNum">     216 </span>            :    malloc/free internally (e.g. in LinuxThreads). */
<a name="217"><span class="lineNum">     217 </span>            : </a>
<span class="lineNum">     218 </span>            : static void
<span class="lineNum">     219 </span><span class="lineNoCov">          0 : ptmalloc_lock_all __MALLOC_P((void))</span>
<span class="lineNum">     220 </span>            : {
<span class="lineNum">     221 </span>            :   mstate ar_ptr;
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :   if(__malloc_initialized &lt; 1)</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :   (void)mutex_lock(&amp;list_lock);</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :   for(ar_ptr = &amp;main_arena;;) {</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :     (void)mutex_lock(&amp;ar_ptr-&gt;mutex);</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :     ar_ptr = ar_ptr-&gt;next;</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :     if(ar_ptr == &amp;main_arena) break;</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :   save_malloc_hook = __malloc_hook;</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :   save_free_hook = __free_hook;</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :   __malloc_hook = malloc_atfork;</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :   __free_hook = free_atfork;</span>
<span class="lineNum">     235 </span>            :   /* Only the current thread may perform malloc/free calls now. */
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :   tsd_getspecific(arena_key, save_arena);</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :   tsd_setspecific(arena_key, ATFORK_ARENA_PTR);</span>
<span class="lineNum">     238 </span>            : }
<a name="239"><span class="lineNum">     239 </span>            : </a>
<span class="lineNum">     240 </span>            : static void
<span class="lineNum">     241 </span><span class="lineNoCov">          0 : ptmalloc_unlock_all __MALLOC_P((void))</span>
<span class="lineNum">     242 </span>            : {
<span class="lineNum">     243 </span>            :   mstate ar_ptr;
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :   if(__malloc_initialized &lt; 1)</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :   tsd_setspecific(arena_key, save_arena);</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :   __malloc_hook = save_malloc_hook;</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :   __free_hook = save_free_hook;</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :   for(ar_ptr = &amp;main_arena;;) {</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :     (void)mutex_unlock(&amp;ar_ptr-&gt;mutex);</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :     ar_ptr = ar_ptr-&gt;next;</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :     if(ar_ptr == &amp;main_arena) break;</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :   (void)mutex_unlock(&amp;list_lock);</span>
<span class="lineNum">     256 </span>            : }
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span>            : #ifdef __linux__
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span>            : /* In LinuxThreads, unlocking a mutex in the child process after a
<span class="lineNum">     261 </span>            :    fork() is currently unsafe, whereas re-initializing it is safe and
<span class="lineNum">     262 </span>            :    does not leak resources.  Therefore, a special atfork handler is
<span class="lineNum">     263 </span>            :    installed for the child. */
<a name="264"><span class="lineNum">     264 </span>            : </a>
<span class="lineNum">     265 </span>            : static void
<span class="lineNum">     266 </span><span class="lineNoCov">          0 : ptmalloc_unlock_all2 __MALLOC_P((void))</span>
<span class="lineNum">     267 </span>            : {
<span class="lineNum">     268 </span>            :   mstate ar_ptr;
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :   if(__malloc_initialized &lt; 1)</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     272 </span>            : #if defined _LIBC || defined MALLOC_HOOKS
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :   tsd_setspecific(arena_key, save_arena);</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :   __malloc_hook = save_malloc_hook;</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :   __free_hook = save_free_hook;</span>
<span class="lineNum">     276 </span>            : #endif
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :   for(ar_ptr = &amp;main_arena;;) {</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :     (void)mutex_init(&amp;ar_ptr-&gt;mutex);</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :     ar_ptr = ar_ptr-&gt;next;</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :     if(ar_ptr == &amp;main_arena) break;</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :   (void)mutex_init(&amp;list_lock);</span>
<span class="lineNum">     283 </span>            : }
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span>            : #else
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span>            : #define ptmalloc_unlock_all2 ptmalloc_unlock_all
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span>            : #endif
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span>            : #endif /* !defined NO_THREADS */
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            : /* Initialization routine. */
<span class="lineNum">     294 </span>            : #ifdef _LIBC
<span class="lineNum">     295 </span>            : #include &lt;string.h&gt;
<span class="lineNum">     296 </span>            : extern char **_environ;
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            : static char *
<span class="lineNum">     299 </span>            : internal_function
<span class="lineNum">     300 </span>            : next_env_entry (char ***position)
<span class="lineNum">     301 </span>            : {
<span class="lineNum">     302 </span>            :   char **current = *position;
<span class="lineNum">     303 </span>            :   char *result = NULL;
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span>            :   while (*current != NULL)
<span class="lineNum">     306 </span>            :     {
<span class="lineNum">     307 </span>            :       if (__builtin_expect ((*current)[0] == 'M', 0)
<span class="lineNum">     308 </span>            :           &amp;&amp; (*current)[1] == 'A'
<span class="lineNum">     309 </span>            :           &amp;&amp; (*current)[2] == 'L'
<span class="lineNum">     310 </span>            :           &amp;&amp; (*current)[3] == 'L'
<span class="lineNum">     311 </span>            :           &amp;&amp; (*current)[4] == 'O'
<span class="lineNum">     312 </span>            :           &amp;&amp; (*current)[5] == 'C'
<span class="lineNum">     313 </span>            :           &amp;&amp; (*current)[6] == '_')
<span class="lineNum">     314 </span>            :         {
<span class="lineNum">     315 </span>            :           result = &amp;(*current)[7];
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span>            :           /* Save current position for next visit.  */
<span class="lineNum">     318 </span>            :           *position = ++current;
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span>            :           break;
<span class="lineNum">     321 </span>            :         }
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span>            :       ++current;
<span class="lineNum">     324 </span>            :     }
<span class="lineNum">     325 </span>            : 
<span class="lineNum">     326 </span>            :   return result;
<span class="lineNum">     327 </span>            : }
<span class="lineNum">     328 </span>            : #endif /* _LIBC */
<span class="lineNum">     329 </span>            : 
<a name="330"><span class="lineNum">     330 </span>            : /* Set up basic state so that _int_malloc et al can work.  */</a>
<span class="lineNum">     331 </span>            : static void
<span class="lineNum">     332 </span><span class="lineNoCov">          0 : ptmalloc_init_minimal __MALLOC_P((void))</span>
<span class="lineNum">     333 </span>            : {
<span class="lineNum">     334 </span>            : #if DEFAULT_TOP_PAD != 0
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :   mp_.top_pad        = DEFAULT_TOP_PAD;</span>
<span class="lineNum">     336 </span>            : #endif
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :   mp_.n_mmaps_max    = DEFAULT_MMAP_MAX;</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :   mp_.mmap_threshold = DEFAULT_MMAP_THRESHOLD;</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :   mp_.trim_threshold = DEFAULT_TRIM_THRESHOLD;</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :   mp_.pagesize       = malloc_getpagesize;</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span>            : #if !(USE_STARTER &amp; 2)
<span class="lineNum">     345 </span>            : static
<a name="346"><span class="lineNum">     346 </span>            : #endif</a>
<span class="lineNum">     347 </span>            : void
<span class="lineNum">     348 </span><span class="lineNoCov">          0 : ptmalloc_init __MALLOC_P((void))</span>
<span class="lineNum">     349 </span>            : {
<span class="lineNum">     350 </span>            : #if __STD_C
<span class="lineNum">     351 </span>            :   const char* s;
<span class="lineNum">     352 </span>            : #else
<span class="lineNum">     353 </span>            :   char* s;
<span class="lineNum">     354 </span>            : #endif
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :   int secure = 0;</span>
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :   if(__malloc_initialized &gt;= 0) return;</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :   __malloc_initialized = 0;</span>
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :   if (mp_.pagesize == 0)</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :     ptmalloc_init_minimal();</span>
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span>            : #ifndef NO_THREADS
<span class="lineNum">     364 </span>            : # if USE_STARTER &amp; 1
<span class="lineNum">     365 </span>            :   /* With some threads implementations, creating thread-specific data
<span class="lineNum">     366 </span>            :      or initializing a mutex may call malloc() itself.  Provide a
<span class="lineNum">     367 </span>            :      simple starter version (realloc() won't work). */
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :   save_malloc_hook = __malloc_hook;</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :   save_memalign_hook = __memalign_hook;</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :   save_free_hook = __free_hook;</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :   __malloc_hook = malloc_starter;</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :   __memalign_hook = memalign_starter;</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :   __free_hook = free_starter;</span>
<span class="lineNum">     374 </span>            : #  ifdef _LIBC
<span class="lineNum">     375 </span>            :   /* Initialize the pthreads interface. */
<span class="lineNum">     376 </span>            :   if (__pthread_initialize != NULL)
<span class="lineNum">     377 </span>            :     __pthread_initialize();
<span class="lineNum">     378 </span>            : #  endif /* !defined _LIBC */
<span class="lineNum">     379 </span>            : # endif /* USE_STARTER &amp; 1 */
<span class="lineNum">     380 </span>            : #endif /* !defined NO_THREADS */
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :   mutex_init(&amp;main_arena.mutex);</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :   main_arena.next = &amp;main_arena;</span>
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :   mutex_init(&amp;list_lock);</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :   tsd_key_create(&amp;arena_key, NULL);</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :   tsd_setspecific(arena_key, (Void_t *)&amp;main_arena);</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :   thread_atfork(ptmalloc_lock_all, ptmalloc_unlock_all, ptmalloc_unlock_all2);</span>
<span class="lineNum">     388 </span>            : #ifndef NO_THREADS
<span class="lineNum">     389 </span>            : # if USE_STARTER &amp; 1
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :   __malloc_hook = save_malloc_hook;</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :   __memalign_hook = save_memalign_hook;</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :   __free_hook = save_free_hook;</span>
<span class="lineNum">     393 </span>            : # endif
<span class="lineNum">     394 </span>            : # if USE_STARTER &amp; 2
<span class="lineNum">     395 </span>            :   __malloc_hook = 0;
<span class="lineNum">     396 </span>            :   __memalign_hook = 0;
<span class="lineNum">     397 </span>            :   __free_hook = 0;
<span class="lineNum">     398 </span>            : # endif
<span class="lineNum">     399 </span>            : #endif
<span class="lineNum">     400 </span>            : #ifdef _LIBC
<span class="lineNum">     401 </span>            :   secure = __libc_enable_secure;
<span class="lineNum">     402 </span>            :   s = NULL;
<span class="lineNum">     403 </span>            :   if (__builtin_expect (_environ != NULL, 1))
<span class="lineNum">     404 </span>            :     {
<span class="lineNum">     405 </span>            :       char **runp = _environ;
<span class="lineNum">     406 </span>            :       char *envline;
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span>            :       while (__builtin_expect ((envline = next_env_entry (&amp;runp)) != NULL,
<span class="lineNum">     409 </span>            :                                0))
<span class="lineNum">     410 </span>            :         {
<span class="lineNum">     411 </span>            :           size_t len = strcspn (envline, &quot;=&quot;);
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span>            :           if (envline[len] != '=')
<span class="lineNum">     414 </span>            :             /* This is a &quot;MALLOC_&quot; variable at the end of the string
<span class="lineNum">     415 </span>            :                without a '=' character.  Ignore it since otherwise we
<span class="lineNum">     416 </span>            :                will access invalid memory below.  */
<span class="lineNum">     417 </span>            :             continue;
<span class="lineNum">     418 </span>            : 
<span class="lineNum">     419 </span>            :           switch (len)
<span class="lineNum">     420 </span>            :             {
<span class="lineNum">     421 </span>            :             case 6:
<span class="lineNum">     422 </span>            :               if (memcmp (envline, &quot;CHECK_&quot;, 6) == 0)
<span class="lineNum">     423 </span>            :                 s = &amp;envline[7];
<span class="lineNum">     424 </span>            :               break;
<span class="lineNum">     425 </span>            :             case 8:
<span class="lineNum">     426 </span>            :               if (! secure &amp;&amp; memcmp (envline, &quot;TOP_PAD_&quot;, 8) == 0)
<span class="lineNum">     427 </span>            :                 mALLOPt(M_TOP_PAD, atoi(&amp;envline[9]));
<span class="lineNum">     428 </span>            :               break;
<span class="lineNum">     429 </span>            :             case 9:
<span class="lineNum">     430 </span>            :               if (! secure &amp;&amp; memcmp (envline, &quot;MMAP_MAX_&quot;, 9) == 0)
<span class="lineNum">     431 </span>            :                 mALLOPt(M_MMAP_MAX, atoi(&amp;envline[10]));
<span class="lineNum">     432 </span>            :               break;
<span class="lineNum">     433 </span>            :             case 15:
<span class="lineNum">     434 </span>            :               if (! secure)
<span class="lineNum">     435 </span>            :                 {
<span class="lineNum">     436 </span>            :                   if (memcmp (envline, &quot;TRIM_THRESHOLD_&quot;, 15) == 0)
<span class="lineNum">     437 </span>            :                     mALLOPt(M_TRIM_THRESHOLD, atoi(&amp;envline[16]));
<span class="lineNum">     438 </span>            :                   else if (memcmp (envline, &quot;MMAP_THRESHOLD_&quot;, 15) == 0)
<span class="lineNum">     439 </span>            :                     mALLOPt(M_MMAP_THRESHOLD, atoi(&amp;envline[16]));
<span class="lineNum">     440 </span>            :                 }
<span class="lineNum">     441 </span>            :               break;
<span class="lineNum">     442 </span>            :             default:
<span class="lineNum">     443 </span>            :               break;
<span class="lineNum">     444 </span>            :             }
<span class="lineNum">     445 </span>            :         }
<span class="lineNum">     446 </span>            :     }
<span class="lineNum">     447 </span>            : #else
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :   if (! secure)</span>
<span class="lineNum">     449 </span>            :     {
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :       if((s = getenv(&quot;MALLOC_TRIM_THRESHOLD_&quot;)))</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :         mALLOPt(M_TRIM_THRESHOLD, atoi(s));</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :       if((s = getenv(&quot;MALLOC_TOP_PAD_&quot;)))</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :         mALLOPt(M_TOP_PAD, atoi(s));</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :       if((s = getenv(&quot;MALLOC_MMAP_THRESHOLD_&quot;)))</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :         mALLOPt(M_MMAP_THRESHOLD, atoi(s));</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :       if((s = getenv(&quot;MALLOC_MMAP_MAX_&quot;)))</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :         mALLOPt(M_MMAP_MAX, atoi(s));</span>
<span class="lineNum">     458 </span>            :     }
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :   s = getenv(&quot;MALLOC_CHECK_&quot;);</span>
<span class="lineNum">     460 </span>            : #endif
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :   if(s) {</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :     if(s[0]) mALLOPt(M_CHECK_ACTION, (int)(s[0] - '0'));</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :     __malloc_check_init();</span>
<span class="lineNum">     464 </span>            :   }
<span class="lineNum">     465 </span>            : #if 0
<span class="lineNum">     466 </span>            :   /* OMPI Change: Don't call the initialize hook; it was us. */
<span class="lineNum">     467 </span>            :   if(__malloc_initialize_hook != NULL)
<span class="lineNum">     468 </span>            :     (*__malloc_initialize_hook)();
<span class="lineNum">     469 </span>            : #endif
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :   __malloc_initialized = 1;</span>
<span class="lineNum">     472 </span>            : }
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span>            : /* There are platforms (e.g. Hurd) with a link-time hook mechanism. */
<span class="lineNum">     475 </span>            : #ifdef thread_atfork_static
<span class="lineNum">     476 </span>            : thread_atfork_static(ptmalloc_lock_all, ptmalloc_unlock_all, \
<span class="lineNum">     477 </span>            :                      ptmalloc_unlock_all2)
<span class="lineNum">     478 </span>            : #endif
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span>            : /* Managing heaps and arenas (for concurrent threads) */
<span class="lineNum">     483 </span>            : 
<span class="lineNum">     484 </span>            : #if USE_ARENAS
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            : #if MALLOC_DEBUG &gt; 1
<span class="lineNum">     487 </span>            : 
<span class="lineNum">     488 </span>            : /* Print the complete contents of a single heap to stderr. */
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span>            : static void
<span class="lineNum">     491 </span>            : #if __STD_C
<span class="lineNum">     492 </span>            : dump_heap(heap_info *heap)
<span class="lineNum">     493 </span>            : #else
<span class="lineNum">     494 </span>            : dump_heap(heap) heap_info *heap;
<span class="lineNum">     495 </span>            : #endif
<span class="lineNum">     496 </span>            : {
<span class="lineNum">     497 </span>            :   char *ptr;
<span class="lineNum">     498 </span>            :   mchunkptr p;
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span>            :   fprintf(stderr, &quot;Heap %p, size %10lx:\n&quot;, heap, (long)heap-&gt;size);
<span class="lineNum">     501 </span>            :   ptr = (heap-&gt;ar_ptr != (mstate)(heap+1)) ?
<span class="lineNum">     502 </span>            :     (char*)(heap + 1) : (char*)(heap + 1) + sizeof(struct malloc_state);
<span class="lineNum">     503 </span>            :   p = (mchunkptr)(((unsigned long)ptr + MALLOC_ALIGN_MASK) &amp;
<span class="lineNum">     504 </span>            :                   ~MALLOC_ALIGN_MASK);
<span class="lineNum">     505 </span>            :   for(;;) {
<span class="lineNum">     506 </span>            :     fprintf(stderr, &quot;chunk %p size %10lx&quot;, p, (long)p-&gt;size);
<span class="lineNum">     507 </span>            :     if(p == top(heap-&gt;ar_ptr)) {
<span class="lineNum">     508 </span>            :       fprintf(stderr, &quot; (top)\n&quot;);
<span class="lineNum">     509 </span>            :       break;
<span class="lineNum">     510 </span>            :     } else if(p-&gt;size == (0|PREV_INUSE)) {
<span class="lineNum">     511 </span>            :       fprintf(stderr, &quot; (fence)\n&quot;);
<span class="lineNum">     512 </span>            :       break;
<span class="lineNum">     513 </span>            :     }
<span class="lineNum">     514 </span>            :     fprintf(stderr, &quot;\n&quot;);
<span class="lineNum">     515 </span>            :     p = next_chunk(p);
<span class="lineNum">     516 </span>            :   }
<span class="lineNum">     517 </span>            : }
<span class="lineNum">     518 </span>            : 
<span class="lineNum">     519 </span>            : #endif /* MALLOC_DEBUG &gt; 1 */
<span class="lineNum">     520 </span>            : 
<span class="lineNum">     521 </span>            : /* Create a new heap.  size is automatically rounded up to a multiple
<span class="lineNum">     522 </span>            :    of the page size. */
<span class="lineNum">     523 </span>            : 
<span class="lineNum">     524 </span>            : static heap_info *
<a name="525"><span class="lineNum">     525 </span>            : internal_function</a>
<span class="lineNum">     526 </span>            : #if __STD_C
<span class="lineNum">     527 </span><span class="lineNoCov">          0 : new_heap(size_t size, size_t top_pad)</span>
<span class="lineNum">     528 </span>            : #else
<span class="lineNum">     529 </span>            : new_heap(size, top_pad) size_t size, top_pad;
<span class="lineNum">     530 </span>            : #endif
<span class="lineNum">     531 </span>            : {
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :   size_t page_mask = malloc_getpagesize - 1;</span>
<span class="lineNum">     533 </span>            :   char *p1, *p2;
<span class="lineNum">     534 </span>            :   unsigned long ul;
<span class="lineNum">     535 </span>            :   heap_info *h;
<span class="lineNum">     536 </span>            : 
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :   if(size+top_pad &lt; HEAP_MIN_SIZE)</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :     size = HEAP_MIN_SIZE;</span>
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :   else if(size+top_pad &lt;= HEAP_MAX_SIZE)</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :     size += top_pad;</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :   else if(size &gt; HEAP_MAX_SIZE)</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     543 </span>            :   else
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :     size = HEAP_MAX_SIZE;</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :   size = (size + page_mask) &amp; ~page_mask;</span>
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span>            :   /* A memory region aligned to a multiple of HEAP_MAX_SIZE is needed.
<span class="lineNum">     548 </span>            :      No swap space needs to be reserved for the following large
<span class="lineNum">     549 </span>            :      mapping (on Linux, this is the case for all non-writable mappings
<span class="lineNum">     550 </span>            :      anyway). */
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :   p1 = (char *)MMAP(0, HEAP_MAX_SIZE&lt;&lt;1, PROT_NONE, MAP_PRIVATE|MAP_NORESERVE);</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :   if(p1 != MAP_FAILED) {</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :     p2 = (char *)(((unsigned long)p1 + (HEAP_MAX_SIZE-1)) &amp; ~(HEAP_MAX_SIZE-1));</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :     ul = p2 - p1;</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :     munmap(p1, ul);</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :     munmap(p2 + HEAP_MAX_SIZE, HEAP_MAX_SIZE - ul);</span>
<span class="lineNum">     557 </span>            :   } else {
<span class="lineNum">     558 </span>            :     /* Try to take the chance that an allocation of only HEAP_MAX_SIZE
<span class="lineNum">     559 </span>            :        is already aligned. */
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :     p2 = (char *)MMAP(0, HEAP_MAX_SIZE, PROT_NONE, MAP_PRIVATE|MAP_NORESERVE);</span>
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :     if(p2 == MAP_FAILED)</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :       return 0;</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :     if((unsigned long)p2 &amp; (HEAP_MAX_SIZE-1)) {</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :       munmap(p2, HEAP_MAX_SIZE);</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :       return 0;</span>
<span class="lineNum">     566 </span>            :     }
<span class="lineNum">     567 </span>            :   }
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :   if(mprotect(p2, size, PROT_READ|PROT_WRITE) != 0) {</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :     munmap(p2, HEAP_MAX_SIZE);</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     571 </span>            :   }
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :   h = (heap_info *)p2;</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :   h-&gt;size = size;</span>
<span class="lineNum">     574 </span>            :   THREAD_STAT(stat_n_heaps++);
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :   return h;</span>
<span class="lineNum">     576 </span>            : }
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span>            : /* Grow or shrink a heap.  size is automatically rounded up to a
<span class="lineNum">     579 </span>            :    multiple of the page size if it is positive. */
<span class="lineNum">     580 </span>            : 
<a name="581"><span class="lineNum">     581 </span>            : static int</a>
<span class="lineNum">     582 </span>            : #if __STD_C
<span class="lineNum">     583 </span><span class="lineNoCov">          0 : grow_heap(heap_info *h, long diff)</span>
<span class="lineNum">     584 </span>            : #else
<span class="lineNum">     585 </span>            : grow_heap(h, diff) heap_info *h; long diff;
<span class="lineNum">     586 </span>            : #endif
<span class="lineNum">     587 </span>            : {
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :   size_t page_mask = malloc_getpagesize - 1;</span>
<span class="lineNum">     589 </span>            :   long new_size;
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :   if(diff &gt;= 0) {</span>
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :     diff = (diff + page_mask) &amp; ~page_mask;</span>
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :     new_size = (long)h-&gt;size + diff;</span>
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :     if(new_size &gt; HEAP_MAX_SIZE)</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :       return -1;</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :     if(mprotect((char *)h + h-&gt;size, diff, PROT_READ|PROT_WRITE) != 0)</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :       return -2;</span>
<span class="lineNum">     598 </span>            :   } else {
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :     new_size = (long)h-&gt;size + diff;</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :     if(new_size &lt; (long)sizeof(*h))</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :       return -1;</span>
<span class="lineNum">     602 </span>            : 
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :     if(mprotect((char *)h + new_size, -diff, PROT_NONE) != 0)</span>
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :       return -2;</span>
<span class="lineNum">     605 </span>            :     /*fprintf(stderr, &quot;shrink %p %08lx\n&quot;, h, new_size);*/
<span class="lineNum">     606 </span>            :   }
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :   h-&gt;size = new_size;</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">     609 </span>            : }
<span class="lineNum">     610 </span>            : 
<span class="lineNum">     611 </span>            : /* Delete a heap. */
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span>            : #define delete_heap(heap) munmap((char*)(heap), HEAP_MAX_SIZE)
<span class="lineNum">     614 </span>            : 
<span class="lineNum">     615 </span>            : static int
<a name="616"><span class="lineNum">     616 </span>            : internal_function</a>
<span class="lineNum">     617 </span>            : #if __STD_C
<span class="lineNum">     618 </span><span class="lineNoCov">          0 : heap_trim(heap_info *heap, size_t pad)</span>
<span class="lineNum">     619 </span>            : #else
<span class="lineNum">     620 </span>            : heap_trim(heap, pad) heap_info *heap; size_t pad;
<span class="lineNum">     621 </span>            : #endif
<span class="lineNum">     622 </span>            : {
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :   mstate ar_ptr = heap-&gt;ar_ptr;</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :   unsigned long pagesz = mp_.pagesize;</span>
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :   mchunkptr top_chunk = top(ar_ptr), p, bck, fwd;</span>
<span class="lineNum">     626 </span>            :   heap_info *prev_heap;
<span class="lineNum">     627 </span>            :   long new_size, top_size, extra;
<span class="lineNum">     628 </span>            : 
<span class="lineNum">     629 </span>            :   /* Can this heap go away completely? */
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :   while(top_chunk == chunk_at_offset(heap, sizeof(*heap))) {</span>
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :     prev_heap = heap-&gt;prev;</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :     p = chunk_at_offset(prev_heap, prev_heap-&gt;size - (MINSIZE-2*SIZE_SZ));</span>
<span class="lineNum">     633 </span>            :     assert(p-&gt;size == (0|PREV_INUSE)); /* must be fencepost */
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :     p = prev_chunk(p);</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :     new_size = chunksize(p) + (MINSIZE-2*SIZE_SZ);</span>
<span class="lineNum">     636 </span>            :     assert(new_size&gt;0 &amp;&amp; new_size&lt;(long)(2*MINSIZE));
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :     if(!prev_inuse(p))</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :       new_size += p-&gt;prev_size;</span>
<span class="lineNum">     639 </span>            :     assert(new_size&gt;0 &amp;&amp; new_size&lt;HEAP_MAX_SIZE);
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :     if(new_size + (HEAP_MAX_SIZE - prev_heap-&gt;size) &lt; pad + MINSIZE + pagesz)</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :     ar_ptr-&gt;system_mem -= heap-&gt;size;</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :     arena_mem -= heap-&gt;size;</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :     delete_heap(heap);</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :     heap = prev_heap;</span>
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :     if(!prev_inuse(p)) { /* consolidate backward */</span>
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :       p = prev_chunk(p);</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :       unlink(p, bck, fwd);</span>
<span class="lineNum">     649 </span>            :     }
<span class="lineNum">     650 </span>            :     assert(((unsigned long)((char*)p + new_size) &amp; (pagesz-1)) == 0);
<span class="lineNum">     651 </span>            :     assert( ((char*)p + new_size) == ((char*)heap + heap-&gt;size) );
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :     top(ar_ptr) = top_chunk = p;</span>
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :     set_head(top_chunk, new_size | PREV_INUSE);</span>
<span class="lineNum">     654 </span>            :     /*check_chunk(ar_ptr, top_chunk);*/
<span class="lineNum">     655 </span>            :   }
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :   top_size = chunksize(top_chunk);</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :   extra = ((top_size - pad - MINSIZE + (pagesz-1))/pagesz - 1) * pagesz;</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :   if(extra &lt; (long)pagesz)</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     660 </span>            :   /* Try to shrink. */
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :   if(grow_heap(heap, -extra) != 0)</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :   ar_ptr-&gt;system_mem -= extra;</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :   arena_mem -= extra;</span>
<span class="lineNum">     665 </span>            : 
<span class="lineNum">     666 </span>            :   /* Success. Adjust top accordingly. */
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :   set_head(top_chunk, (top_size - extra) | PREV_INUSE);</span>
<span class="lineNum">     668 </span>            :   /*check_chunk(ar_ptr, top_chunk);*/
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :   return 1;</span>
<span class="lineNum">     670 </span>            : }
<span class="lineNum">     671 </span>            : 
<span class="lineNum">     672 </span>            : static mstate
<a name="673"><span class="lineNum">     673 </span>            : internal_function</a>
<span class="lineNum">     674 </span>            : #if __STD_C
<span class="lineNum">     675 </span><span class="lineNoCov">          0 : arena_get2(mstate a_tsd, size_t size)</span>
<span class="lineNum">     676 </span>            : #else
<span class="lineNum">     677 </span>            : arena_get2(a_tsd, size) mstate a_tsd; size_t size;
<span class="lineNum">     678 </span>            : #endif
<span class="lineNum">     679 </span>            : {
<span class="lineNum">     680 </span>            :   mstate a;
<span class="lineNum">     681 </span>            :   int err;
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :   if(!a_tsd)</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :     a = a_tsd = &amp;main_arena;</span>
<span class="lineNum">     685 </span>            :   else {
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :     a = a_tsd-&gt;next;</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :     if(!a) {</span>
<span class="lineNum">     688 </span>            :       /* This can only happen while initializing the new arena. */
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :       (void)mutex_lock(&amp;main_arena.mutex);</span>
<span class="lineNum">     690 </span>            :       THREAD_STAT(++(main_arena.stat_lock_wait));
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :       return &amp;main_arena;</span>
<span class="lineNum">     692 </span>            :     }
<span class="lineNum">     693 </span>            :   }
<span class="lineNum">     694 </span>            : 
<span class="lineNum">     695 </span>            :   /* Check the global, circularly linked list for available arenas. */
<span class="lineNum">     696 </span>            :  repeat:
<span class="lineNum">     697 </span>            :   do {
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :     if(!mutex_trylock(&amp;a-&gt;mutex)) {</span>
<span class="lineNum">     699 </span>            :       THREAD_STAT(++(a-&gt;stat_lock_loop));
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :       tsd_setspecific(arena_key, (Void_t *)a);</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :       return a;</span>
<span class="lineNum">     702 </span>            :     }
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :     a = a-&gt;next;</span>
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :   } while(a != a_tsd);</span>
<span class="lineNum">     705 </span>            : 
<span class="lineNum">     706 </span>            :   /* If not even the list_lock can be obtained, try again.  This can
<span class="lineNum">     707 </span>            :      happen during `atfork', or for example on systems where thread
<span class="lineNum">     708 </span>            :      creation makes it temporarily impossible to obtain _any_
<span class="lineNum">     709 </span>            :      locks. */
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :   if(mutex_trylock(&amp;list_lock)) {</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :     a = a_tsd;</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :     goto repeat;</span>
<span class="lineNum">     713 </span>            :   }
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :   (void)mutex_unlock(&amp;list_lock);</span>
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span>            :   /* Nothing immediately available, so generate a new arena.  */
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :   a = _int_new_arena(size);</span>
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :   if(!a)</span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     720 </span>            : 
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :   tsd_setspecific(arena_key, (Void_t *)a);</span>
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :   mutex_init(&amp;a-&gt;mutex);</span>
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :   err = mutex_lock(&amp;a-&gt;mutex); /* remember result */</span>
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span>            :   /* Add the new arena to the global list.  */
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :   (void)mutex_lock(&amp;list_lock);</span>
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :   a-&gt;next = main_arena.next;</span>
<span class="lineNum">     728 </span>            : /* OMPI: use our barriers
<span class="lineNum">     729 </span>            :   atomic_write_barrier ();
<span class="lineNum">     730 </span>            : */
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :   opal_atomic_wmb();</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :   main_arena.next = a;</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :   (void)mutex_unlock(&amp;list_lock);</span>
<span class="lineNum">     734 </span>            : 
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :   if(err) /* locking failed; keep arena for further attempts later */</span>
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     737 </span>            : 
<span class="lineNum">     738 </span>            :   THREAD_STAT(++(a-&gt;stat_lock_loop));
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :   return a;</span>
<span class="lineNum">     740 </span>            : }
<span class="lineNum">     741 </span>            : 
<span class="lineNum">     742 </span>            : /* Create a new arena with initial size &quot;size&quot;.  */
<a name="743"><span class="lineNum">     743 </span>            : </a>
<span class="lineNum">     744 </span>            : mstate
<span class="lineNum">     745 </span><span class="lineNoCov">          0 : _int_new_arena(size_t size)</span>
<span class="lineNum">     746 </span>            : {
<span class="lineNum">     747 </span>            :   mstate a;
<span class="lineNum">     748 </span>            :   heap_info *h;
<span class="lineNum">     749 </span>            :   char *ptr;
<span class="lineNum">     750 </span>            :   unsigned long misalign;
<span class="lineNum">     751 </span>            : 
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :   h = new_heap(size + (sizeof(*h) + sizeof(*a) + MALLOC_ALIGNMENT),</span>
<span class="lineNum">     753 </span>            :                mp_.top_pad);
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :   if(!h) {</span>
<span class="lineNum">     755 </span>            :     /* Maybe size is too large to fit in a single heap.  So, just try
<span class="lineNum">     756 </span>            :        to create a minimally-sized arena and let _int_malloc() attempt
<span class="lineNum">     757 </span>            :        to deal with the large request via mmap_chunk().  */
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :     h = new_heap(sizeof(*h) + sizeof(*a) + MALLOC_ALIGNMENT, mp_.top_pad);</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :     if(!h)</span>
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :       return 0;</span>
<span class="lineNum">     761 </span>            :   }
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :   a = h-&gt;ar_ptr = (mstate)(h+1);</span>
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :   malloc_init_state(a);</span>
<span class="lineNum">     764 </span>            :   /*a-&gt;next = NULL;*/
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :   a-&gt;system_mem = a-&gt;max_system_mem = h-&gt;size;</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :   arena_mem += h-&gt;size;</span>
<span class="lineNum">     767 </span>            : #ifdef NO_THREADS
<span class="lineNum">     768 </span>            :   if((unsigned long)(mp_.mmapped_mem + arena_mem + main_arena.system_mem) &gt;
<span class="lineNum">     769 </span>            :      mp_.max_total_mem)
<span class="lineNum">     770 </span>            :     mp_.max_total_mem = mp_.mmapped_mem + arena_mem + main_arena.system_mem;
<span class="lineNum">     771 </span>            : #endif
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span>            :   /* Set up the top chunk, with proper alignment. */
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :   ptr = (char *)(a + 1);</span>
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :   misalign = (unsigned long)chunk2mem(ptr) &amp; MALLOC_ALIGN_MASK;</span>
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :   if (misalign &gt; 0)</span>
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :     ptr += MALLOC_ALIGNMENT - misalign;</span>
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :   top(a) = (mchunkptr)ptr;</span>
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :   set_head(top(a), (((char*)h + h-&gt;size) - ptr) | PREV_INUSE);</span>
<span class="lineNum">     780 </span>            : 
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :   return a;</span>
<span class="lineNum">     782 </span>            : }
<span class="lineNum">     783 </span>            : 
<span class="lineNum">     784 </span>            : /* Obtain the arena number n.  Needed in malloc_stats.  */
<a name="785"><span class="lineNum">     785 </span>            : </a>
<span class="lineNum">     786 </span>            : mstate
<span class="lineNum">     787 </span><span class="lineNoCov">          0 : _int_get_arena (int n)</span>
<span class="lineNum">     788 </span>            : {
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :   mstate a = &amp;main_arena;</span>
<span class="lineNum">     790 </span>            : 
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :   while (n-- != 0) {</span>
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :     a = a-&gt;next;</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :     if (a == &amp;main_arena)</span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :       return 0;</span>
<span class="lineNum">     795 </span>            :   }
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :   return a;</span>
<span class="lineNum">     797 </span>            : }
<span class="lineNum">     798 </span>            : 
<span class="lineNum">     799 </span>            : #endif /* USE_ARENAS */
<span class="lineNum">     800 </span>            : 
<span class="lineNum">     801 </span>            : /*
<span class="lineNum">     802 </span>            :  * Local variables:
<span class="lineNum">     803 </span>            :  * c-basic-offset: 2
<span class="lineNum">     804 </span>            :  * End:
<span class="lineNum">     805 </span>            :  */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
