<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - master-ibm-intel - /usr/include/infiniband/verbs.h</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">usr/include/infiniband</a> - verbs.h<span style="font-size: 80%;"> (source / <a href="verbs.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">master-ibm-intel</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">58</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2015-07-30 16:27:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">13</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Copyright (c) 2004, 2005 Topspin Communications.  All rights reserved.
<span class="lineNum">       3 </span>            :  * Copyright (c) 2004, 2011-2012 Intel Corporation.  All rights reserved.
<span class="lineNum">       4 </span>            :  * Copyright (c) 2005, 2006, 2007 Cisco Systems, Inc.  All rights reserved.
<span class="lineNum">       5 </span>            :  * Copyright (c) 2005 PathScale, Inc.  All rights reserved.
<span class="lineNum">       6 </span>            :  *
<span class="lineNum">       7 </span>            :  * This software is available to you under a choice of one of two
<span class="lineNum">       8 </span>            :  * licenses.  You may choose to be licensed under the terms of the GNU
<span class="lineNum">       9 </span>            :  * General Public License (GPL) Version 2, available from the file
<span class="lineNum">      10 </span>            :  * COPYING in the main directory of this source tree, or the
<span class="lineNum">      11 </span>            :  * OpenIB.org BSD license below:
<span class="lineNum">      12 </span>            :  *
<span class="lineNum">      13 </span>            :  *     Redistribution and use in source and binary forms, with or
<span class="lineNum">      14 </span>            :  *     without modification, are permitted provided that the following
<span class="lineNum">      15 </span>            :  *     conditions are met:
<span class="lineNum">      16 </span>            :  *
<span class="lineNum">      17 </span>            :  *      - Redistributions of source code must retain the above
<span class="lineNum">      18 </span>            :  *        copyright notice, this list of conditions and the following
<span class="lineNum">      19 </span>            :  *        disclaimer.
<span class="lineNum">      20 </span>            :  *
<span class="lineNum">      21 </span>            :  *      - Redistributions in binary form must reproduce the above
<span class="lineNum">      22 </span>            :  *        copyright notice, this list of conditions and the following
<span class="lineNum">      23 </span>            :  *        disclaimer in the documentation and/or other materials
<span class="lineNum">      24 </span>            :  *        provided with the distribution.
<span class="lineNum">      25 </span>            :  *
<span class="lineNum">      26 </span>            :  * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
<span class="lineNum">      27 </span>            :  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
<span class="lineNum">      28 </span>            :  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
<span class="lineNum">      29 </span>            :  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
<span class="lineNum">      30 </span>            :  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
<span class="lineNum">      31 </span>            :  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
<span class="lineNum">      32 </span>            :  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
<span class="lineNum">      33 </span>            :  * SOFTWARE.
<span class="lineNum">      34 </span>            :  */
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            : #ifndef INFINIBAND_VERBS_H
<span class="lineNum">      37 </span>            : #define INFINIBAND_VERBS_H
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : #include &lt;stdint.h&gt;
<span class="lineNum">      40 </span>            : #include &lt;pthread.h&gt;
<span class="lineNum">      41 </span>            : #include &lt;stddef.h&gt;
<span class="lineNum">      42 </span>            : #include &lt;errno.h&gt;
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            : #ifdef __cplusplus
<span class="lineNum">      45 </span>            : #  define BEGIN_C_DECLS extern &quot;C&quot; {
<span class="lineNum">      46 </span>            : #  define END_C_DECLS   }
<span class="lineNum">      47 </span>            : #else /* !__cplusplus */
<span class="lineNum">      48 </span>            : #  define BEGIN_C_DECLS
<span class="lineNum">      49 </span>            : #  define END_C_DECLS
<span class="lineNum">      50 </span>            : #endif /* __cplusplus */
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            : #if __GNUC__ &gt;= 3
<span class="lineNum">      53 </span>            : #  define __attribute_const __attribute__((const))
<span class="lineNum">      54 </span>            : #else
<span class="lineNum">      55 </span>            : #  define __attribute_const
<span class="lineNum">      56 </span>            : #endif
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : BEGIN_C_DECLS
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            : union ibv_gid {
<span class="lineNum">      61 </span>            :         uint8_t                 raw[16];
<span class="lineNum">      62 </span>            :         struct {
<span class="lineNum">      63 </span>            :                 uint64_t        subnet_prefix;
<span class="lineNum">      64 </span>            :                 uint64_t        interface_id;
<span class="lineNum">      65 </span>            :         } global;
<span class="lineNum">      66 </span>            : };
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span>            : #ifndef container_of
<span class="lineNum">      69 </span>            : /**
<span class="lineNum">      70 </span>            :   * container_of - cast a member of a structure out to the containing structure
<span class="lineNum">      71 </span>            :   * @ptr:        the pointer to the member.
<span class="lineNum">      72 </span>            :   * @type:       the type of the container struct this is embedded in.
<span class="lineNum">      73 </span>            :   * @member:     the name of the member within the struct.
<span class="lineNum">      74 </span>            :   *
<span class="lineNum">      75 </span>            :  */
<span class="lineNum">      76 </span>            : #define container_of(ptr, type, member) \
<span class="lineNum">      77 </span>            :         ((type *) ((uint8_t *)(ptr) - offsetof(type, member)))
<span class="lineNum">      78 </span>            : #endif
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            : #define vext_field_avail(type, fld, sz) (offsetof(type, fld) &lt; (sz))
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span>            : static void *__VERBS_ABI_IS_EXTENDED = ((uint8_t *) NULL) - 1;
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span>            : enum ibv_node_type {
<span class="lineNum">      85 </span>            :         IBV_NODE_UNKNOWN        = -1,
<span class="lineNum">      86 </span>            :         IBV_NODE_CA             = 1,
<span class="lineNum">      87 </span>            :         IBV_NODE_SWITCH,
<span class="lineNum">      88 </span>            :         IBV_NODE_ROUTER,
<span class="lineNum">      89 </span>            :         IBV_NODE_RNIC,
<span class="lineNum">      90 </span>            :         IBV_NODE_USNIC,
<span class="lineNum">      91 </span>            :         IBV_NODE_USNIC_UDP,
<span class="lineNum">      92 </span>            : };
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span>            : enum ibv_transport_type {
<span class="lineNum">      95 </span>            :         IBV_TRANSPORT_UNKNOWN   = -1,
<span class="lineNum">      96 </span>            :         IBV_TRANSPORT_IB        = 0,
<span class="lineNum">      97 </span>            :         IBV_TRANSPORT_IWARP,
<span class="lineNum">      98 </span>            :         IBV_TRANSPORT_USNIC,
<span class="lineNum">      99 </span>            :         IBV_TRANSPORT_USNIC_UDP,
<span class="lineNum">     100 </span>            : };
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            : enum ibv_device_cap_flags {
<span class="lineNum">     103 </span>            :         IBV_DEVICE_RESIZE_MAX_WR        = 1,
<span class="lineNum">     104 </span>            :         IBV_DEVICE_BAD_PKEY_CNTR        = 1 &lt;&lt;  1,
<span class="lineNum">     105 </span>            :         IBV_DEVICE_BAD_QKEY_CNTR        = 1 &lt;&lt;  2,
<span class="lineNum">     106 </span>            :         IBV_DEVICE_RAW_MULTI            = 1 &lt;&lt;  3,
<span class="lineNum">     107 </span>            :         IBV_DEVICE_AUTO_PATH_MIG        = 1 &lt;&lt;  4,
<span class="lineNum">     108 </span>            :         IBV_DEVICE_CHANGE_PHY_PORT      = 1 &lt;&lt;  5,
<span class="lineNum">     109 </span>            :         IBV_DEVICE_UD_AV_PORT_ENFORCE   = 1 &lt;&lt;  6,
<span class="lineNum">     110 </span>            :         IBV_DEVICE_CURR_QP_STATE_MOD    = 1 &lt;&lt;  7,
<span class="lineNum">     111 </span>            :         IBV_DEVICE_SHUTDOWN_PORT        = 1 &lt;&lt;  8,
<span class="lineNum">     112 </span>            :         IBV_DEVICE_INIT_TYPE            = 1 &lt;&lt;  9,
<span class="lineNum">     113 </span>            :         IBV_DEVICE_PORT_ACTIVE_EVENT    = 1 &lt;&lt; 10,
<span class="lineNum">     114 </span>            :         IBV_DEVICE_SYS_IMAGE_GUID       = 1 &lt;&lt; 11,
<span class="lineNum">     115 </span>            :         IBV_DEVICE_RC_RNR_NAK_GEN       = 1 &lt;&lt; 12,
<span class="lineNum">     116 </span>            :         IBV_DEVICE_SRQ_RESIZE           = 1 &lt;&lt; 13,
<span class="lineNum">     117 </span>            :         IBV_DEVICE_N_NOTIFY_CQ          = 1 &lt;&lt; 14,
<span class="lineNum">     118 </span>            :         IBV_DEVICE_XRC                  = 1 &lt;&lt; 20,
<span class="lineNum">     119 </span>            :         IBV_DEVICE_MANAGED_FLOW_STEERING = 1 &lt;&lt; 29
<span class="lineNum">     120 </span>            : };
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span>            : enum ibv_atomic_cap {
<span class="lineNum">     123 </span>            :         IBV_ATOMIC_NONE,
<span class="lineNum">     124 </span>            :         IBV_ATOMIC_HCA,
<span class="lineNum">     125 </span>            :         IBV_ATOMIC_GLOB
<span class="lineNum">     126 </span>            : };
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span>            : struct ibv_device_attr {
<span class="lineNum">     129 </span>            :         char                    fw_ver[64];
<span class="lineNum">     130 </span>            :         uint64_t                node_guid;
<span class="lineNum">     131 </span>            :         uint64_t                sys_image_guid;
<span class="lineNum">     132 </span>            :         uint64_t                max_mr_size;
<span class="lineNum">     133 </span>            :         uint64_t                page_size_cap;
<span class="lineNum">     134 </span>            :         uint32_t                vendor_id;
<span class="lineNum">     135 </span>            :         uint32_t                vendor_part_id;
<span class="lineNum">     136 </span>            :         uint32_t                hw_ver;
<span class="lineNum">     137 </span>            :         int                     max_qp;
<span class="lineNum">     138 </span>            :         int                     max_qp_wr;
<span class="lineNum">     139 </span>            :         int                     device_cap_flags;
<span class="lineNum">     140 </span>            :         int                     max_sge;
<span class="lineNum">     141 </span>            :         int                     max_sge_rd;
<span class="lineNum">     142 </span>            :         int                     max_cq;
<span class="lineNum">     143 </span>            :         int                     max_cqe;
<span class="lineNum">     144 </span>            :         int                     max_mr;
<span class="lineNum">     145 </span>            :         int                     max_pd;
<span class="lineNum">     146 </span>            :         int                     max_qp_rd_atom;
<span class="lineNum">     147 </span>            :         int                     max_ee_rd_atom;
<span class="lineNum">     148 </span>            :         int                     max_res_rd_atom;
<span class="lineNum">     149 </span>            :         int                     max_qp_init_rd_atom;
<span class="lineNum">     150 </span>            :         int                     max_ee_init_rd_atom;
<span class="lineNum">     151 </span>            :         enum ibv_atomic_cap     atomic_cap;
<span class="lineNum">     152 </span>            :         int                     max_ee;
<span class="lineNum">     153 </span>            :         int                     max_rdd;
<span class="lineNum">     154 </span>            :         int                     max_mw;
<span class="lineNum">     155 </span>            :         int                     max_raw_ipv6_qp;
<span class="lineNum">     156 </span>            :         int                     max_raw_ethy_qp;
<span class="lineNum">     157 </span>            :         int                     max_mcast_grp;
<span class="lineNum">     158 </span>            :         int                     max_mcast_qp_attach;
<span class="lineNum">     159 </span>            :         int                     max_total_mcast_qp_attach;
<span class="lineNum">     160 </span>            :         int                     max_ah;
<span class="lineNum">     161 </span>            :         int                     max_fmr;
<span class="lineNum">     162 </span>            :         int                     max_map_per_fmr;
<span class="lineNum">     163 </span>            :         int                     max_srq;
<span class="lineNum">     164 </span>            :         int                     max_srq_wr;
<span class="lineNum">     165 </span>            :         int                     max_srq_sge;
<span class="lineNum">     166 </span>            :         uint16_t                max_pkeys;
<span class="lineNum">     167 </span>            :         uint8_t                 local_ca_ack_delay;
<span class="lineNum">     168 </span>            :         uint8_t                 phys_port_cnt;
<span class="lineNum">     169 </span>            : };
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span>            : enum ibv_mtu {
<span class="lineNum">     172 </span>            :         IBV_MTU_256  = 1,
<span class="lineNum">     173 </span>            :         IBV_MTU_512  = 2,
<span class="lineNum">     174 </span>            :         IBV_MTU_1024 = 3,
<span class="lineNum">     175 </span>            :         IBV_MTU_2048 = 4,
<span class="lineNum">     176 </span>            :         IBV_MTU_4096 = 5
<span class="lineNum">     177 </span>            : };
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span>            : enum ibv_port_state {
<span class="lineNum">     180 </span>            :         IBV_PORT_NOP            = 0,
<span class="lineNum">     181 </span>            :         IBV_PORT_DOWN           = 1,
<span class="lineNum">     182 </span>            :         IBV_PORT_INIT           = 2,
<span class="lineNum">     183 </span>            :         IBV_PORT_ARMED          = 3,
<span class="lineNum">     184 </span>            :         IBV_PORT_ACTIVE         = 4,
<span class="lineNum">     185 </span>            :         IBV_PORT_ACTIVE_DEFER   = 5
<span class="lineNum">     186 </span>            : };
<span class="lineNum">     187 </span>            : 
<span class="lineNum">     188 </span>            : enum {
<span class="lineNum">     189 </span>            :         IBV_LINK_LAYER_UNSPECIFIED,
<span class="lineNum">     190 </span>            :         IBV_LINK_LAYER_INFINIBAND,
<span class="lineNum">     191 </span>            :         IBV_LINK_LAYER_ETHERNET,
<span class="lineNum">     192 </span>            : };
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span>            : enum ibv_port_cap_flags {
<span class="lineNum">     195 </span>            :         IBV_PORT_SM                             = 1 &lt;&lt;  1,
<span class="lineNum">     196 </span>            :         IBV_PORT_NOTICE_SUP                     = 1 &lt;&lt;  2,
<span class="lineNum">     197 </span>            :         IBV_PORT_TRAP_SUP                       = 1 &lt;&lt;  3,
<span class="lineNum">     198 </span>            :         IBV_PORT_OPT_IPD_SUP                    = 1 &lt;&lt;  4,
<span class="lineNum">     199 </span>            :         IBV_PORT_AUTO_MIGR_SUP                  = 1 &lt;&lt;  5,
<span class="lineNum">     200 </span>            :         IBV_PORT_SL_MAP_SUP                     = 1 &lt;&lt;  6,
<span class="lineNum">     201 </span>            :         IBV_PORT_MKEY_NVRAM                     = 1 &lt;&lt;  7,
<span class="lineNum">     202 </span>            :         IBV_PORT_PKEY_NVRAM                     = 1 &lt;&lt;  8,
<span class="lineNum">     203 </span>            :         IBV_PORT_LED_INFO_SUP                   = 1 &lt;&lt;  9,
<span class="lineNum">     204 </span>            :         IBV_PORT_SYS_IMAGE_GUID_SUP             = 1 &lt;&lt; 11,
<span class="lineNum">     205 </span>            :         IBV_PORT_PKEY_SW_EXT_PORT_TRAP_SUP      = 1 &lt;&lt; 12,
<span class="lineNum">     206 </span>            :         IBV_PORT_EXTENDED_SPEEDS_SUP            = 1 &lt;&lt; 14,
<span class="lineNum">     207 </span>            :         IBV_PORT_CM_SUP                         = 1 &lt;&lt; 16,
<span class="lineNum">     208 </span>            :         IBV_PORT_SNMP_TUNNEL_SUP                = 1 &lt;&lt; 17,
<span class="lineNum">     209 </span>            :         IBV_PORT_REINIT_SUP                     = 1 &lt;&lt; 18,
<span class="lineNum">     210 </span>            :         IBV_PORT_DEVICE_MGMT_SUP                = 1 &lt;&lt; 19,
<span class="lineNum">     211 </span>            :         IBV_PORT_VENDOR_CLASS_SUP               = 1 &lt;&lt; 20,
<span class="lineNum">     212 </span>            :         IBV_PORT_DR_NOTICE_SUP                  = 1 &lt;&lt; 21,
<span class="lineNum">     213 </span>            :         IBV_PORT_CAP_MASK_NOTICE_SUP            = 1 &lt;&lt; 22,
<span class="lineNum">     214 </span>            :         IBV_PORT_BOOT_MGMT_SUP                  = 1 &lt;&lt; 23,
<span class="lineNum">     215 </span>            :         IBV_PORT_LINK_LATENCY_SUP               = 1 &lt;&lt; 24,
<span class="lineNum">     216 </span>            :         IBV_PORT_CLIENT_REG_SUP                 = 1 &lt;&lt; 25,
<span class="lineNum">     217 </span>            :         IBV_PORT_IP_BASED_GIDS                  = 1 &lt;&lt; 26
<span class="lineNum">     218 </span>            : };
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            : struct ibv_port_attr {
<span class="lineNum">     221 </span>            :         enum ibv_port_state     state;
<span class="lineNum">     222 </span>            :         enum ibv_mtu            max_mtu;
<span class="lineNum">     223 </span>            :         enum ibv_mtu            active_mtu;
<span class="lineNum">     224 </span>            :         int                     gid_tbl_len;
<span class="lineNum">     225 </span>            :         uint32_t                port_cap_flags;
<span class="lineNum">     226 </span>            :         uint32_t                max_msg_sz;
<span class="lineNum">     227 </span>            :         uint32_t                bad_pkey_cntr;
<span class="lineNum">     228 </span>            :         uint32_t                qkey_viol_cntr;
<span class="lineNum">     229 </span>            :         uint16_t                pkey_tbl_len;
<span class="lineNum">     230 </span>            :         uint16_t                lid;
<span class="lineNum">     231 </span>            :         uint16_t                sm_lid;
<span class="lineNum">     232 </span>            :         uint8_t                 lmc;
<span class="lineNum">     233 </span>            :         uint8_t                 max_vl_num;
<span class="lineNum">     234 </span>            :         uint8_t                 sm_sl;
<span class="lineNum">     235 </span>            :         uint8_t                 subnet_timeout;
<span class="lineNum">     236 </span>            :         uint8_t                 init_type_reply;
<span class="lineNum">     237 </span>            :         uint8_t                 active_width;
<span class="lineNum">     238 </span>            :         uint8_t                 active_speed;
<span class="lineNum">     239 </span>            :         uint8_t                 phys_state;
<span class="lineNum">     240 </span>            :         uint8_t                 link_layer;
<span class="lineNum">     241 </span>            :         uint8_t                 reserved;
<span class="lineNum">     242 </span>            : };
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span>            : enum ibv_event_type {
<span class="lineNum">     245 </span>            :         IBV_EVENT_CQ_ERR,
<span class="lineNum">     246 </span>            :         IBV_EVENT_QP_FATAL,
<span class="lineNum">     247 </span>            :         IBV_EVENT_QP_REQ_ERR,
<span class="lineNum">     248 </span>            :         IBV_EVENT_QP_ACCESS_ERR,
<span class="lineNum">     249 </span>            :         IBV_EVENT_COMM_EST,
<span class="lineNum">     250 </span>            :         IBV_EVENT_SQ_DRAINED,
<span class="lineNum">     251 </span>            :         IBV_EVENT_PATH_MIG,
<span class="lineNum">     252 </span>            :         IBV_EVENT_PATH_MIG_ERR,
<span class="lineNum">     253 </span>            :         IBV_EVENT_DEVICE_FATAL,
<span class="lineNum">     254 </span>            :         IBV_EVENT_PORT_ACTIVE,
<span class="lineNum">     255 </span>            :         IBV_EVENT_PORT_ERR,
<span class="lineNum">     256 </span>            :         IBV_EVENT_LID_CHANGE,
<span class="lineNum">     257 </span>            :         IBV_EVENT_PKEY_CHANGE,
<span class="lineNum">     258 </span>            :         IBV_EVENT_SM_CHANGE,
<span class="lineNum">     259 </span>            :         IBV_EVENT_SRQ_ERR,
<span class="lineNum">     260 </span>            :         IBV_EVENT_SRQ_LIMIT_REACHED,
<span class="lineNum">     261 </span>            :         IBV_EVENT_QP_LAST_WQE_REACHED,
<span class="lineNum">     262 </span>            :         IBV_EVENT_CLIENT_REREGISTER,
<span class="lineNum">     263 </span>            :         IBV_EVENT_GID_CHANGE,
<span class="lineNum">     264 </span>            : };
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span>            : struct ibv_async_event {
<span class="lineNum">     267 </span>            :         union {
<span class="lineNum">     268 </span>            :                 struct ibv_cq  *cq;
<span class="lineNum">     269 </span>            :                 struct ibv_qp  *qp;
<span class="lineNum">     270 </span>            :                 struct ibv_srq *srq;
<span class="lineNum">     271 </span>            :                 int             port_num;
<span class="lineNum">     272 </span>            :         } element;
<span class="lineNum">     273 </span>            :         enum ibv_event_type     event_type;
<span class="lineNum">     274 </span>            : };
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span>            : enum ibv_wc_status {
<span class="lineNum">     277 </span>            :         IBV_WC_SUCCESS,
<span class="lineNum">     278 </span>            :         IBV_WC_LOC_LEN_ERR,
<span class="lineNum">     279 </span>            :         IBV_WC_LOC_QP_OP_ERR,
<span class="lineNum">     280 </span>            :         IBV_WC_LOC_EEC_OP_ERR,
<span class="lineNum">     281 </span>            :         IBV_WC_LOC_PROT_ERR,
<span class="lineNum">     282 </span>            :         IBV_WC_WR_FLUSH_ERR,
<span class="lineNum">     283 </span>            :         IBV_WC_MW_BIND_ERR,
<span class="lineNum">     284 </span>            :         IBV_WC_BAD_RESP_ERR,
<span class="lineNum">     285 </span>            :         IBV_WC_LOC_ACCESS_ERR,
<span class="lineNum">     286 </span>            :         IBV_WC_REM_INV_REQ_ERR,
<span class="lineNum">     287 </span>            :         IBV_WC_REM_ACCESS_ERR,
<span class="lineNum">     288 </span>            :         IBV_WC_REM_OP_ERR,
<span class="lineNum">     289 </span>            :         IBV_WC_RETRY_EXC_ERR,
<span class="lineNum">     290 </span>            :         IBV_WC_RNR_RETRY_EXC_ERR,
<span class="lineNum">     291 </span>            :         IBV_WC_LOC_RDD_VIOL_ERR,
<span class="lineNum">     292 </span>            :         IBV_WC_REM_INV_RD_REQ_ERR,
<span class="lineNum">     293 </span>            :         IBV_WC_REM_ABORT_ERR,
<span class="lineNum">     294 </span>            :         IBV_WC_INV_EECN_ERR,
<span class="lineNum">     295 </span>            :         IBV_WC_INV_EEC_STATE_ERR,
<span class="lineNum">     296 </span>            :         IBV_WC_FATAL_ERR,
<span class="lineNum">     297 </span>            :         IBV_WC_RESP_TIMEOUT_ERR,
<span class="lineNum">     298 </span>            :         IBV_WC_GENERAL_ERR
<span class="lineNum">     299 </span>            : };
<span class="lineNum">     300 </span>            : const char *ibv_wc_status_str(enum ibv_wc_status status);
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span>            : enum ibv_wc_opcode {
<span class="lineNum">     303 </span>            :         IBV_WC_SEND,
<span class="lineNum">     304 </span>            :         IBV_WC_RDMA_WRITE,
<span class="lineNum">     305 </span>            :         IBV_WC_RDMA_READ,
<span class="lineNum">     306 </span>            :         IBV_WC_COMP_SWAP,
<span class="lineNum">     307 </span>            :         IBV_WC_FETCH_ADD,
<span class="lineNum">     308 </span>            :         IBV_WC_BIND_MW,
<span class="lineNum">     309 </span>            : /*
<span class="lineNum">     310 </span>            :  * Set value of IBV_WC_RECV so consumers can test if a completion is a
<span class="lineNum">     311 </span>            :  * receive by testing (opcode &amp; IBV_WC_RECV).
<span class="lineNum">     312 </span>            :  */
<span class="lineNum">     313 </span>            :         IBV_WC_RECV                     = 1 &lt;&lt; 7,
<span class="lineNum">     314 </span>            :         IBV_WC_RECV_RDMA_WITH_IMM
<span class="lineNum">     315 </span>            : };
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span>            : enum ibv_wc_flags {
<span class="lineNum">     318 </span>            :         IBV_WC_GRH              = 1 &lt;&lt; 0,
<span class="lineNum">     319 </span>            :         IBV_WC_WITH_IMM         = 1 &lt;&lt; 1
<span class="lineNum">     320 </span>            : };
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span>            : struct ibv_wc {
<span class="lineNum">     323 </span>            :         uint64_t                wr_id;
<span class="lineNum">     324 </span>            :         enum ibv_wc_status      status;
<span class="lineNum">     325 </span>            :         enum ibv_wc_opcode      opcode;
<span class="lineNum">     326 </span>            :         uint32_t                vendor_err;
<span class="lineNum">     327 </span>            :         uint32_t                byte_len;
<span class="lineNum">     328 </span>            :         uint32_t                imm_data;       /* in network byte order */
<span class="lineNum">     329 </span>            :         uint32_t                qp_num;
<span class="lineNum">     330 </span>            :         uint32_t                src_qp;
<span class="lineNum">     331 </span>            :         int                     wc_flags;
<span class="lineNum">     332 </span>            :         uint16_t                pkey_index;
<span class="lineNum">     333 </span>            :         uint16_t                slid;
<span class="lineNum">     334 </span>            :         uint8_t                 sl;
<span class="lineNum">     335 </span>            :         uint8_t                 dlid_path_bits;
<span class="lineNum">     336 </span>            : };
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span>            : enum ibv_access_flags {
<span class="lineNum">     339 </span>            :         IBV_ACCESS_LOCAL_WRITE          = 1,
<span class="lineNum">     340 </span>            :         IBV_ACCESS_REMOTE_WRITE         = (1&lt;&lt;1),
<span class="lineNum">     341 </span>            :         IBV_ACCESS_REMOTE_READ          = (1&lt;&lt;2),
<span class="lineNum">     342 </span>            :         IBV_ACCESS_REMOTE_ATOMIC        = (1&lt;&lt;3),
<span class="lineNum">     343 </span>            :         IBV_ACCESS_MW_BIND              = (1&lt;&lt;4)
<span class="lineNum">     344 </span>            : };
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span>            : struct ibv_pd {
<span class="lineNum">     347 </span>            :         struct ibv_context     *context;
<span class="lineNum">     348 </span>            :         uint32_t                handle;
<span class="lineNum">     349 </span>            : };
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span>            : enum ibv_xrcd_init_attr_mask {
<span class="lineNum">     352 </span>            :         IBV_XRCD_INIT_ATTR_FD       = 1 &lt;&lt; 0,
<span class="lineNum">     353 </span>            :         IBV_XRCD_INIT_ATTR_OFLAGS   = 1 &lt;&lt; 1,
<span class="lineNum">     354 </span>            :         IBV_XRCD_INIT_ATTR_RESERVED = 1 &lt;&lt; 2
<span class="lineNum">     355 </span>            : };
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span>            : struct ibv_xrcd_init_attr {
<span class="lineNum">     358 </span>            :         uint32_t comp_mask;
<span class="lineNum">     359 </span>            :         int      fd;
<span class="lineNum">     360 </span>            :         int      oflags;
<span class="lineNum">     361 </span>            : };
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span>            : struct ibv_xrcd {
<span class="lineNum">     364 </span>            :         struct ibv_context     *context;
<span class="lineNum">     365 </span>            : };
<span class="lineNum">     366 </span>            : 
<span class="lineNum">     367 </span>            : enum ibv_rereg_mr_flags {
<span class="lineNum">     368 </span>            :         IBV_REREG_MR_CHANGE_TRANSLATION = (1 &lt;&lt; 0),
<span class="lineNum">     369 </span>            :         IBV_REREG_MR_CHANGE_PD          = (1 &lt;&lt; 1),
<span class="lineNum">     370 </span>            :         IBV_REREG_MR_CHANGE_ACCESS      = (1 &lt;&lt; 2),
<span class="lineNum">     371 </span>            :         IBV_REREG_MR_KEEP_VALID         = (1 &lt;&lt; 3)
<span class="lineNum">     372 </span>            : };
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span>            : struct ibv_mr {
<span class="lineNum">     375 </span>            :         struct ibv_context     *context;
<span class="lineNum">     376 </span>            :         struct ibv_pd          *pd;
<span class="lineNum">     377 </span>            :         void                   *addr;
<span class="lineNum">     378 </span>            :         size_t                  length;
<span class="lineNum">     379 </span>            :         uint32_t                handle;
<span class="lineNum">     380 </span>            :         uint32_t                lkey;
<span class="lineNum">     381 </span>            :         uint32_t                rkey;
<span class="lineNum">     382 </span>            : };
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span>            : enum ibv_mw_type {
<span class="lineNum">     385 </span>            :         IBV_MW_TYPE_1                   = 1,
<span class="lineNum">     386 </span>            :         IBV_MW_TYPE_2                   = 2
<span class="lineNum">     387 </span>            : };
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span>            : struct ibv_mw {
<span class="lineNum">     390 </span>            :         struct ibv_context     *context;
<span class="lineNum">     391 </span>            :         struct ibv_pd          *pd;
<span class="lineNum">     392 </span>            :         uint32_t                rkey;
<span class="lineNum">     393 </span>            : };
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span>            : struct ibv_global_route {
<span class="lineNum">     396 </span>            :         union ibv_gid           dgid;
<span class="lineNum">     397 </span>            :         uint32_t                flow_label;
<span class="lineNum">     398 </span>            :         uint8_t                 sgid_index;
<span class="lineNum">     399 </span>            :         uint8_t                 hop_limit;
<span class="lineNum">     400 </span>            :         uint8_t                 traffic_class;
<span class="lineNum">     401 </span>            : };
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span>            : struct ibv_grh {
<span class="lineNum">     404 </span>            :         uint32_t                version_tclass_flow;
<span class="lineNum">     405 </span>            :         uint16_t                paylen;
<span class="lineNum">     406 </span>            :         uint8_t                 next_hdr;
<span class="lineNum">     407 </span>            :         uint8_t                 hop_limit;
<span class="lineNum">     408 </span>            :         union ibv_gid           sgid;
<span class="lineNum">     409 </span>            :         union ibv_gid           dgid;
<span class="lineNum">     410 </span>            : };
<span class="lineNum">     411 </span>            : 
<span class="lineNum">     412 </span>            : enum ibv_rate {
<span class="lineNum">     413 </span>            :         IBV_RATE_MAX      = 0,
<span class="lineNum">     414 </span>            :         IBV_RATE_2_5_GBPS = 2,
<span class="lineNum">     415 </span>            :         IBV_RATE_5_GBPS   = 5,
<span class="lineNum">     416 </span>            :         IBV_RATE_10_GBPS  = 3,
<span class="lineNum">     417 </span>            :         IBV_RATE_20_GBPS  = 6,
<span class="lineNum">     418 </span>            :         IBV_RATE_30_GBPS  = 4,
<span class="lineNum">     419 </span>            :         IBV_RATE_40_GBPS  = 7,
<span class="lineNum">     420 </span>            :         IBV_RATE_60_GBPS  = 8,
<span class="lineNum">     421 </span>            :         IBV_RATE_80_GBPS  = 9,
<span class="lineNum">     422 </span>            :         IBV_RATE_120_GBPS = 10,
<span class="lineNum">     423 </span>            :         IBV_RATE_14_GBPS  = 11,
<span class="lineNum">     424 </span>            :         IBV_RATE_56_GBPS  = 12,
<span class="lineNum">     425 </span>            :         IBV_RATE_112_GBPS = 13,
<span class="lineNum">     426 </span>            :         IBV_RATE_168_GBPS = 14,
<span class="lineNum">     427 </span>            :         IBV_RATE_25_GBPS  = 15,
<span class="lineNum">     428 </span>            :         IBV_RATE_100_GBPS = 16,
<span class="lineNum">     429 </span>            :         IBV_RATE_200_GBPS = 17,
<span class="lineNum">     430 </span>            :         IBV_RATE_300_GBPS = 18
<span class="lineNum">     431 </span>            : };
<span class="lineNum">     432 </span>            : 
<span class="lineNum">     433 </span>            : /**
<span class="lineNum">     434 </span>            :  * ibv_rate_to_mult - Convert the IB rate enum to a multiple of the
<span class="lineNum">     435 </span>            :  * base rate of 2.5 Gbit/sec.  For example, IBV_RATE_5_GBPS will be
<span class="lineNum">     436 </span>            :  * converted to 2, since 5 Gbit/sec is 2 * 2.5 Gbit/sec.
<span class="lineNum">     437 </span>            :  * @rate: rate to convert.
<span class="lineNum">     438 </span>            :  */
<span class="lineNum">     439 </span>            : int ibv_rate_to_mult(enum ibv_rate rate) __attribute_const;
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span>            : /**
<span class="lineNum">     442 </span>            :  * mult_to_ibv_rate - Convert a multiple of 2.5 Gbit/sec to an IB rate enum.
<span class="lineNum">     443 </span>            :  * @mult: multiple to convert.
<span class="lineNum">     444 </span>            :  */
<span class="lineNum">     445 </span>            : enum ibv_rate mult_to_ibv_rate(int mult) __attribute_const;
<span class="lineNum">     446 </span>            : 
<span class="lineNum">     447 </span>            : /**
<span class="lineNum">     448 </span>            :  * ibv_rate_to_mbps - Convert the IB rate enum to Mbit/sec.
<span class="lineNum">     449 </span>            :  * For example, IBV_RATE_5_GBPS will return the value 5000.
<span class="lineNum">     450 </span>            :  * @rate: rate to convert.
<span class="lineNum">     451 </span>            :  */
<span class="lineNum">     452 </span>            : int ibv_rate_to_mbps(enum ibv_rate rate) __attribute_const;
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span>            : /**
<span class="lineNum">     455 </span>            :  * mbps_to_ibv_rate - Convert a Mbit/sec value to an IB rate enum.
<span class="lineNum">     456 </span>            :  * @mbps: value to convert.
<span class="lineNum">     457 </span>            :  */
<span class="lineNum">     458 </span>            : enum ibv_rate mbps_to_ibv_rate(int mbps) __attribute_const;
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span>            : struct ibv_ah_attr {
<span class="lineNum">     461 </span>            :         struct ibv_global_route grh;
<span class="lineNum">     462 </span>            :         uint16_t                dlid;
<span class="lineNum">     463 </span>            :         uint8_t                 sl;
<span class="lineNum">     464 </span>            :         uint8_t                 src_path_bits;
<span class="lineNum">     465 </span>            :         uint8_t                 static_rate;
<span class="lineNum">     466 </span>            :         uint8_t                 is_global;
<span class="lineNum">     467 </span>            :         uint8_t                 port_num;
<span class="lineNum">     468 </span>            : };
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span>            : enum ibv_srq_attr_mask {
<span class="lineNum">     471 </span>            :         IBV_SRQ_MAX_WR  = 1 &lt;&lt; 0,
<span class="lineNum">     472 </span>            :         IBV_SRQ_LIMIT   = 1 &lt;&lt; 1
<span class="lineNum">     473 </span>            : };
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span>            : struct ibv_srq_attr {
<span class="lineNum">     476 </span>            :         uint32_t                max_wr;
<span class="lineNum">     477 </span>            :         uint32_t                max_sge;
<span class="lineNum">     478 </span>            :         uint32_t                srq_limit;
<span class="lineNum">     479 </span>            : };
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span>            : struct ibv_srq_init_attr {
<span class="lineNum">     482 </span>            :         void                   *srq_context;
<span class="lineNum">     483 </span>            :         struct ibv_srq_attr     attr;
<span class="lineNum">     484 </span>            : };
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            : enum ibv_srq_type {
<span class="lineNum">     487 </span>            :         IBV_SRQT_BASIC,
<span class="lineNum">     488 </span>            :         IBV_SRQT_XRC
<span class="lineNum">     489 </span>            : };
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span>            : enum ibv_srq_init_attr_mask {
<span class="lineNum">     492 </span>            :         IBV_SRQ_INIT_ATTR_TYPE          = 1 &lt;&lt; 0,
<span class="lineNum">     493 </span>            :         IBV_SRQ_INIT_ATTR_PD            = 1 &lt;&lt; 1,
<span class="lineNum">     494 </span>            :         IBV_SRQ_INIT_ATTR_XRCD          = 1 &lt;&lt; 2,
<span class="lineNum">     495 </span>            :         IBV_SRQ_INIT_ATTR_CQ            = 1 &lt;&lt; 3,
<span class="lineNum">     496 </span>            :         IBV_SRQ_INIT_ATTR_RESERVED      = 1 &lt;&lt; 4
<span class="lineNum">     497 </span>            : };
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span>            : struct ibv_srq_init_attr_ex {
<span class="lineNum">     500 </span>            :         void                   *srq_context;
<span class="lineNum">     501 </span>            :         struct ibv_srq_attr     attr;
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span>            :         uint32_t                comp_mask;
<span class="lineNum">     504 </span>            :         enum ibv_srq_type       srq_type;
<span class="lineNum">     505 </span>            :         struct ibv_pd          *pd;
<span class="lineNum">     506 </span>            :         struct ibv_xrcd        *xrcd;
<span class="lineNum">     507 </span>            :         struct ibv_cq          *cq;
<span class="lineNum">     508 </span>            : };
<span class="lineNum">     509 </span>            : 
<span class="lineNum">     510 </span>            : enum ibv_qp_type {
<span class="lineNum">     511 </span>            :         IBV_QPT_RC = 2,
<span class="lineNum">     512 </span>            :         IBV_QPT_UC,
<span class="lineNum">     513 </span>            :         IBV_QPT_UD,
<span class="lineNum">     514 </span>            :         IBV_QPT_RAW_PACKET = 8,
<span class="lineNum">     515 </span>            :         IBV_QPT_XRC_SEND = 9,
<span class="lineNum">     516 </span>            :         IBV_QPT_XRC_RECV
<span class="lineNum">     517 </span>            : };
<span class="lineNum">     518 </span>            : 
<span class="lineNum">     519 </span>            : struct ibv_qp_cap {
<span class="lineNum">     520 </span>            :         uint32_t                max_send_wr;
<span class="lineNum">     521 </span>            :         uint32_t                max_recv_wr;
<span class="lineNum">     522 </span>            :         uint32_t                max_send_sge;
<span class="lineNum">     523 </span>            :         uint32_t                max_recv_sge;
<span class="lineNum">     524 </span>            :         uint32_t                max_inline_data;
<span class="lineNum">     525 </span>            : };
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span>            : struct ibv_qp_init_attr {
<span class="lineNum">     528 </span>            :         void                   *qp_context;
<span class="lineNum">     529 </span>            :         struct ibv_cq          *send_cq;
<span class="lineNum">     530 </span>            :         struct ibv_cq          *recv_cq;
<span class="lineNum">     531 </span>            :         struct ibv_srq         *srq;
<span class="lineNum">     532 </span>            :         struct ibv_qp_cap       cap;
<span class="lineNum">     533 </span>            :         enum ibv_qp_type        qp_type;
<span class="lineNum">     534 </span>            :         int                     sq_sig_all;
<span class="lineNum">     535 </span>            : };
<span class="lineNum">     536 </span>            : 
<span class="lineNum">     537 </span>            : enum ibv_qp_init_attr_mask {
<span class="lineNum">     538 </span>            :         IBV_QP_INIT_ATTR_PD             = 1 &lt;&lt; 0,
<span class="lineNum">     539 </span>            :         IBV_QP_INIT_ATTR_XRCD           = 1 &lt;&lt; 1,
<span class="lineNum">     540 </span>            :         IBV_QP_INIT_ATTR_RESERVED       = 1 &lt;&lt; 2
<span class="lineNum">     541 </span>            : };
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span>            : struct ibv_qp_init_attr_ex {
<span class="lineNum">     544 </span>            :         void                   *qp_context;
<span class="lineNum">     545 </span>            :         struct ibv_cq          *send_cq;
<span class="lineNum">     546 </span>            :         struct ibv_cq          *recv_cq;
<span class="lineNum">     547 </span>            :         struct ibv_srq         *srq;
<span class="lineNum">     548 </span>            :         struct ibv_qp_cap       cap;
<span class="lineNum">     549 </span>            :         enum ibv_qp_type        qp_type;
<span class="lineNum">     550 </span>            :         int                     sq_sig_all;
<span class="lineNum">     551 </span>            : 
<span class="lineNum">     552 </span>            :         uint32_t                comp_mask;
<span class="lineNum">     553 </span>            :         struct ibv_pd          *pd;
<span class="lineNum">     554 </span>            :         struct ibv_xrcd        *xrcd;
<span class="lineNum">     555 </span>            : };
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span>            : enum ibv_qp_open_attr_mask {
<span class="lineNum">     558 </span>            :         IBV_QP_OPEN_ATTR_NUM            = 1 &lt;&lt; 0,
<span class="lineNum">     559 </span>            :         IBV_QP_OPEN_ATTR_XRCD           = 1 &lt;&lt; 1,
<span class="lineNum">     560 </span>            :         IBV_QP_OPEN_ATTR_CONTEXT        = 1 &lt;&lt; 2,
<span class="lineNum">     561 </span>            :         IBV_QP_OPEN_ATTR_TYPE           = 1 &lt;&lt; 3,
<span class="lineNum">     562 </span>            :         IBV_QP_OPEN_ATTR_RESERVED       = 1 &lt;&lt; 4
<span class="lineNum">     563 </span>            : };
<span class="lineNum">     564 </span>            : 
<span class="lineNum">     565 </span>            : struct ibv_qp_open_attr {
<span class="lineNum">     566 </span>            :         uint32_t                comp_mask;
<span class="lineNum">     567 </span>            :         uint32_t                qp_num;
<span class="lineNum">     568 </span>            :         struct ibv_xrcd        *xrcd;
<span class="lineNum">     569 </span>            :         void                   *qp_context;
<span class="lineNum">     570 </span>            :         enum ibv_qp_type        qp_type;
<span class="lineNum">     571 </span>            : };
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span>            : enum ibv_qp_attr_mask {
<span class="lineNum">     574 </span>            :         IBV_QP_STATE                    = 1 &lt;&lt;    0,
<span class="lineNum">     575 </span>            :         IBV_QP_CUR_STATE                = 1 &lt;&lt;    1,
<span class="lineNum">     576 </span>            :         IBV_QP_EN_SQD_ASYNC_NOTIFY      = 1 &lt;&lt;    2,
<span class="lineNum">     577 </span>            :         IBV_QP_ACCESS_FLAGS             = 1 &lt;&lt;    3,
<span class="lineNum">     578 </span>            :         IBV_QP_PKEY_INDEX               = 1 &lt;&lt;    4,
<span class="lineNum">     579 </span>            :         IBV_QP_PORT                     = 1 &lt;&lt;    5,
<span class="lineNum">     580 </span>            :         IBV_QP_QKEY                     = 1 &lt;&lt;    6,
<span class="lineNum">     581 </span>            :         IBV_QP_AV                       = 1 &lt;&lt;    7,
<span class="lineNum">     582 </span>            :         IBV_QP_PATH_MTU                 = 1 &lt;&lt;    8,
<span class="lineNum">     583 </span>            :         IBV_QP_TIMEOUT                  = 1 &lt;&lt;    9,
<span class="lineNum">     584 </span>            :         IBV_QP_RETRY_CNT                = 1 &lt;&lt; 10,
<span class="lineNum">     585 </span>            :         IBV_QP_RNR_RETRY                = 1 &lt;&lt; 11,
<span class="lineNum">     586 </span>            :         IBV_QP_RQ_PSN                   = 1 &lt;&lt; 12,
<span class="lineNum">     587 </span>            :         IBV_QP_MAX_QP_RD_ATOMIC         = 1 &lt;&lt; 13,
<span class="lineNum">     588 </span>            :         IBV_QP_ALT_PATH                 = 1 &lt;&lt; 14,
<span class="lineNum">     589 </span>            :         IBV_QP_MIN_RNR_TIMER            = 1 &lt;&lt; 15,
<span class="lineNum">     590 </span>            :         IBV_QP_SQ_PSN                   = 1 &lt;&lt; 16,
<span class="lineNum">     591 </span>            :         IBV_QP_MAX_DEST_RD_ATOMIC       = 1 &lt;&lt; 17,
<span class="lineNum">     592 </span>            :         IBV_QP_PATH_MIG_STATE           = 1 &lt;&lt; 18,
<span class="lineNum">     593 </span>            :         IBV_QP_CAP                      = 1 &lt;&lt; 19,
<span class="lineNum">     594 </span>            :         IBV_QP_DEST_QPN                 = 1 &lt;&lt; 20
<span class="lineNum">     595 </span>            : };
<span class="lineNum">     596 </span>            : 
<span class="lineNum">     597 </span>            : enum ibv_qp_state {
<span class="lineNum">     598 </span>            :         IBV_QPS_RESET,
<span class="lineNum">     599 </span>            :         IBV_QPS_INIT,
<span class="lineNum">     600 </span>            :         IBV_QPS_RTR,
<span class="lineNum">     601 </span>            :         IBV_QPS_RTS,
<span class="lineNum">     602 </span>            :         IBV_QPS_SQD,
<span class="lineNum">     603 </span>            :         IBV_QPS_SQE,
<span class="lineNum">     604 </span>            :         IBV_QPS_ERR,
<span class="lineNum">     605 </span>            :         IBV_QPS_UNKNOWN
<span class="lineNum">     606 </span>            : };
<span class="lineNum">     607 </span>            : 
<span class="lineNum">     608 </span>            : enum ibv_mig_state {
<span class="lineNum">     609 </span>            :         IBV_MIG_MIGRATED,
<span class="lineNum">     610 </span>            :         IBV_MIG_REARM,
<span class="lineNum">     611 </span>            :         IBV_MIG_ARMED
<span class="lineNum">     612 </span>            : };
<span class="lineNum">     613 </span>            : 
<span class="lineNum">     614 </span>            : struct ibv_qp_attr {
<span class="lineNum">     615 </span>            :         enum ibv_qp_state       qp_state;
<span class="lineNum">     616 </span>            :         enum ibv_qp_state       cur_qp_state;
<span class="lineNum">     617 </span>            :         enum ibv_mtu            path_mtu;
<span class="lineNum">     618 </span>            :         enum ibv_mig_state      path_mig_state;
<span class="lineNum">     619 </span>            :         uint32_t                qkey;
<span class="lineNum">     620 </span>            :         uint32_t                rq_psn;
<span class="lineNum">     621 </span>            :         uint32_t                sq_psn;
<span class="lineNum">     622 </span>            :         uint32_t                dest_qp_num;
<span class="lineNum">     623 </span>            :         int                     qp_access_flags;
<span class="lineNum">     624 </span>            :         struct ibv_qp_cap       cap;
<span class="lineNum">     625 </span>            :         struct ibv_ah_attr      ah_attr;
<span class="lineNum">     626 </span>            :         struct ibv_ah_attr      alt_ah_attr;
<span class="lineNum">     627 </span>            :         uint16_t                pkey_index;
<span class="lineNum">     628 </span>            :         uint16_t                alt_pkey_index;
<span class="lineNum">     629 </span>            :         uint8_t                 en_sqd_async_notify;
<span class="lineNum">     630 </span>            :         uint8_t                 sq_draining;
<span class="lineNum">     631 </span>            :         uint8_t                 max_rd_atomic;
<span class="lineNum">     632 </span>            :         uint8_t                 max_dest_rd_atomic;
<span class="lineNum">     633 </span>            :         uint8_t                 min_rnr_timer;
<span class="lineNum">     634 </span>            :         uint8_t                 port_num;
<span class="lineNum">     635 </span>            :         uint8_t                 timeout;
<span class="lineNum">     636 </span>            :         uint8_t                 retry_cnt;
<span class="lineNum">     637 </span>            :         uint8_t                 rnr_retry;
<span class="lineNum">     638 </span>            :         uint8_t                 alt_port_num;
<span class="lineNum">     639 </span>            :         uint8_t                 alt_timeout;
<span class="lineNum">     640 </span>            : };
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span>            : enum ibv_wr_opcode {
<span class="lineNum">     643 </span>            :         IBV_WR_RDMA_WRITE,
<span class="lineNum">     644 </span>            :         IBV_WR_RDMA_WRITE_WITH_IMM,
<span class="lineNum">     645 </span>            :         IBV_WR_SEND,
<span class="lineNum">     646 </span>            :         IBV_WR_SEND_WITH_IMM,
<span class="lineNum">     647 </span>            :         IBV_WR_RDMA_READ,
<span class="lineNum">     648 </span>            :         IBV_WR_ATOMIC_CMP_AND_SWP,
<span class="lineNum">     649 </span>            :         IBV_WR_ATOMIC_FETCH_AND_ADD
<span class="lineNum">     650 </span>            : };
<span class="lineNum">     651 </span>            : 
<span class="lineNum">     652 </span>            : enum ibv_send_flags {
<span class="lineNum">     653 </span>            :         IBV_SEND_FENCE          = 1 &lt;&lt; 0,
<span class="lineNum">     654 </span>            :         IBV_SEND_SIGNALED       = 1 &lt;&lt; 1,
<span class="lineNum">     655 </span>            :         IBV_SEND_SOLICITED      = 1 &lt;&lt; 2,
<span class="lineNum">     656 </span>            :         IBV_SEND_INLINE         = 1 &lt;&lt; 3
<span class="lineNum">     657 </span>            : };
<span class="lineNum">     658 </span>            : 
<span class="lineNum">     659 </span>            : struct ibv_sge {
<span class="lineNum">     660 </span>            :         uint64_t                addr;
<span class="lineNum">     661 </span>            :         uint32_t                length;
<span class="lineNum">     662 </span>            :         uint32_t                lkey;
<span class="lineNum">     663 </span>            : };
<span class="lineNum">     664 </span>            : 
<span class="lineNum">     665 </span>            : struct ibv_send_wr {
<span class="lineNum">     666 </span>            :         uint64_t                wr_id;
<span class="lineNum">     667 </span>            :         struct ibv_send_wr     *next;
<span class="lineNum">     668 </span>            :         struct ibv_sge         *sg_list;
<span class="lineNum">     669 </span>            :         int                     num_sge;
<span class="lineNum">     670 </span>            :         enum ibv_wr_opcode      opcode;
<span class="lineNum">     671 </span>            :         int                     send_flags;
<span class="lineNum">     672 </span>            :         uint32_t                imm_data;       /* in network byte order */
<span class="lineNum">     673 </span>            :         union {
<span class="lineNum">     674 </span>            :                 struct {
<span class="lineNum">     675 </span>            :                         uint64_t        remote_addr;
<span class="lineNum">     676 </span>            :                         uint32_t        rkey;
<span class="lineNum">     677 </span>            :                 } rdma;
<span class="lineNum">     678 </span>            :                 struct {
<span class="lineNum">     679 </span>            :                         uint64_t        remote_addr;
<span class="lineNum">     680 </span>            :                         uint64_t        compare_add;
<span class="lineNum">     681 </span>            :                         uint64_t        swap;
<span class="lineNum">     682 </span>            :                         uint32_t        rkey;
<span class="lineNum">     683 </span>            :                 } atomic;
<span class="lineNum">     684 </span>            :                 struct {
<span class="lineNum">     685 </span>            :                         struct ibv_ah  *ah;
<span class="lineNum">     686 </span>            :                         uint32_t        remote_qpn;
<span class="lineNum">     687 </span>            :                         uint32_t        remote_qkey;
<span class="lineNum">     688 </span>            :                 } ud;
<span class="lineNum">     689 </span>            :         } wr;
<span class="lineNum">     690 </span>            :         union {
<span class="lineNum">     691 </span>            :                 struct {
<span class="lineNum">     692 </span>            :                         uint32_t    remote_srqn;
<span class="lineNum">     693 </span>            :                 } xrc;
<span class="lineNum">     694 </span>            :         } qp_type;
<span class="lineNum">     695 </span>            : };
<span class="lineNum">     696 </span>            : 
<span class="lineNum">     697 </span>            : struct ibv_recv_wr {
<span class="lineNum">     698 </span>            :         uint64_t                wr_id;
<span class="lineNum">     699 </span>            :         struct ibv_recv_wr     *next;
<span class="lineNum">     700 </span>            :         struct ibv_sge         *sg_list;
<span class="lineNum">     701 </span>            :         int                     num_sge;
<span class="lineNum">     702 </span>            : };
<span class="lineNum">     703 </span>            : 
<span class="lineNum">     704 </span>            : struct ibv_mw_bind {
<span class="lineNum">     705 </span>            :         uint64_t                wr_id;
<span class="lineNum">     706 </span>            :         struct ibv_mr          *mr;
<span class="lineNum">     707 </span>            :         void                   *addr;
<span class="lineNum">     708 </span>            :         size_t                  length;
<span class="lineNum">     709 </span>            :         int                     send_flags;
<span class="lineNum">     710 </span>            :         int                     mw_access_flags;
<span class="lineNum">     711 </span>            : };
<span class="lineNum">     712 </span>            : 
<span class="lineNum">     713 </span>            : struct ibv_srq {
<span class="lineNum">     714 </span>            :         struct ibv_context     *context;
<span class="lineNum">     715 </span>            :         void                   *srq_context;
<span class="lineNum">     716 </span>            :         struct ibv_pd          *pd;
<span class="lineNum">     717 </span>            :         uint32_t                handle;
<span class="lineNum">     718 </span>            : 
<span class="lineNum">     719 </span>            :         pthread_mutex_t         mutex;
<span class="lineNum">     720 </span>            :         pthread_cond_t          cond;
<span class="lineNum">     721 </span>            :         uint32_t                events_completed;
<span class="lineNum">     722 </span>            : };
<span class="lineNum">     723 </span>            : 
<span class="lineNum">     724 </span>            : struct ibv_qp {
<span class="lineNum">     725 </span>            :         struct ibv_context     *context;
<span class="lineNum">     726 </span>            :         void                   *qp_context;
<span class="lineNum">     727 </span>            :         struct ibv_pd          *pd;
<span class="lineNum">     728 </span>            :         struct ibv_cq          *send_cq;
<span class="lineNum">     729 </span>            :         struct ibv_cq          *recv_cq;
<span class="lineNum">     730 </span>            :         struct ibv_srq         *srq;
<span class="lineNum">     731 </span>            :         uint32_t                handle;
<span class="lineNum">     732 </span>            :         uint32_t                qp_num;
<span class="lineNum">     733 </span>            :         enum ibv_qp_state       state;
<span class="lineNum">     734 </span>            :         enum ibv_qp_type        qp_type;
<span class="lineNum">     735 </span>            : 
<span class="lineNum">     736 </span>            :         pthread_mutex_t         mutex;
<span class="lineNum">     737 </span>            :         pthread_cond_t          cond;
<span class="lineNum">     738 </span>            :         uint32_t                events_completed;
<span class="lineNum">     739 </span>            : };
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span>            : struct ibv_comp_channel {
<span class="lineNum">     742 </span>            :         struct ibv_context     *context;
<span class="lineNum">     743 </span>            :         int                     fd;
<span class="lineNum">     744 </span>            :         int                     refcnt;
<span class="lineNum">     745 </span>            : };
<span class="lineNum">     746 </span>            : 
<span class="lineNum">     747 </span>            : struct ibv_cq {
<span class="lineNum">     748 </span>            :         struct ibv_context     *context;
<span class="lineNum">     749 </span>            :         struct ibv_comp_channel *channel;
<span class="lineNum">     750 </span>            :         void                   *cq_context;
<span class="lineNum">     751 </span>            :         uint32_t                handle;
<span class="lineNum">     752 </span>            :         int                     cqe;
<span class="lineNum">     753 </span>            : 
<span class="lineNum">     754 </span>            :         pthread_mutex_t         mutex;
<span class="lineNum">     755 </span>            :         pthread_cond_t          cond;
<span class="lineNum">     756 </span>            :         uint32_t                comp_events_completed;
<span class="lineNum">     757 </span>            :         uint32_t                async_events_completed;
<span class="lineNum">     758 </span>            : };
<span class="lineNum">     759 </span>            : 
<span class="lineNum">     760 </span>            : struct ibv_ah {
<span class="lineNum">     761 </span>            :         struct ibv_context     *context;
<span class="lineNum">     762 </span>            :         struct ibv_pd          *pd;
<span class="lineNum">     763 </span>            :         uint32_t                handle;
<span class="lineNum">     764 </span>            : };
<span class="lineNum">     765 </span>            : 
<span class="lineNum">     766 </span>            : enum ibv_flow_flags {
<span class="lineNum">     767 </span>            :         IBV_FLOW_ATTR_FLAGS_ALLOW_LOOP_BACK = 1,
<span class="lineNum">     768 </span>            : };
<span class="lineNum">     769 </span>            : 
<span class="lineNum">     770 </span>            : enum ibv_flow_attr_type {
<span class="lineNum">     771 </span>            :         /* steering according to rule specifications */
<span class="lineNum">     772 </span>            :         IBV_FLOW_ATTR_NORMAL            = 0x0,
<span class="lineNum">     773 </span>            :         /* default unicast and multicast rule -
<span class="lineNum">     774 </span>            :          * receive all Eth traffic which isn't steered to any QP
<span class="lineNum">     775 </span>            :          */
<span class="lineNum">     776 </span>            :         IBV_FLOW_ATTR_ALL_DEFAULT       = 0x1,
<span class="lineNum">     777 </span>            :         /* default multicast rule -
<span class="lineNum">     778 </span>            :          * receive all Eth multicast traffic which isn't steered to any QP
<span class="lineNum">     779 </span>            :          */
<span class="lineNum">     780 </span>            :         IBV_FLOW_ATTR_MC_DEFAULT        = 0x2,
<span class="lineNum">     781 </span>            : };
<span class="lineNum">     782 </span>            : 
<span class="lineNum">     783 </span>            : enum ibv_flow_spec_type {
<span class="lineNum">     784 </span>            :         IBV_FLOW_SPEC_ETH       = 0x20,
<span class="lineNum">     785 </span>            :         IBV_FLOW_SPEC_IPV4      = 0x30,
<span class="lineNum">     786 </span>            :         IBV_FLOW_SPEC_TCP       = 0x40,
<span class="lineNum">     787 </span>            :         IBV_FLOW_SPEC_UDP       = 0x41,
<span class="lineNum">     788 </span>            : };
<span class="lineNum">     789 </span>            : 
<span class="lineNum">     790 </span>            : struct ibv_flow_eth_filter {
<span class="lineNum">     791 </span>            :         uint8_t         dst_mac[6];
<span class="lineNum">     792 </span>            :         uint8_t         src_mac[6];
<span class="lineNum">     793 </span>            :         uint16_t        ether_type;
<span class="lineNum">     794 </span>            :         /*
<span class="lineNum">     795 </span>            :          * same layout as 802.1q: prio 3, cfi 1, vlan id 12
<span class="lineNum">     796 </span>            :          */
<span class="lineNum">     797 </span>            :         uint16_t        vlan_tag;
<span class="lineNum">     798 </span>            : };
<span class="lineNum">     799 </span>            : 
<span class="lineNum">     800 </span>            : struct ibv_flow_spec_eth {
<span class="lineNum">     801 </span>            :         enum ibv_flow_spec_type  type;
<span class="lineNum">     802 </span>            :         uint16_t  size;
<span class="lineNum">     803 </span>            :         struct ibv_flow_eth_filter val;
<span class="lineNum">     804 </span>            :         struct ibv_flow_eth_filter mask;
<span class="lineNum">     805 </span>            : };
<span class="lineNum">     806 </span>            : 
<span class="lineNum">     807 </span>            : struct ibv_flow_ipv4_filter {
<span class="lineNum">     808 </span>            :         uint32_t src_ip;
<span class="lineNum">     809 </span>            :         uint32_t dst_ip;
<span class="lineNum">     810 </span>            : };
<span class="lineNum">     811 </span>            : 
<span class="lineNum">     812 </span>            : struct ibv_flow_spec_ipv4 {
<span class="lineNum">     813 </span>            :         enum ibv_flow_spec_type  type;
<span class="lineNum">     814 </span>            :         uint16_t  size;
<span class="lineNum">     815 </span>            :         struct ibv_flow_ipv4_filter val;
<span class="lineNum">     816 </span>            :         struct ibv_flow_ipv4_filter mask;
<span class="lineNum">     817 </span>            : };
<span class="lineNum">     818 </span>            : 
<span class="lineNum">     819 </span>            : struct ibv_flow_tcp_udp_filter {
<span class="lineNum">     820 </span>            :         uint16_t dst_port;
<span class="lineNum">     821 </span>            :         uint16_t src_port;
<span class="lineNum">     822 </span>            : };
<span class="lineNum">     823 </span>            : 
<span class="lineNum">     824 </span>            : struct ibv_flow_spec_tcp_udp {
<span class="lineNum">     825 </span>            :         enum ibv_flow_spec_type  type;
<span class="lineNum">     826 </span>            :         uint16_t  size;
<span class="lineNum">     827 </span>            :         struct ibv_flow_tcp_udp_filter val;
<span class="lineNum">     828 </span>            :         struct ibv_flow_tcp_udp_filter mask;
<span class="lineNum">     829 </span>            : };
<span class="lineNum">     830 </span>            : 
<span class="lineNum">     831 </span>            : struct ibv_flow_spec {
<span class="lineNum">     832 </span>            :         union {
<span class="lineNum">     833 </span>            :                 struct {
<span class="lineNum">     834 </span>            :                         enum ibv_flow_spec_type type;
<span class="lineNum">     835 </span>            :                         uint16_t                size;
<span class="lineNum">     836 </span>            :                 } hdr;
<span class="lineNum">     837 </span>            :                 struct ibv_flow_spec_eth eth;
<span class="lineNum">     838 </span>            :                 struct ibv_flow_spec_ipv4 ipv4;
<span class="lineNum">     839 </span>            :                 struct ibv_flow_spec_tcp_udp tcp_udp;
<span class="lineNum">     840 </span>            :         };
<span class="lineNum">     841 </span>            : };
<span class="lineNum">     842 </span>            : 
<span class="lineNum">     843 </span>            : struct ibv_flow_attr {
<span class="lineNum">     844 </span>            :         uint32_t comp_mask;
<span class="lineNum">     845 </span>            :         enum ibv_flow_attr_type type;
<span class="lineNum">     846 </span>            :         uint16_t size;
<span class="lineNum">     847 </span>            :         uint16_t priority;
<span class="lineNum">     848 </span>            :         uint8_t num_of_specs;
<span class="lineNum">     849 </span>            :         uint8_t port;
<span class="lineNum">     850 </span>            :         uint32_t flags;
<span class="lineNum">     851 </span>            :         /* Following are the optional layers according to user request
<span class="lineNum">     852 </span>            :          * struct ibv_flow_spec_xxx [L2]
<span class="lineNum">     853 </span>            :          * struct ibv_flow_spec_yyy [L3/L4]
<span class="lineNum">     854 </span>            :          */
<span class="lineNum">     855 </span>            : };
<span class="lineNum">     856 </span>            : 
<span class="lineNum">     857 </span>            : struct ibv_flow {
<span class="lineNum">     858 </span>            :         uint32_t           comp_mask;
<span class="lineNum">     859 </span>            :         struct ibv_context *context;
<span class="lineNum">     860 </span>            :         uint32_t           handle;
<span class="lineNum">     861 </span>            : };
<span class="lineNum">     862 </span>            : 
<span class="lineNum">     863 </span>            : struct ibv_device;
<span class="lineNum">     864 </span>            : struct ibv_context;
<span class="lineNum">     865 </span>            : 
<span class="lineNum">     866 </span>            : struct ibv_device_ops {
<span class="lineNum">     867 </span>            :         struct ibv_context *    (*alloc_context)(struct ibv_device *device, int cmd_fd);
<span class="lineNum">     868 </span>            :         void                    (*free_context)(struct ibv_context *context);
<span class="lineNum">     869 </span>            : };
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span>            : enum {
<span class="lineNum">     872 </span>            :         IBV_SYSFS_NAME_MAX      = 64,
<span class="lineNum">     873 </span>            :         IBV_SYSFS_PATH_MAX      = 256
<span class="lineNum">     874 </span>            : };
<span class="lineNum">     875 </span>            : 
<span class="lineNum">     876 </span>            : struct ibv_device {
<span class="lineNum">     877 </span>            :         struct ibv_device_ops   ops;
<span class="lineNum">     878 </span>            :         enum ibv_node_type      node_type;
<span class="lineNum">     879 </span>            :         enum ibv_transport_type transport_type;
<span class="lineNum">     880 </span>            :         /* Name of underlying kernel IB device, eg &quot;mthca0&quot; */
<span class="lineNum">     881 </span>            :         char                    name[IBV_SYSFS_NAME_MAX];
<span class="lineNum">     882 </span>            :         /* Name of uverbs device, eg &quot;uverbs0&quot; */
<span class="lineNum">     883 </span>            :         char                    dev_name[IBV_SYSFS_NAME_MAX];
<span class="lineNum">     884 </span>            :         /* Path to infiniband_verbs class device in sysfs */
<span class="lineNum">     885 </span>            :         char                    dev_path[IBV_SYSFS_PATH_MAX];
<span class="lineNum">     886 </span>            :         /* Path to infiniband class device in sysfs */
<span class="lineNum">     887 </span>            :         char                    ibdev_path[IBV_SYSFS_PATH_MAX];
<span class="lineNum">     888 </span>            : };
<span class="lineNum">     889 </span>            : 
<span class="lineNum">     890 </span>            : struct verbs_device {
<span class="lineNum">     891 </span>            :         struct ibv_device device; /* Must be first */
<span class="lineNum">     892 </span>            :         size_t  sz;
<span class="lineNum">     893 </span>            :         size_t  size_of_context;
<span class="lineNum">     894 </span>            :         int     (*init_context)(struct verbs_device *device,
<span class="lineNum">     895 </span>            :                                 struct ibv_context *ctx, int cmd_fd);
<span class="lineNum">     896 </span>            :         void    (*uninit_context)(struct verbs_device *device,
<span class="lineNum">     897 </span>            :                                 struct ibv_context *ctx);
<span class="lineNum">     898 </span>            :         /* future fields added here */
<span class="lineNum">     899 </span>            : };
<span class="lineNum">     900 </span>            : 
<span class="lineNum">     901 </span>            : struct ibv_context_ops {
<span class="lineNum">     902 </span>            :         int                     (*query_device)(struct ibv_context *context,
<span class="lineNum">     903 </span>            :                                               struct ibv_device_attr *device_attr);
<span class="lineNum">     904 </span>            :         int                     (*query_port)(struct ibv_context *context, uint8_t port_num,
<span class="lineNum">     905 </span>            :                                               struct ibv_port_attr *port_attr);
<span class="lineNum">     906 </span>            :         struct ibv_pd *         (*alloc_pd)(struct ibv_context *context);
<span class="lineNum">     907 </span>            :         int                     (*dealloc_pd)(struct ibv_pd *pd);
<span class="lineNum">     908 </span>            :         struct ibv_mr *         (*reg_mr)(struct ibv_pd *pd, void *addr, size_t length,
<span class="lineNum">     909 </span>            :                                           int access);
<span class="lineNum">     910 </span>            :         struct ibv_mr *         (*rereg_mr)(struct ibv_mr *mr,
<span class="lineNum">     911 </span>            :                                             int flags,
<span class="lineNum">     912 </span>            :                                             struct ibv_pd *pd, void *addr,
<span class="lineNum">     913 </span>            :                                             size_t length,
<span class="lineNum">     914 </span>            :                                             int access);
<span class="lineNum">     915 </span>            :         int                     (*dereg_mr)(struct ibv_mr *mr);
<span class="lineNum">     916 </span>            :         struct ibv_mw *         (*alloc_mw)(struct ibv_pd *pd, enum ibv_mw_type type);
<span class="lineNum">     917 </span>            :         int                     (*bind_mw)(struct ibv_qp *qp, struct ibv_mw *mw,
<span class="lineNum">     918 </span>            :                                            struct ibv_mw_bind *mw_bind);
<span class="lineNum">     919 </span>            :         int                     (*dealloc_mw)(struct ibv_mw *mw);
<span class="lineNum">     920 </span>            :         struct ibv_cq *         (*create_cq)(struct ibv_context *context, int cqe,
<span class="lineNum">     921 </span>            :                                              struct ibv_comp_channel *channel,
<span class="lineNum">     922 </span>            :                                              int comp_vector);
<span class="lineNum">     923 </span>            :         int                     (*poll_cq)(struct ibv_cq *cq, int num_entries, struct ibv_wc *wc);
<span class="lineNum">     924 </span>            :         int                     (*req_notify_cq)(struct ibv_cq *cq, int solicited_only);
<span class="lineNum">     925 </span>            :         void                    (*cq_event)(struct ibv_cq *cq);
<span class="lineNum">     926 </span>            :         int                     (*resize_cq)(struct ibv_cq *cq, int cqe);
<span class="lineNum">     927 </span>            :         int                     (*destroy_cq)(struct ibv_cq *cq);
<span class="lineNum">     928 </span>            :         struct ibv_srq *        (*create_srq)(struct ibv_pd *pd,
<span class="lineNum">     929 </span>            :                                               struct ibv_srq_init_attr *srq_init_attr);
<span class="lineNum">     930 </span>            :         int                     (*modify_srq)(struct ibv_srq *srq,
<span class="lineNum">     931 </span>            :                                               struct ibv_srq_attr *srq_attr,
<span class="lineNum">     932 </span>            :                                               int srq_attr_mask);
<span class="lineNum">     933 </span>            :         int                     (*query_srq)(struct ibv_srq *srq,
<span class="lineNum">     934 </span>            :                                              struct ibv_srq_attr *srq_attr);
<span class="lineNum">     935 </span>            :         int                     (*destroy_srq)(struct ibv_srq *srq);
<span class="lineNum">     936 </span>            :         int                     (*post_srq_recv)(struct ibv_srq *srq,
<span class="lineNum">     937 </span>            :                                                  struct ibv_recv_wr *recv_wr,
<span class="lineNum">     938 </span>            :                                                  struct ibv_recv_wr **bad_recv_wr);
<span class="lineNum">     939 </span>            :         struct ibv_qp *         (*create_qp)(struct ibv_pd *pd, struct ibv_qp_init_attr *attr);
<span class="lineNum">     940 </span>            :         int                     (*query_qp)(struct ibv_qp *qp, struct ibv_qp_attr *attr,
<span class="lineNum">     941 </span>            :                                             int attr_mask,
<span class="lineNum">     942 </span>            :                                             struct ibv_qp_init_attr *init_attr);
<span class="lineNum">     943 </span>            :         int                     (*modify_qp)(struct ibv_qp *qp, struct ibv_qp_attr *attr,
<span class="lineNum">     944 </span>            :                                              int attr_mask);
<span class="lineNum">     945 </span>            :         int                     (*destroy_qp)(struct ibv_qp *qp);
<span class="lineNum">     946 </span>            :         int                     (*post_send)(struct ibv_qp *qp, struct ibv_send_wr *wr,
<span class="lineNum">     947 </span>            :                                              struct ibv_send_wr **bad_wr);
<span class="lineNum">     948 </span>            :         int                     (*post_recv)(struct ibv_qp *qp, struct ibv_recv_wr *wr,
<span class="lineNum">     949 </span>            :                                              struct ibv_recv_wr **bad_wr);
<span class="lineNum">     950 </span>            :         struct ibv_ah *         (*create_ah)(struct ibv_pd *pd, struct ibv_ah_attr *attr);
<span class="lineNum">     951 </span>            :         int                     (*destroy_ah)(struct ibv_ah *ah);
<span class="lineNum">     952 </span>            :         int                     (*attach_mcast)(struct ibv_qp *qp, const union ibv_gid *gid,
<span class="lineNum">     953 </span>            :                                                 uint16_t lid);
<span class="lineNum">     954 </span>            :         int                     (*detach_mcast)(struct ibv_qp *qp, const union ibv_gid *gid,
<span class="lineNum">     955 </span>            :                                                 uint16_t lid);
<span class="lineNum">     956 </span>            :         void                    (*async_event)(struct ibv_async_event *event);
<span class="lineNum">     957 </span>            : };
<span class="lineNum">     958 </span>            : 
<span class="lineNum">     959 </span>            : struct ibv_context {
<span class="lineNum">     960 </span>            :         struct ibv_device      *device;
<span class="lineNum">     961 </span>            :         struct ibv_context_ops  ops;
<span class="lineNum">     962 </span>            :         int                     cmd_fd;
<span class="lineNum">     963 </span>            :         int                     async_fd;
<span class="lineNum">     964 </span>            :         int                     num_comp_vectors;
<span class="lineNum">     965 </span>            :         pthread_mutex_t         mutex;
<span class="lineNum">     966 </span>            :         void                   *abi_compat;
<span class="lineNum">     967 </span>            : };
<span class="lineNum">     968 </span>            : 
<span class="lineNum">     969 </span>            : enum verbs_context_mask {
<span class="lineNum">     970 </span>            :         VERBS_CONTEXT_XRCD      = 1 &lt;&lt; 0,
<span class="lineNum">     971 </span>            :         VERBS_CONTEXT_SRQ       = 1 &lt;&lt; 1,
<span class="lineNum">     972 </span>            :         VERBS_CONTEXT_QP        = 1 &lt;&lt; 2,
<span class="lineNum">     973 </span>            :         VERBS_CONTEXT_CREATE_FLOW = 1 &lt;&lt; 3,
<span class="lineNum">     974 </span>            :         VERBS_CONTEXT_DESTROY_FLOW = 1 &lt;&lt; 4,
<span class="lineNum">     975 </span>            :         VERBS_CONTEXT_RESERVED  = 1 &lt;&lt; 5
<span class="lineNum">     976 </span>            : };
<span class="lineNum">     977 </span>            : 
<span class="lineNum">     978 </span>            : struct verbs_context {
<span class="lineNum">     979 </span>            :         /*  &quot;grows up&quot; - new fields go here */
<span class="lineNum">     980 </span>            :         int (*drv_ibv_destroy_flow) (struct ibv_flow *flow);
<span class="lineNum">     981 </span>            :         int (*lib_ibv_destroy_flow) (struct ibv_flow *flow);
<span class="lineNum">     982 </span>            :         struct ibv_flow * (*drv_ibv_create_flow) (struct ibv_qp *qp,
<span class="lineNum">     983 </span>            :                                                   struct ibv_flow_attr
<span class="lineNum">     984 </span>            :                                                   *flow_attr);
<span class="lineNum">     985 </span>            :         struct ibv_flow * (*lib_ibv_create_flow) (struct ibv_qp *qp,
<span class="lineNum">     986 </span>            :                                                   struct ibv_flow_attr
<span class="lineNum">     987 </span>            :                                                   *flow_attr);
<span class="lineNum">     988 </span>            :         struct ibv_qp *(*open_qp)(struct ibv_context *context,
<span class="lineNum">     989 </span>            :                         struct ibv_qp_open_attr *attr);
<span class="lineNum">     990 </span>            :         struct ibv_qp *(*create_qp_ex)(struct ibv_context *context,
<span class="lineNum">     991 </span>            :                         struct ibv_qp_init_attr_ex *qp_init_attr_ex);
<span class="lineNum">     992 </span>            :         int (*get_srq_num)(struct ibv_srq *srq, uint32_t *srq_num);
<span class="lineNum">     993 </span>            :         struct ibv_srq *        (*create_srq_ex)(struct ibv_context *context,
<span class="lineNum">     994 </span>            :                                                  struct ibv_srq_init_attr_ex *srq_init_attr_ex);
<span class="lineNum">     995 </span>            :         struct ibv_xrcd *       (*open_xrcd)(struct ibv_context *context,
<span class="lineNum">     996 </span>            :                                              struct ibv_xrcd_init_attr *xrcd_init_attr);
<span class="lineNum">     997 </span>            :         int                     (*close_xrcd)(struct ibv_xrcd *xrcd);
<span class="lineNum">     998 </span>            :         uint64_t has_comp_mask;
<span class="lineNum">     999 </span>            :         size_t   sz;                    /* Must be immediately before struct ibv_context */
<span class="lineNum">    1000 </span>            :         struct ibv_context context;     /* Must be last field in the struct */
<a name="1001"><span class="lineNum">    1001 </span>            : };</a>
<span class="lineNum">    1002 </span>            : 
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 : static inline struct verbs_context *verbs_get_ctx(struct ibv_context *ctx)</span>
<span class="lineNum">    1004 </span>            : {
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :         return (ctx-&gt;abi_compat != __VERBS_ABI_IS_EXTENDED) ?</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :                 NULL : container_of(ctx, struct verbs_context, context);</span>
<span class="lineNum">    1007 </span>            : }
<span class="lineNum">    1008 </span>            : 
<span class="lineNum">    1009 </span>            : #define verbs_get_ctx_op(ctx, op) ({ \
<span class="lineNum">    1010 </span>            :         struct verbs_context *vctx = verbs_get_ctx(ctx); \
<span class="lineNum">    1011 </span>            :         (!vctx || (vctx-&gt;sz &lt; sizeof(*vctx) - offsetof(struct verbs_context, op)) || \
<span class="lineNum">    1012 </span>            :          !vctx-&gt;op) ? NULL : vctx; })
<span class="lineNum">    1013 </span>            : 
<span class="lineNum">    1014 </span>            : #define verbs_set_ctx_op(_vctx, op, ptr) ({ \
<span class="lineNum">    1015 </span>            :         struct verbs_context *vctx = _vctx; \
<span class="lineNum">    1016 </span>            :         if (vctx &amp;&amp; (vctx-&gt;sz &gt;= sizeof(*vctx) - offsetof(struct verbs_context, op))) \
<span class="lineNum">    1017 </span>            :                 vctx-&gt;op = ptr; })
<span class="lineNum">    1018 </span>            : 
<span class="lineNum">    1019 </span>            : static inline struct verbs_device *verbs_get_device(
<span class="lineNum">    1020 </span>            :                                         const struct ibv_device *dev)
<span class="lineNum">    1021 </span>            : {
<span class="lineNum">    1022 </span>            :         return (dev-&gt;ops.alloc_context) ?
<span class="lineNum">    1023 </span>            :                 NULL : container_of(dev, struct verbs_device, device);
<span class="lineNum">    1024 </span>            : }
<span class="lineNum">    1025 </span>            : 
<span class="lineNum">    1026 </span>            : /**
<span class="lineNum">    1027 </span>            :  * ibv_get_device_list - Get list of IB devices currently available
<span class="lineNum">    1028 </span>            :  * @num_devices: optional.  if non-NULL, set to the number of devices
<span class="lineNum">    1029 </span>            :  * returned in the array.
<span class="lineNum">    1030 </span>            :  *
<span class="lineNum">    1031 </span>            :  * Return a NULL-terminated array of IB devices.  The array can be
<span class="lineNum">    1032 </span>            :  * released with ibv_free_device_list().
<span class="lineNum">    1033 </span>            :  */
<span class="lineNum">    1034 </span>            : struct ibv_device **ibv_get_device_list(int *num_devices);
<span class="lineNum">    1035 </span>            : 
<span class="lineNum">    1036 </span>            : /**
<span class="lineNum">    1037 </span>            :  * ibv_free_device_list - Free list from ibv_get_device_list()
<span class="lineNum">    1038 </span>            :  *
<span class="lineNum">    1039 </span>            :  * Free an array of devices returned from ibv_get_device_list().  Once
<span class="lineNum">    1040 </span>            :  * the array is freed, pointers to devices that were not opened with
<span class="lineNum">    1041 </span>            :  * ibv_open_device() are no longer valid.  Client code must open all
<span class="lineNum">    1042 </span>            :  * devices it intends to use before calling ibv_free_device_list().
<span class="lineNum">    1043 </span>            :  */
<span class="lineNum">    1044 </span>            : void ibv_free_device_list(struct ibv_device **list);
<span class="lineNum">    1045 </span>            : 
<span class="lineNum">    1046 </span>            : /**
<span class="lineNum">    1047 </span>            :  * ibv_get_device_name - Return kernel device name
<span class="lineNum">    1048 </span>            :  */
<span class="lineNum">    1049 </span>            : const char *ibv_get_device_name(struct ibv_device *device);
<span class="lineNum">    1050 </span>            : 
<span class="lineNum">    1051 </span>            : /**
<span class="lineNum">    1052 </span>            :  * ibv_get_device_guid - Return device's node GUID
<span class="lineNum">    1053 </span>            :  */
<span class="lineNum">    1054 </span>            : uint64_t ibv_get_device_guid(struct ibv_device *device);
<span class="lineNum">    1055 </span>            : 
<span class="lineNum">    1056 </span>            : /**
<span class="lineNum">    1057 </span>            :  * ibv_open_device - Initialize device for use
<span class="lineNum">    1058 </span>            :  */
<span class="lineNum">    1059 </span>            : struct ibv_context *ibv_open_device(struct ibv_device *device);
<span class="lineNum">    1060 </span>            : 
<span class="lineNum">    1061 </span>            : /**
<span class="lineNum">    1062 </span>            :  * ibv_close_device - Release device
<span class="lineNum">    1063 </span>            :  */
<span class="lineNum">    1064 </span>            : int ibv_close_device(struct ibv_context *context);
<span class="lineNum">    1065 </span>            : 
<span class="lineNum">    1066 </span>            : /**
<span class="lineNum">    1067 </span>            :  * ibv_get_async_event - Get next async event
<span class="lineNum">    1068 </span>            :  * @event: Pointer to use to return async event
<span class="lineNum">    1069 </span>            :  *
<span class="lineNum">    1070 </span>            :  * All async events returned by ibv_get_async_event() must eventually
<span class="lineNum">    1071 </span>            :  * be acknowledged with ibv_ack_async_event().
<span class="lineNum">    1072 </span>            :  */
<span class="lineNum">    1073 </span>            : int ibv_get_async_event(struct ibv_context *context,
<span class="lineNum">    1074 </span>            :                         struct ibv_async_event *event);
<span class="lineNum">    1075 </span>            : 
<span class="lineNum">    1076 </span>            : /**
<span class="lineNum">    1077 </span>            :  * ibv_ack_async_event - Acknowledge an async event
<span class="lineNum">    1078 </span>            :  * @event: Event to be acknowledged.
<span class="lineNum">    1079 </span>            :  *
<span class="lineNum">    1080 </span>            :  * All async events which are returned by ibv_get_async_event() must
<span class="lineNum">    1081 </span>            :  * be acknowledged.  To avoid races, destroying an object (CQ, SRQ or
<span class="lineNum">    1082 </span>            :  * QP) will wait for all affiliated events to be acknowledged, so
<span class="lineNum">    1083 </span>            :  * there should be a one-to-one correspondence between acks and
<span class="lineNum">    1084 </span>            :  * successful gets.
<span class="lineNum">    1085 </span>            :  */
<span class="lineNum">    1086 </span>            : void ibv_ack_async_event(struct ibv_async_event *event);
<span class="lineNum">    1087 </span>            : 
<span class="lineNum">    1088 </span>            : /**
<span class="lineNum">    1089 </span>            :  * ibv_query_device - Get device properties
<span class="lineNum">    1090 </span>            :  */
<span class="lineNum">    1091 </span>            : int ibv_query_device(struct ibv_context *context,
<span class="lineNum">    1092 </span>            :                      struct ibv_device_attr *device_attr);
<span class="lineNum">    1093 </span>            : 
<span class="lineNum">    1094 </span>            : /**
<span class="lineNum">    1095 </span>            :  * ibv_query_port - Get port properties
<span class="lineNum">    1096 </span>            :  */
<span class="lineNum">    1097 </span>            : int ibv_query_port(struct ibv_context *context, uint8_t port_num,
<a name="1098"><span class="lineNum">    1098 </span>            :                    struct ibv_port_attr *port_attr);</a>
<span class="lineNum">    1099 </span>            : 
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 : static inline int ___ibv_query_port(struct ibv_context *context,</span>
<span class="lineNum">    1101 </span>            :                                     uint8_t port_num,
<span class="lineNum">    1102 </span>            :                                     struct ibv_port_attr *port_attr)
<span class="lineNum">    1103 </span>            : {
<span class="lineNum">    1104 </span>            :         /* For compatibility when running with old libibverbs */
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :         port_attr-&gt;link_layer = IBV_LINK_LAYER_UNSPECIFIED;</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :         port_attr-&gt;reserved   = 0;</span>
<span class="lineNum">    1107 </span>            : 
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :         return ibv_query_port(context, port_num, port_attr);</span>
<span class="lineNum">    1109 </span>            : }
<span class="lineNum">    1110 </span>            : 
<span class="lineNum">    1111 </span>            : #define ibv_query_port(context, port_num, port_attr) \
<span class="lineNum">    1112 </span>            :         ___ibv_query_port(context, port_num, port_attr)
<span class="lineNum">    1113 </span>            : 
<span class="lineNum">    1114 </span>            : /**
<span class="lineNum">    1115 </span>            :  * ibv_query_gid - Get a GID table entry
<span class="lineNum">    1116 </span>            :  */
<span class="lineNum">    1117 </span>            : int ibv_query_gid(struct ibv_context *context, uint8_t port_num,
<span class="lineNum">    1118 </span>            :                   int index, union ibv_gid *gid);
<span class="lineNum">    1119 </span>            : 
<span class="lineNum">    1120 </span>            : /**
<span class="lineNum">    1121 </span>            :  * ibv_query_pkey - Get a P_Key table entry
<span class="lineNum">    1122 </span>            :  */
<span class="lineNum">    1123 </span>            : int ibv_query_pkey(struct ibv_context *context, uint8_t port_num,
<span class="lineNum">    1124 </span>            :                    int index, uint16_t *pkey);
<span class="lineNum">    1125 </span>            : 
<span class="lineNum">    1126 </span>            : /**
<span class="lineNum">    1127 </span>            :  * ibv_alloc_pd - Allocate a protection domain
<span class="lineNum">    1128 </span>            :  */
<span class="lineNum">    1129 </span>            : struct ibv_pd *ibv_alloc_pd(struct ibv_context *context);
<span class="lineNum">    1130 </span>            : 
<span class="lineNum">    1131 </span>            : /**
<span class="lineNum">    1132 </span>            :  * ibv_dealloc_pd - Free a protection domain
<span class="lineNum">    1133 </span>            :  */
<span class="lineNum">    1134 </span>            : int ibv_dealloc_pd(struct ibv_pd *pd);
<span class="lineNum">    1135 </span>            : 
<span class="lineNum">    1136 </span>            : static inline struct ibv_flow *ibv_create_flow(struct ibv_qp *qp,
<span class="lineNum">    1137 </span>            :                                                struct ibv_flow_attr *flow)
<span class="lineNum">    1138 </span>            : {
<span class="lineNum">    1139 </span>            :         struct verbs_context *vctx = verbs_get_ctx_op(qp-&gt;context,
<span class="lineNum">    1140 </span>            :                                                       lib_ibv_create_flow);
<span class="lineNum">    1141 </span>            :         if (!vctx || !vctx-&gt;lib_ibv_create_flow)
<span class="lineNum">    1142 </span>            :                 return NULL;
<span class="lineNum">    1143 </span>            : 
<span class="lineNum">    1144 </span>            :         return vctx-&gt;lib_ibv_create_flow(qp, flow);
<span class="lineNum">    1145 </span>            : }
<span class="lineNum">    1146 </span>            : 
<span class="lineNum">    1147 </span>            : static inline int ibv_destroy_flow(struct ibv_flow *flow_id)
<span class="lineNum">    1148 </span>            : {
<span class="lineNum">    1149 </span>            :         struct verbs_context *vctx = verbs_get_ctx_op(flow_id-&gt;context,
<span class="lineNum">    1150 </span>            :                                                       lib_ibv_destroy_flow);
<span class="lineNum">    1151 </span>            :         if (!vctx || !vctx-&gt;lib_ibv_destroy_flow)
<span class="lineNum">    1152 </span>            :                 return -ENOSYS;
<span class="lineNum">    1153 </span>            :         return vctx-&gt;lib_ibv_destroy_flow(flow_id);
<span class="lineNum">    1154 </span>            : }
<span class="lineNum">    1155 </span>            : 
<span class="lineNum">    1156 </span>            : /**
<span class="lineNum">    1157 </span>            :  * ibv_open_xrcd - Open an extended connection domain
<a name="1158"><span class="lineNum">    1158 </span>            :  */</a>
<span class="lineNum">    1159 </span>            : static inline struct ibv_xrcd *
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 : ibv_open_xrcd(struct ibv_context *context, struct ibv_xrcd_init_attr *xrcd_init_attr)</span>
<span class="lineNum">    1161 </span>            : {
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :         struct verbs_context *vctx = verbs_get_ctx_op(context, open_xrcd);</span>
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :         if (!vctx) {</span>
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :                 errno = ENOSYS;</span>
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1166 </span>            :         }
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :         return vctx-&gt;open_xrcd(context, xrcd_init_attr);</span>
<span class="lineNum">    1168 </span>            : }
<span class="lineNum">    1169 </span>            : 
<span class="lineNum">    1170 </span>            : /**
<a name="1171"><span class="lineNum">    1171 </span>            :  * ibv_close_xrcd - Close an extended connection domain</a>
<span class="lineNum">    1172 </span>            :  */
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 : static inline int ibv_close_xrcd(struct ibv_xrcd *xrcd)</span>
<span class="lineNum">    1174 </span>            : {
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :         struct verbs_context *vctx = verbs_get_ctx(xrcd-&gt;context);</span>
<span class="lineNum">    1176 </span><span class="lineNoCov">          0 :         return vctx-&gt;close_xrcd(xrcd);</span>
<span class="lineNum">    1177 </span>            : }
<span class="lineNum">    1178 </span>            : 
<span class="lineNum">    1179 </span>            : /**
<span class="lineNum">    1180 </span>            :  * ibv_reg_mr - Register a memory region
<span class="lineNum">    1181 </span>            :  */
<span class="lineNum">    1182 </span>            : struct ibv_mr *ibv_reg_mr(struct ibv_pd *pd, void *addr,
<span class="lineNum">    1183 </span>            :                           size_t length, int access);
<span class="lineNum">    1184 </span>            : 
<span class="lineNum">    1185 </span>            : /**
<span class="lineNum">    1186 </span>            :  * ibv_dereg_mr - Deregister a memory region
<span class="lineNum">    1187 </span>            :  */
<span class="lineNum">    1188 </span>            : int ibv_dereg_mr(struct ibv_mr *mr);
<span class="lineNum">    1189 </span>            : 
<span class="lineNum">    1190 </span>            : /**
<span class="lineNum">    1191 </span>            :  * ibv_create_comp_channel - Create a completion event channel
<span class="lineNum">    1192 </span>            :  */
<span class="lineNum">    1193 </span>            : struct ibv_comp_channel *ibv_create_comp_channel(struct ibv_context *context);
<span class="lineNum">    1194 </span>            : 
<span class="lineNum">    1195 </span>            : /**
<span class="lineNum">    1196 </span>            :  * ibv_destroy_comp_channel - Destroy a completion event channel
<span class="lineNum">    1197 </span>            :  */
<span class="lineNum">    1198 </span>            : int ibv_destroy_comp_channel(struct ibv_comp_channel *channel);
<span class="lineNum">    1199 </span>            : 
<span class="lineNum">    1200 </span>            : /**
<span class="lineNum">    1201 </span>            :  * ibv_create_cq - Create a completion queue
<span class="lineNum">    1202 </span>            :  * @context - Context CQ will be attached to
<span class="lineNum">    1203 </span>            :  * @cqe - Minimum number of entries required for CQ
<span class="lineNum">    1204 </span>            :  * @cq_context - Consumer-supplied context returned for completion events
<span class="lineNum">    1205 </span>            :  * @channel - Completion channel where completion events will be queued.
<span class="lineNum">    1206 </span>            :  *     May be NULL if completion events will not be used.
<span class="lineNum">    1207 </span>            :  * @comp_vector - Completion vector used to signal completion events.
<span class="lineNum">    1208 </span>            :  *     Must be &gt;= 0 and &lt; context-&gt;num_comp_vectors.
<span class="lineNum">    1209 </span>            :  */
<span class="lineNum">    1210 </span>            : struct ibv_cq *ibv_create_cq(struct ibv_context *context, int cqe,
<span class="lineNum">    1211 </span>            :                              void *cq_context,
<span class="lineNum">    1212 </span>            :                              struct ibv_comp_channel *channel,
<span class="lineNum">    1213 </span>            :                              int comp_vector);
<span class="lineNum">    1214 </span>            : 
<span class="lineNum">    1215 </span>            : /**
<span class="lineNum">    1216 </span>            :  * ibv_resize_cq - Modifies the capacity of the CQ.
<span class="lineNum">    1217 </span>            :  * @cq: The CQ to resize.
<span class="lineNum">    1218 </span>            :  * @cqe: The minimum size of the CQ.
<span class="lineNum">    1219 </span>            :  *
<span class="lineNum">    1220 </span>            :  * Users can examine the cq structure to determine the actual CQ size.
<span class="lineNum">    1221 </span>            :  */
<span class="lineNum">    1222 </span>            : int ibv_resize_cq(struct ibv_cq *cq, int cqe);
<span class="lineNum">    1223 </span>            : 
<span class="lineNum">    1224 </span>            : /**
<span class="lineNum">    1225 </span>            :  * ibv_destroy_cq - Destroy a completion queue
<span class="lineNum">    1226 </span>            :  */
<span class="lineNum">    1227 </span>            : int ibv_destroy_cq(struct ibv_cq *cq);
<span class="lineNum">    1228 </span>            : 
<span class="lineNum">    1229 </span>            : /**
<span class="lineNum">    1230 </span>            :  * ibv_get_cq_event - Read next CQ event
<span class="lineNum">    1231 </span>            :  * @channel: Channel to get next event from.
<span class="lineNum">    1232 </span>            :  * @cq: Used to return pointer to CQ.
<span class="lineNum">    1233 </span>            :  * @cq_context: Used to return consumer-supplied CQ context.
<span class="lineNum">    1234 </span>            :  *
<span class="lineNum">    1235 </span>            :  * All completion events returned by ibv_get_cq_event() must
<span class="lineNum">    1236 </span>            :  * eventually be acknowledged with ibv_ack_cq_events().
<span class="lineNum">    1237 </span>            :  */
<span class="lineNum">    1238 </span>            : int ibv_get_cq_event(struct ibv_comp_channel *channel,
<span class="lineNum">    1239 </span>            :                      struct ibv_cq **cq, void **cq_context);
<span class="lineNum">    1240 </span>            : 
<span class="lineNum">    1241 </span>            : /**
<span class="lineNum">    1242 </span>            :  * ibv_ack_cq_events - Acknowledge CQ completion events
<span class="lineNum">    1243 </span>            :  * @cq: CQ to acknowledge events for
<span class="lineNum">    1244 </span>            :  * @nevents: Number of events to acknowledge.
<span class="lineNum">    1245 </span>            :  *
<span class="lineNum">    1246 </span>            :  * All completion events which are returned by ibv_get_cq_event() must
<span class="lineNum">    1247 </span>            :  * be acknowledged.  To avoid races, ibv_destroy_cq() will wait for
<span class="lineNum">    1248 </span>            :  * all completion events to be acknowledged, so there should be a
<span class="lineNum">    1249 </span>            :  * one-to-one correspondence between acks and successful gets.  An
<span class="lineNum">    1250 </span>            :  * application may accumulate multiple completion events and
<span class="lineNum">    1251 </span>            :  * acknowledge them in a single call to ibv_ack_cq_events() by passing
<span class="lineNum">    1252 </span>            :  * the number of events to ack in @nevents.
<span class="lineNum">    1253 </span>            :  */
<span class="lineNum">    1254 </span>            : void ibv_ack_cq_events(struct ibv_cq *cq, unsigned int nevents);
<span class="lineNum">    1255 </span>            : 
<span class="lineNum">    1256 </span>            : /**
<span class="lineNum">    1257 </span>            :  * ibv_poll_cq - Poll a CQ for work completions
<span class="lineNum">    1258 </span>            :  * @cq:the CQ being polled
<span class="lineNum">    1259 </span>            :  * @num_entries:maximum number of completions to return
<span class="lineNum">    1260 </span>            :  * @wc:array of at least @num_entries of &amp;struct ibv_wc where completions
<span class="lineNum">    1261 </span>            :  *   will be returned
<span class="lineNum">    1262 </span>            :  *
<span class="lineNum">    1263 </span>            :  * Poll a CQ for (possibly multiple) completions.  If the return value
<span class="lineNum">    1264 </span>            :  * is &lt; 0, an error occurred.  If the return value is &gt;= 0, it is the
<span class="lineNum">    1265 </span>            :  * number of completions returned.  If the return value is
<span class="lineNum">    1266 </span>            :  * non-negative and strictly less than num_entries, then the CQ was
<a name="1267"><span class="lineNum">    1267 </span>            :  * emptied.</a>
<span class="lineNum">    1268 </span>            :  */
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 : static inline int ibv_poll_cq(struct ibv_cq *cq, int num_entries, struct ibv_wc *wc)</span>
<span class="lineNum">    1270 </span>            : {
<span class="lineNum">    1271 </span><span class="lineNoCov">          0 :         return cq-&gt;context-&gt;ops.poll_cq(cq, num_entries, wc);</span>
<span class="lineNum">    1272 </span>            : }
<span class="lineNum">    1273 </span>            : 
<span class="lineNum">    1274 </span>            : /**
<span class="lineNum">    1275 </span>            :  * ibv_req_notify_cq - Request completion notification on a CQ.  An
<span class="lineNum">    1276 </span>            :  *   event will be added to the completion channel associated with the
<span class="lineNum">    1277 </span>            :  *   CQ when an entry is added to the CQ.
<span class="lineNum">    1278 </span>            :  * @cq: The completion queue to request notification for.
<span class="lineNum">    1279 </span>            :  * @solicited_only: If non-zero, an event will be generated only for
<span class="lineNum">    1280 </span>            :  *   the next solicited CQ entry.  If zero, any CQ entry, solicited or
<a name="1281"><span class="lineNum">    1281 </span>            :  *   not, will generate an event.</a>
<span class="lineNum">    1282 </span>            :  */
<span class="lineNum">    1283 </span><span class="lineNoCov">          0 : static inline int ibv_req_notify_cq(struct ibv_cq *cq, int solicited_only)</span>
<span class="lineNum">    1284 </span>            : {
<span class="lineNum">    1285 </span><span class="lineNoCov">          0 :         return cq-&gt;context-&gt;ops.req_notify_cq(cq, solicited_only);</span>
<span class="lineNum">    1286 </span>            : }
<span class="lineNum">    1287 </span>            : 
<span class="lineNum">    1288 </span>            : /**
<span class="lineNum">    1289 </span>            :  * ibv_create_srq - Creates a SRQ associated with the specified protection
<span class="lineNum">    1290 </span>            :  *   domain.
<span class="lineNum">    1291 </span>            :  * @pd: The protection domain associated with the SRQ.
<span class="lineNum">    1292 </span>            :  * @srq_init_attr: A list of initial attributes required to create the SRQ.
<span class="lineNum">    1293 </span>            :  *
<span class="lineNum">    1294 </span>            :  * srq_attr-&gt;max_wr and srq_attr-&gt;max_sge are read the determine the
<span class="lineNum">    1295 </span>            :  * requested size of the SRQ, and set to the actual values allocated
<span class="lineNum">    1296 </span>            :  * on return.  If ibv_create_srq() succeeds, then max_wr and max_sge
<span class="lineNum">    1297 </span>            :  * will always be at least as large as the requested values.
<span class="lineNum">    1298 </span>            :  */
<span class="lineNum">    1299 </span>            : struct ibv_srq *ibv_create_srq(struct ibv_pd *pd,
<span class="lineNum">    1300 </span>            :                                struct ibv_srq_init_attr *srq_init_attr);
<a name="1301"><span class="lineNum">    1301 </span>            : </a>
<span class="lineNum">    1302 </span>            : static inline struct ibv_srq *
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 : ibv_create_srq_ex(struct ibv_context *context,</span>
<span class="lineNum">    1304 </span>            :                   struct ibv_srq_init_attr_ex *srq_init_attr_ex)
<span class="lineNum">    1305 </span>            : {
<span class="lineNum">    1306 </span>            :         struct verbs_context *vctx;
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :         uint32_t mask = srq_init_attr_ex-&gt;comp_mask;</span>
<span class="lineNum">    1308 </span>            : 
<span class="lineNum">    1309 </span><span class="lineNoCov">          0 :         if (!(mask &amp; ~(IBV_SRQ_INIT_ATTR_PD | IBV_SRQ_INIT_ATTR_TYPE)) &amp;&amp;</span>
<span class="lineNum">    1310 </span><span class="lineNoCov">          0 :             (mask &amp; IBV_SRQ_INIT_ATTR_PD) &amp;&amp;</span>
<span class="lineNum">    1311 </span><span class="lineNoCov">          0 :             (!(mask &amp; IBV_SRQ_INIT_ATTR_TYPE) ||</span>
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :              (srq_init_attr_ex-&gt;srq_type == IBV_SRQT_BASIC)))</span>
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :                 return ibv_create_srq(srq_init_attr_ex-&gt;pd,</span>
<span class="lineNum">    1314 </span>            :                                       (struct ibv_srq_init_attr *)srq_init_attr_ex);
<span class="lineNum">    1315 </span>            : 
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :         vctx = verbs_get_ctx_op(context, create_srq_ex);</span>
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 :         if (!vctx) {</span>
<span class="lineNum">    1318 </span><span class="lineNoCov">          0 :                 errno = ENOSYS;</span>
<span class="lineNum">    1319 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1320 </span>            :         }
<span class="lineNum">    1321 </span><span class="lineNoCov">          0 :         return vctx-&gt;create_srq_ex(context, srq_init_attr_ex);</span>
<span class="lineNum">    1322 </span>            : }
<span class="lineNum">    1323 </span>            : 
<span class="lineNum">    1324 </span>            : /**
<span class="lineNum">    1325 </span>            :  * ibv_modify_srq - Modifies the attributes for the specified SRQ.
<span class="lineNum">    1326 </span>            :  * @srq: The SRQ to modify.
<span class="lineNum">    1327 </span>            :  * @srq_attr: On input, specifies the SRQ attributes to modify.  On output,
<span class="lineNum">    1328 </span>            :  *   the current values of selected SRQ attributes are returned.
<span class="lineNum">    1329 </span>            :  * @srq_attr_mask: A bit-mask used to specify which attributes of the SRQ
<span class="lineNum">    1330 </span>            :  *   are being modified.
<span class="lineNum">    1331 </span>            :  *
<span class="lineNum">    1332 </span>            :  * The mask may contain IBV_SRQ_MAX_WR to resize the SRQ and/or
<span class="lineNum">    1333 </span>            :  * IBV_SRQ_LIMIT to set the SRQ's limit and request notification when
<span class="lineNum">    1334 </span>            :  * the number of receives queued drops below the limit.
<span class="lineNum">    1335 </span>            :  */
<span class="lineNum">    1336 </span>            : int ibv_modify_srq(struct ibv_srq *srq,
<span class="lineNum">    1337 </span>            :                    struct ibv_srq_attr *srq_attr,
<span class="lineNum">    1338 </span>            :                    int srq_attr_mask);
<span class="lineNum">    1339 </span>            : 
<span class="lineNum">    1340 </span>            : /**
<span class="lineNum">    1341 </span>            :  * ibv_query_srq - Returns the attribute list and current values for the
<span class="lineNum">    1342 </span>            :  *   specified SRQ.
<span class="lineNum">    1343 </span>            :  * @srq: The SRQ to query.
<span class="lineNum">    1344 </span>            :  * @srq_attr: The attributes of the specified SRQ.
<span class="lineNum">    1345 </span>            :  */
<a name="1346"><span class="lineNum">    1346 </span>            : int ibv_query_srq(struct ibv_srq *srq, struct ibv_srq_attr *srq_attr);</a>
<span class="lineNum">    1347 </span>            : 
<span class="lineNum">    1348 </span><span class="lineNoCov">          0 : static inline int ibv_get_srq_num(struct ibv_srq *srq, uint32_t *srq_num)</span>
<span class="lineNum">    1349 </span>            : {
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :         struct verbs_context *vctx = verbs_get_ctx_op(srq-&gt;context, get_srq_num);</span>
<span class="lineNum">    1351 </span>            : 
<span class="lineNum">    1352 </span><span class="lineNoCov">          0 :         if (!vctx)</span>
<span class="lineNum">    1353 </span><span class="lineNoCov">          0 :                 return ENOSYS;</span>
<span class="lineNum">    1354 </span>            : 
<span class="lineNum">    1355 </span><span class="lineNoCov">          0 :         return vctx-&gt;get_srq_num(srq, srq_num);</span>
<span class="lineNum">    1356 </span>            : }
<span class="lineNum">    1357 </span>            : 
<span class="lineNum">    1358 </span>            : /**
<span class="lineNum">    1359 </span>            :  * ibv_destroy_srq - Destroys the specified SRQ.
<span class="lineNum">    1360 </span>            :  * @srq: The SRQ to destroy.
<span class="lineNum">    1361 </span>            :  */
<span class="lineNum">    1362 </span>            : int ibv_destroy_srq(struct ibv_srq *srq);
<span class="lineNum">    1363 </span>            : 
<span class="lineNum">    1364 </span>            : /**
<span class="lineNum">    1365 </span>            :  * ibv_post_srq_recv - Posts a list of work requests to the specified SRQ.
<span class="lineNum">    1366 </span>            :  * @srq: The SRQ to post the work request on.
<span class="lineNum">    1367 </span>            :  * @recv_wr: A list of work requests to post on the receive queue.
<span class="lineNum">    1368 </span>            :  * @bad_recv_wr: On an immediate failure, this parameter will reference
<a name="1369"><span class="lineNum">    1369 </span>            :  *   the work request that failed to be posted on the QP.</a>
<span class="lineNum">    1370 </span>            :  */
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 : static inline int ibv_post_srq_recv(struct ibv_srq *srq,</span>
<span class="lineNum">    1372 </span>            :                                     struct ibv_recv_wr *recv_wr,
<span class="lineNum">    1373 </span>            :                                     struct ibv_recv_wr **bad_recv_wr)
<span class="lineNum">    1374 </span>            : {
<span class="lineNum">    1375 </span><span class="lineNoCov">          0 :         return srq-&gt;context-&gt;ops.post_srq_recv(srq, recv_wr, bad_recv_wr);</span>
<span class="lineNum">    1376 </span>            : }
<span class="lineNum">    1377 </span>            : 
<span class="lineNum">    1378 </span>            : /**
<span class="lineNum">    1379 </span>            :  * ibv_create_qp - Create a queue pair.
<span class="lineNum">    1380 </span>            :  */
<span class="lineNum">    1381 </span>            : struct ibv_qp *ibv_create_qp(struct ibv_pd *pd,
<span class="lineNum">    1382 </span>            :                              struct ibv_qp_init_attr *qp_init_attr);
<a name="1383"><span class="lineNum">    1383 </span>            : </a>
<span class="lineNum">    1384 </span>            : static inline struct ibv_qp *
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 : ibv_create_qp_ex(struct ibv_context *context, struct ibv_qp_init_attr_ex *qp_init_attr_ex)</span>
<span class="lineNum">    1386 </span>            : {
<span class="lineNum">    1387 </span>            :         struct verbs_context *vctx;
<span class="lineNum">    1388 </span><span class="lineNoCov">          0 :         uint32_t mask = qp_init_attr_ex-&gt;comp_mask;</span>
<span class="lineNum">    1389 </span>            : 
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 :         if (mask == IBV_QP_INIT_ATTR_PD)</span>
<span class="lineNum">    1391 </span><span class="lineNoCov">          0 :                 return ibv_create_qp(qp_init_attr_ex-&gt;pd,</span>
<span class="lineNum">    1392 </span>            :                                      (struct ibv_qp_init_attr *)qp_init_attr_ex);
<span class="lineNum">    1393 </span>            : 
<span class="lineNum">    1394 </span><span class="lineNoCov">          0 :         vctx = verbs_get_ctx_op(context, create_qp_ex);</span>
<span class="lineNum">    1395 </span><span class="lineNoCov">          0 :         if (!vctx) {</span>
<span class="lineNum">    1396 </span><span class="lineNoCov">          0 :                 errno = ENOSYS;</span>
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1398 </span>            :         }
<span class="lineNum">    1399 </span><span class="lineNoCov">          0 :         return vctx-&gt;create_qp_ex(context, qp_init_attr_ex);</span>
<span class="lineNum">    1400 </span>            : }
<span class="lineNum">    1401 </span>            : 
<span class="lineNum">    1402 </span>            : /**
<span class="lineNum">    1403 </span>            :  * ibv_open_qp - Open a shareable queue pair.
<a name="1404"><span class="lineNum">    1404 </span>            :  */</a>
<span class="lineNum">    1405 </span>            : static inline struct ibv_qp *
<span class="lineNum">    1406 </span><span class="lineNoCov">          0 : ibv_open_qp(struct ibv_context *context, struct ibv_qp_open_attr *qp_open_attr)</span>
<span class="lineNum">    1407 </span>            : {
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :         struct verbs_context *vctx = verbs_get_ctx_op(context, open_qp);</span>
<span class="lineNum">    1409 </span><span class="lineNoCov">          0 :         if (!vctx) {</span>
<span class="lineNum">    1410 </span><span class="lineNoCov">          0 :                 errno = ENOSYS;</span>
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1412 </span>            :         }
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :         return vctx-&gt;open_qp(context, qp_open_attr);</span>
<span class="lineNum">    1414 </span>            : }
<span class="lineNum">    1415 </span>            : 
<span class="lineNum">    1416 </span>            : /**
<span class="lineNum">    1417 </span>            :  * ibv_modify_qp - Modify a queue pair.
<span class="lineNum">    1418 </span>            :  */
<span class="lineNum">    1419 </span>            : int ibv_modify_qp(struct ibv_qp *qp, struct ibv_qp_attr *attr,
<span class="lineNum">    1420 </span>            :                   int attr_mask);
<span class="lineNum">    1421 </span>            : 
<span class="lineNum">    1422 </span>            : /**
<span class="lineNum">    1423 </span>            :  * ibv_query_qp - Returns the attribute list and current values for the
<span class="lineNum">    1424 </span>            :  *   specified QP.
<span class="lineNum">    1425 </span>            :  * @qp: The QP to query.
<span class="lineNum">    1426 </span>            :  * @attr: The attributes of the specified QP.
<span class="lineNum">    1427 </span>            :  * @attr_mask: A bit-mask used to select specific attributes to query.
<span class="lineNum">    1428 </span>            :  * @init_attr: Additional attributes of the selected QP.
<span class="lineNum">    1429 </span>            :  *
<span class="lineNum">    1430 </span>            :  * The qp_attr_mask may be used to limit the query to gathering only the
<span class="lineNum">    1431 </span>            :  * selected attributes.
<span class="lineNum">    1432 </span>            :  */
<span class="lineNum">    1433 </span>            : int ibv_query_qp(struct ibv_qp *qp, struct ibv_qp_attr *attr,
<span class="lineNum">    1434 </span>            :                  int attr_mask,
<span class="lineNum">    1435 </span>            :                  struct ibv_qp_init_attr *init_attr);
<span class="lineNum">    1436 </span>            : 
<span class="lineNum">    1437 </span>            : /**
<span class="lineNum">    1438 </span>            :  * ibv_destroy_qp - Destroy a queue pair.
<span class="lineNum">    1439 </span>            :  */
<span class="lineNum">    1440 </span>            : int ibv_destroy_qp(struct ibv_qp *qp);
<span class="lineNum">    1441 </span>            : 
<span class="lineNum">    1442 </span>            : /**
<span class="lineNum">    1443 </span>            :  * ibv_post_send - Post a list of work requests to a send queue.
<span class="lineNum">    1444 </span>            :  *
<span class="lineNum">    1445 </span>            :  * If IBV_SEND_INLINE flag is set, the data buffers can be reused
<a name="1446"><span class="lineNum">    1446 </span>            :  * immediately after the call returns.</a>
<span class="lineNum">    1447 </span>            :  */
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 : static inline int ibv_post_send(struct ibv_qp *qp, struct ibv_send_wr *wr,</span>
<span class="lineNum">    1449 </span>            :                                 struct ibv_send_wr **bad_wr)
<span class="lineNum">    1450 </span>            : {
<span class="lineNum">    1451 </span><span class="lineNoCov">          0 :         return qp-&gt;context-&gt;ops.post_send(qp, wr, bad_wr);</span>
<span class="lineNum">    1452 </span>            : }
<span class="lineNum">    1453 </span>            : 
<span class="lineNum">    1454 </span>            : /**
<a name="1455"><span class="lineNum">    1455 </span>            :  * ibv_post_recv - Post a list of work requests to a receive queue.</a>
<span class="lineNum">    1456 </span>            :  */
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 : static inline int ibv_post_recv(struct ibv_qp *qp, struct ibv_recv_wr *wr,</span>
<span class="lineNum">    1458 </span>            :                                 struct ibv_recv_wr **bad_wr)
<span class="lineNum">    1459 </span>            : {
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 :         return qp-&gt;context-&gt;ops.post_recv(qp, wr, bad_wr);</span>
<span class="lineNum">    1461 </span>            : }
<span class="lineNum">    1462 </span>            : 
<span class="lineNum">    1463 </span>            : /**
<span class="lineNum">    1464 </span>            :  * ibv_create_ah - Create an address handle.
<span class="lineNum">    1465 </span>            :  */
<span class="lineNum">    1466 </span>            : struct ibv_ah *ibv_create_ah(struct ibv_pd *pd, struct ibv_ah_attr *attr);
<span class="lineNum">    1467 </span>            : 
<span class="lineNum">    1468 </span>            : /**
<span class="lineNum">    1469 </span>            :  * ibv_init_ah_from_wc - Initializes address handle attributes from a
<span class="lineNum">    1470 </span>            :  *   work completion.
<span class="lineNum">    1471 </span>            :  * @context: Device context on which the received message arrived.
<span class="lineNum">    1472 </span>            :  * @port_num: Port on which the received message arrived.
<span class="lineNum">    1473 </span>            :  * @wc: Work completion associated with the received message.
<span class="lineNum">    1474 </span>            :  * @grh: References the received global route header.  This parameter is
<span class="lineNum">    1475 </span>            :  *   ignored unless the work completion indicates that the GRH is valid.
<span class="lineNum">    1476 </span>            :  * @ah_attr: Returned attributes that can be used when creating an address
<span class="lineNum">    1477 </span>            :  *   handle for replying to the message.
<span class="lineNum">    1478 </span>            :  */
<span class="lineNum">    1479 </span>            : int ibv_init_ah_from_wc(struct ibv_context *context, uint8_t port_num,
<span class="lineNum">    1480 </span>            :                         struct ibv_wc *wc, struct ibv_grh *grh,
<span class="lineNum">    1481 </span>            :                         struct ibv_ah_attr *ah_attr);
<span class="lineNum">    1482 </span>            : 
<span class="lineNum">    1483 </span>            : /**
<span class="lineNum">    1484 </span>            :  * ibv_create_ah_from_wc - Creates an address handle associated with the
<span class="lineNum">    1485 </span>            :  *   sender of the specified work completion.
<span class="lineNum">    1486 </span>            :  * @pd: The protection domain associated with the address handle.
<span class="lineNum">    1487 </span>            :  * @wc: Work completion information associated with a received message.
<span class="lineNum">    1488 </span>            :  * @grh: References the received global route header.  This parameter is
<span class="lineNum">    1489 </span>            :  *   ignored unless the work completion indicates that the GRH is valid.
<span class="lineNum">    1490 </span>            :  * @port_num: The outbound port number to associate with the address.
<span class="lineNum">    1491 </span>            :  *
<span class="lineNum">    1492 </span>            :  * The address handle is used to reference a local or global destination
<span class="lineNum">    1493 </span>            :  * in all UD QP post sends.
<span class="lineNum">    1494 </span>            :  */
<span class="lineNum">    1495 </span>            : struct ibv_ah *ibv_create_ah_from_wc(struct ibv_pd *pd, struct ibv_wc *wc,
<span class="lineNum">    1496 </span>            :                                      struct ibv_grh *grh, uint8_t port_num);
<span class="lineNum">    1497 </span>            : 
<span class="lineNum">    1498 </span>            : /**
<span class="lineNum">    1499 </span>            :  * ibv_destroy_ah - Destroy an address handle.
<span class="lineNum">    1500 </span>            :  */
<span class="lineNum">    1501 </span>            : int ibv_destroy_ah(struct ibv_ah *ah);
<span class="lineNum">    1502 </span>            : 
<span class="lineNum">    1503 </span>            : /**
<span class="lineNum">    1504 </span>            :  * ibv_attach_mcast - Attaches the specified QP to a multicast group.
<span class="lineNum">    1505 </span>            :  * @qp: QP to attach to the multicast group.  The QP must be a UD QP.
<span class="lineNum">    1506 </span>            :  * @gid: Multicast group GID.
<span class="lineNum">    1507 </span>            :  * @lid: Multicast group LID in host byte order.
<span class="lineNum">    1508 </span>            :  *
<span class="lineNum">    1509 </span>            :  * In order to route multicast packets correctly, subnet
<span class="lineNum">    1510 </span>            :  * administration must have created the multicast group and configured
<span class="lineNum">    1511 </span>            :  * the fabric appropriately.  The port associated with the specified
<span class="lineNum">    1512 </span>            :  * QP must also be a member of the multicast group.
<span class="lineNum">    1513 </span>            :  */
<span class="lineNum">    1514 </span>            : int ibv_attach_mcast(struct ibv_qp *qp, const union ibv_gid *gid, uint16_t lid);
<span class="lineNum">    1515 </span>            : 
<span class="lineNum">    1516 </span>            : /**
<span class="lineNum">    1517 </span>            :  * ibv_detach_mcast - Detaches the specified QP from a multicast group.
<span class="lineNum">    1518 </span>            :  * @qp: QP to detach from the multicast group.
<span class="lineNum">    1519 </span>            :  * @gid: Multicast group GID.
<span class="lineNum">    1520 </span>            :  * @lid: Multicast group LID in host byte order.
<span class="lineNum">    1521 </span>            :  */
<span class="lineNum">    1522 </span>            : int ibv_detach_mcast(struct ibv_qp *qp, const union ibv_gid *gid, uint16_t lid);
<span class="lineNum">    1523 </span>            : 
<span class="lineNum">    1524 </span>            : /**
<span class="lineNum">    1525 </span>            :  * ibv_fork_init - Prepare data structures so that fork() may be used
<span class="lineNum">    1526 </span>            :  * safely.  If this function is not called or returns a non-zero
<span class="lineNum">    1527 </span>            :  * status, then libibverbs data structures are not fork()-safe and the
<span class="lineNum">    1528 </span>            :  * effect of an application calling fork() is undefined.
<span class="lineNum">    1529 </span>            :  */
<span class="lineNum">    1530 </span>            : int ibv_fork_init(void);
<span class="lineNum">    1531 </span>            : 
<span class="lineNum">    1532 </span>            : /**
<span class="lineNum">    1533 </span>            :  * ibv_node_type_str - Return string describing node_type enum value
<span class="lineNum">    1534 </span>            :  */
<span class="lineNum">    1535 </span>            : const char *ibv_node_type_str(enum ibv_node_type node_type);
<span class="lineNum">    1536 </span>            : 
<span class="lineNum">    1537 </span>            : /**
<span class="lineNum">    1538 </span>            :  * ibv_port_state_str - Return string describing port_state enum value
<span class="lineNum">    1539 </span>            :  */
<span class="lineNum">    1540 </span>            : const char *ibv_port_state_str(enum ibv_port_state port_state);
<span class="lineNum">    1541 </span>            : 
<span class="lineNum">    1542 </span>            : /**
<span class="lineNum">    1543 </span>            :  * ibv_event_type_str - Return string describing event_type enum value
<span class="lineNum">    1544 </span>            :  */
<span class="lineNum">    1545 </span>            : const char *ibv_event_type_str(enum ibv_event_type event);
<span class="lineNum">    1546 </span>            : 
<span class="lineNum">    1547 </span>            : #define ETHERNET_LL_SIZE 6
<span class="lineNum">    1548 </span>            : int ibv_resolve_eth_l2_from_gid(struct ibv_context *context,
<span class="lineNum">    1549 </span>            :                                 struct ibv_ah_attr *attr,
<span class="lineNum">    1550 </span>            :                                 uint8_t eth_mac[ETHERNET_LL_SIZE],
<span class="lineNum">    1551 </span>            :                                 uint16_t *vid);
<span class="lineNum">    1552 </span>            : END_C_DECLS
<span class="lineNum">    1553 </span>            : 
<span class="lineNum">    1554 </span>            : #  undef __attribute_const
<span class="lineNum">    1555 </span>            : 
<span class="lineNum">    1556 </span>            : 
<span class="lineNum">    1557 </span>            : #endif /* INFINIBAND_VERBS_H */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
