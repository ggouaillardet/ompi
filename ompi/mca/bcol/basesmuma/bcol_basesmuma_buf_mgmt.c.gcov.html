<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - master-ibm-intel-check - ompi/mca/bcol/basesmuma/bcol_basesmuma_buf_mgmt.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">ompi/mca/bcol/basesmuma</a> - bcol_basesmuma_buf_mgmt.c<span style="font-size: 80%;"> (source / <a href="bcol_basesmuma_buf_mgmt.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">master-ibm-intel-check</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">154</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2015-08-03 17:10:23</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">5</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */</a>
<span class="lineNum">       2 </span>            : /*
<span class="lineNum">       3 </span>            :  * Copyright (c) 2009-2013 Oak Ridge National Laboratory.  All rights reserved.
<span class="lineNum">       4 </span>            :  * Copyright (c) 2009-2012 Mellanox Technologies.  All rights reserved.
<span class="lineNum">       5 </span>            :  * Copyright (c) 2013-2014 Los Alamos National Security, LLC.
<span class="lineNum">       6 </span>            :  *                         All rights reserved.
<span class="lineNum">       7 </span>            :  * Copyright (c) 2014      Cisco Systems, Inc.  All rights reserved.
<span class="lineNum">       8 </span>            :  * Copyright (c) 2014-2015 Research Organization for Information Science
<span class="lineNum">       9 </span>            :  *                         and Technology (RIST). All rights reserved.
<span class="lineNum">      10 </span>            :  * $COPYRIGHT$
<span class="lineNum">      11 </span>            :  *
<span class="lineNum">      12 </span>            :  * Additional copyrights may follow
<span class="lineNum">      13 </span>            :  *
<span class="lineNum">      14 </span>            :  * $HEADER$
<span class="lineNum">      15 </span>            :  */
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : /**
<span class="lineNum">      18 </span>            :  * @file
<span class="lineNum">      19 </span>            :  *
<span class="lineNum">      20 </span>            :  */
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : #include &quot;ompi_config.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;ompi/constants.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;ompi/mca/bcol/bcol.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;ompi/mca/bcol/base/base.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;ompi/patterns/comm/coll_ops.h&quot;
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : #include &quot;opal/dss/dss.h&quot;
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : #include &quot;bcol_basesmuma.h&quot;
<span class="lineNum">      31 </span>            : /*
<span class="lineNum">      32 </span>            :  * With support for nonblocking collectives, we don't have an upper
<span class="lineNum">      33 </span>            :  * limit on the number of outstanding collectives per communicator.
<span class="lineNum">      34 </span>            :  * Also, since we want to avoid communication to figure out which
<span class="lineNum">      35 </span>            :  * buffers other ranks in the group will use, we will rely on the
<span class="lineNum">      36 </span>            :  * fact that collective operations are called in the same order
<span class="lineNum">      37 </span>            :  * in each process, to assign a unique ID to each collective operation.
<span class="lineNum">      38 </span>            :  * We use this to create a static mapping from the index to the buffer
<span class="lineNum">      39 </span>            :  * that will be used.  Also, because there is no limit to the number of
<span class="lineNum">      40 </span>            :  * outstanding collective operations, we use a generation index for each
<span class="lineNum">      41 </span>            :  * memory bank, so the collective will use the buffer only when the
<a name="42"><span class="lineNum">      42 </span>            :  * correct generation of the bank is ready for use.</a>
<span class="lineNum">      43 </span>            :  */
<span class="lineNum">      44 </span><span class="lineNoCov">          0 : int bcol_basesmuma_get_buff_index( sm_buffer_mgmt *buff_block,</span>
<span class="lineNum">      45 </span>            :                                    uint64_t buff_id )
<span class="lineNum">      46 </span>            : {
<span class="lineNum">      47 </span>            :     /* local variables */
<span class="lineNum">      48 </span>            :     int memory_bank;
<span class="lineNum">      49 </span>            :     uint64_t generation;
<span class="lineNum">      50 </span><span class="lineNoCov">          0 :     int index=-1;</span>
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span>            :     /* get the bank index that will be used */
<span class="lineNum">      54 </span><span class="lineNoCov">          0 :     memory_bank=buff_id&amp; buff_block-&gt;mask;</span>
<span class="lineNum">      55 </span><span class="lineNoCov">          0 :     memory_bank = memory_bank SHIFT_DOWN buff_block-&gt;log2_num_buffs_per_mem_bank;</span>
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            :     /* get the generation of the bank this maps to */
<span class="lineNum">      58 </span><span class="lineNoCov">          0 :     generation = buff_id SHIFT_DOWN (buff_block-&gt;log2_number_of_buffs);</span>
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            :     /* check to see if the bank is available */
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :     if( generation == buff_block-&gt;ctl_buffs_mgmt[memory_bank].</span>
<span class="lineNum">      62 </span>            :         bank_gen_counter ) {
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span>            :         /* get the buffer index that will be returned */
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :         index=buff_id &amp; buff_block-&gt;mask;</span>
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            :         /* no in-use counter increment, as the mapping is static, and
<span class="lineNum">      68 </span>            :          * all we need to know if the number of collectives that complete */
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span>            :     } else {
<span class="lineNum">      71 </span>            :         /* progress communications so that resources can be freed up */
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :         opal_progress();</span>
<span class="lineNum">      73 </span>            :     }
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span>            :     /* return */
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :     return index;</span>
<span class="lineNum">      77 </span>            : }
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            : /* release the shared memory buffers
<a name="80"><span class="lineNum">      80 </span>            :  *  buf_id is the unique ID assigned to the particular buffer</a>
<span class="lineNum">      81 </span>            :  */
<span class="lineNum">      82 </span><span class="lineNoCov">          0 : int bcol_basesmuma_free_buff( sm_buffer_mgmt * buff_block,</span>
<span class="lineNum">      83 </span>            :                               uint64_t buff_id )
<span class="lineNum">      84 </span>            : {
<span class="lineNum">      85 </span>            :     /* local variables */
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :     int ret=OMPI_SUCCESS;</span>
<span class="lineNum">      87 </span>            :     int memory_bank;
<span class="lineNum">      88 </span>            :     uint64_t generation;
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :     mca_bcol_basesmuma_component_t *cs = &amp;mca_bcol_basesmuma_component;</span>
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span>            :     /* get the bank index that will be used */
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :     memory_bank=buff_id&amp; buff_block-&gt;mask;</span>
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :     memory_bank = memory_bank SHIFT_DOWN buff_block-&gt;log2_num_buffs_per_mem_bank;</span>
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span>            :     /* get the generation of the bank this maps to */
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :     generation = buff_id SHIFT_DOWN (buff_block-&gt;log2_number_of_buffs);</span>
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            :     /* the generation counter should not change until all resrouces
<span class="lineNum">      99 </span>            :      *   associated with this bank have been freed.
<span class="lineNum">     100 </span>            :      */
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :     assert(generation == buff_block-&gt;ctl_buffs_mgmt[memory_bank].bank_gen_counter);</span>
<span class="lineNum">     102 </span>            : 
<span class="lineNum">     103 </span>            :     /*
<span class="lineNum">     104 </span>            :      * increment counter of completed buffers
<span class="lineNum">     105 </span>            :      */
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :     OPAL_THREAD_ADD32(&amp;(buff_block-&gt;ctl_buffs_mgmt[memory_bank].n_buffs_freed),</span>
<span class="lineNum">     107 </span>            :                       1);
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span>            :     /*
<span class="lineNum">     110 </span>            :      * If I am the last to checkin - initiate resource recycling
<span class="lineNum">     111 </span>            :      */
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :     if( buff_block-&gt;ctl_buffs_mgmt[memory_bank].n_buffs_freed ==</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :         buff_block-&gt;ctl_buffs_mgmt[memory_bank].number_of_buffers ) {</span>
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span>            :         /* Lock to ensure atomic recycling of resources */
<span class="lineNum">     116 </span>            :         OPAL_THREAD_LOCK(&amp;(buff_block-&gt;ctl_buffs_mgmt[memory_bank].mutex));
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span>            :         /* make sure someone else did not already get to this */
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :         if( buff_block-&gt;ctl_buffs_mgmt[memory_bank].n_buffs_freed !=</span>
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :             buff_block-&gt;ctl_buffs_mgmt[memory_bank].number_of_buffers ) {</span>
<span class="lineNum">     121 </span>            :             /* release lock and exit */
<span class="lineNum">     122 </span>            :             OPAL_THREAD_UNLOCK(&amp;(buff_block-&gt;ctl_buffs_mgmt[memory_bank].mutex));
<span class="lineNum">     123 </span>            :         } else {
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :             sm_nbbar_desc_t *p_sm_nb_desc = NULL;</span>
<span class="lineNum">     125 </span>            :             /* initiate the freeing of resources.  Need to make sure the other
<span class="lineNum">     126 </span>            :              * ranks in the group are also done with their resources before this
<span class="lineNum">     127 </span>            :              * block is made available for use again.
<span class="lineNum">     128 </span>            :              * No one else will try to allocate from this block or free back to
<span class="lineNum">     129 </span>            :              * this block until the next genration counter has been incremented,
<span class="lineNum">     130 </span>            :              * so will just reset the number of freed buffers to 0, so no one else
<span class="lineNum">     131 </span>            :              * will try to also initialize the recycling of these resrouces
<span class="lineNum">     132 </span>            :              */
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :             buff_block-&gt;ctl_buffs_mgmt[memory_bank].n_buffs_freed=0;</span>
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span>            :             /* Start the nonblocking barrier */
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :             p_sm_nb_desc = &amp;(buff_block-&gt;ctl_buffs_mgmt[memory_bank].nb_barrier_desc);</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :             p_sm_nb_desc-&gt;coll_buff = buff_block;</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :             bcol_basesmuma_rd_nb_barrier_init_admin(p_sm_nb_desc);</span>
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :             if( NB_BARRIER_DONE !=</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :                 buff_block-&gt;ctl_buffs_mgmt[memory_bank].</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :                 nb_barrier_desc.collective_phase) {</span>
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :                 opal_list_t *list=&amp;(cs-&gt;nb_admin_barriers);</span>
<span class="lineNum">     145 </span>            :                 opal_list_item_t *append_item;
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span>            :                 /* put this onto the progression list */
<span class="lineNum">     148 </span>            :                 OPAL_THREAD_LOCK(&amp;(cs-&gt;nb_admin_barriers_mutex));
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :                 append_item=(opal_list_item_t *)</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :                     &amp;(buff_block-&gt;ctl_buffs_mgmt[memory_bank].nb_barrier_desc);</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :                 opal_list_append(list,append_item);</span>
<span class="lineNum">     152 </span>            :                 OPAL_THREAD_UNLOCK(&amp;(cs-&gt;nb_admin_barriers_mutex));
<span class="lineNum">     153 </span>            :                 /* progress communications so that resources can be freed up */
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :                 opal_progress();</span>
<span class="lineNum">     155 </span>            :             } else {
<span class="lineNum">     156 </span>            :                 /* mark the block as available */
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :                 (buff_block-&gt;ctl_buffs_mgmt[memory_bank].bank_gen_counter)++;</span>
<span class="lineNum">     158 </span>            :             }
<span class="lineNum">     159 </span>            : 
<span class="lineNum">     160 </span>            :             /* get out of here */
<span class="lineNum">     161 </span>            :             OPAL_THREAD_UNLOCK(&amp;(buff_block-&gt;ctl_buffs_mgmt[memory_bank].mutex));
<span class="lineNum">     162 </span>            :         }
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            :     }
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span>            :     /* return */
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :     return ret;</span>
<span class="lineNum">     168 </span>            : }
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span>            : /*
<span class="lineNum">     171 </span>            :  * Allocate buffers for storing non-blocking collective descriptions, required
<span class="lineNum">     172 </span>            :  * for making code re-entrant
<a name="173"><span class="lineNum">     173 </span>            :  *</a>
<span class="lineNum">     174 </span>            :  */
<span class="lineNum">     175 </span><span class="lineNoCov">          0 : static int init_nb_coll_buff_desc(mca_bcol_basesmuma_nb_coll_buff_desc_t **desc,</span>
<span class="lineNum">     176 </span>            :                                   void *base_addr, uint32_t num_banks,
<span class="lineNum">     177 </span>            :                                   uint32_t num_buffers_per_bank,
<span class="lineNum">     178 </span>            :                                   uint32_t size_buffer,
<span class="lineNum">     179 </span>            :                                   uint32_t header_size,
<span class="lineNum">     180 </span>            :                                   int group_size,
<span class="lineNum">     181 </span>            :                                   int pow_k)
<span class="lineNum">     182 </span>            : {
<span class="lineNum">     183 </span>            :     uint32_t i, j, ci;
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :     mca_bcol_basesmuma_nb_coll_buff_desc_t *tmp_desc = NULL;</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :     int k_nomial_radix = mca_bcol_basesmuma_component.k_nomial_radix;</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :     int pow_k_val = (0 == pow_k) ? 1 : pow_k;</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :     int num_to_alloc = (k_nomial_radix - 1) * pow_k_val * 2 + 1 ;</span>
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :     *desc = (mca_bcol_basesmuma_nb_coll_buff_desc_t *)calloc(num_banks * num_buffers_per_bank, sizeof(mca_bcol_basesmuma_nb_coll_buff_desc_t));</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :     if (NULL == *desc) {</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :         return OMPI_ERROR;</span>
<span class="lineNum">     193 </span>            :     }
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :     tmp_desc = *desc;</span>
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; num_banks; i++) {</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :         for (j = 0; j &lt; num_buffers_per_bank; j++) {</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :             ci = i * num_buffers_per_bank + j;</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :             tmp_desc[ci].bank_index = i;</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :             tmp_desc[ci].buffer_index = j;</span>
<span class="lineNum">     202 </span>            :             /* *2  is for gather session  +1 for extra peer */
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :             tmp_desc[ci].requests = (ompi_request_t **)</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :                 calloc(num_to_alloc, sizeof(ompi_request_t *));</span>
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :             tmp_desc[ci].data_addr = (void *)</span>
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :                 ((unsigned char*)base_addr + ci * size_buffer + header_size);</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :             BASESMUMA_VERBOSE(10, (&quot;ml memory cache setup %d %d - %p&quot;, i, j, tmp_desc[ci].data_addr));</span>
<span class="lineNum">     208 </span>            :         }
<span class="lineNum">     209 </span>            :     }
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :     return OMPI_SUCCESS;</span>
<span class="lineNum">     212 </span>            : }
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span>            : /*
<span class="lineNum">     216 </span>            :  * Free buffers for storing non-blocking collective descriptions.
<a name="217"><span class="lineNum">     217 </span>            :  *</a>
<span class="lineNum">     218 </span>            :  */
<span class="lineNum">     219 </span><span class="lineNoCov">          0 : void cleanup_nb_coll_buff_desc(mca_bcol_basesmuma_nb_coll_buff_desc_t **desc,</span>
<span class="lineNum">     220 </span>            :                                   uint32_t num_banks,
<span class="lineNum">     221 </span>            :                                   uint32_t num_buffers_per_bank)
<span class="lineNum">     222 </span>            : {
<span class="lineNum">     223 </span>            :     uint32_t ci;
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :     if (NULL != *desc) {</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :         for (ci=0; ci&lt;num_banks*num_buffers_per_bank; ci++) {</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :             if (NULL != ((*desc)[ci]).requests) {</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :                 free(((*desc)[ci]).requests);</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :                 ((*desc))[ci].requests = NULL;</span>
<span class="lineNum">     229 </span>            :             }
<span class="lineNum">     230 </span>            :         }
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :         free(*desc);</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :         *desc = NULL;</span>
<span class="lineNum">     233 </span>            :     }
<span class="lineNum">     234 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span>            : #if 1
<span class="lineNum">     238 </span>            : /* New init function used for new control scheme where we put the control
<a name="239"><span class="lineNum">     239 </span>            :  * struct at the top of the payload buffer</a>
<span class="lineNum">     240 </span>            :  */
<span class="lineNum">     241 </span><span class="lineNoCov">          0 : int bcol_basesmuma_bank_init_opti(struct mca_bcol_base_memory_block_desc_t *payload_block,</span>
<span class="lineNum">     242 </span>            :         uint32_t data_offset,
<span class="lineNum">     243 </span>            :         mca_bcol_base_module_t *bcol_module,
<span class="lineNum">     244 </span>            :         void *reg_data)
<span class="lineNum">     245 </span>            : {
<span class="lineNum">     246 </span>            :     /* assumption here is that the block has been registered with
<span class="lineNum">     247 </span>            :      * sm bcol hence has been mapped by each process, need to be
<span class="lineNum">     248 </span>            :      * sure that memory is mapped amongst sm peers
<span class="lineNum">     249 </span>            :      */
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span>            :     /* local variables */
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :     int ret = OMPI_SUCCESS, i, j;</span>
<span class="lineNum">     253 </span>            :     sm_buffer_mgmt *pload_mgmt;
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :     mca_bcol_basesmuma_component_t *cs = &amp;mca_bcol_basesmuma_component;</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :     bcol_basesmuma_registration_data_t *sm_reg_data =</span>
<span class="lineNum">     256 </span>            :         (bcol_basesmuma_registration_data_t *) reg_data;
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :     mca_bcol_basesmuma_module_t *sm_bcol =</span>
<span class="lineNum">     258 </span>            :         (mca_bcol_basesmuma_module_t *) bcol_module;
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :     mca_bcol_base_memory_block_desc_t *ml_block = payload_block;</span>
<span class="lineNum">     260 </span>            :     size_t malloc_size;
<span class="lineNum">     261 </span>            :     bcol_basesmuma_smcm_file_t input_file;
<span class="lineNum">     262 </span>            :     int leading_dim,loop_limit,buf_id;
<span class="lineNum">     263 </span>            :     unsigned char *base_ptr;
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :     mca_bcol_basesmuma_module_t *sm_bcol_module=</span>
<span class="lineNum">     265 </span>            :         (mca_bcol_basesmuma_module_t *)bcol_module;
<span class="lineNum">     266 </span>            :     int my_idx, array_id;
<span class="lineNum">     267 </span>            :     mca_bcol_basesmuma_header_t *ctl_ptr;
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :     void **results_array=NULL, *mem_offset;</span>
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :     mca_bcol_basesmuma_local_mlmem_desc_t *ml_mem = &amp;sm_bcol_module-&gt;ml_mem;</span>
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span>            :     /* first, we get a pointer to the payload buffer management struct */
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :     pload_mgmt = &amp;(sm_bcol-&gt;colls_with_user_data);</span>
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            :     /* go ahead and get the header size that is cached on the payload block
<span class="lineNum">     276 </span>            :      */
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :     sm_bcol-&gt;total_header_size = data_offset;</span>
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span>            :     /* allocate memory for pointers to mine and my peers' payload buffers
<span class="lineNum">     280 </span>            :      * difference here is that now we use our new data struct
<span class="lineNum">     281 </span>            :      */
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :     malloc_size = ml_block-&gt;num_banks*ml_block-&gt;num_buffers_per_bank*</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :         pload_mgmt-&gt;size_of_group *sizeof(mca_bcol_basesmuma_payload_t);</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :     pload_mgmt-&gt;data_buffs = (mca_bcol_basesmuma_payload_t *) malloc(malloc_size);</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :     if( !pload_mgmt-&gt;data_buffs) {</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :         ret = OMPI_ERR_OUT_OF_RESOURCE;</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :         goto exit_ERROR;</span>
<span class="lineNum">     288 </span>            :     }
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span>            :     /* allocate some memory to hold the offsets */
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :     results_array = (void **) malloc(pload_mgmt-&gt;size_of_group * sizeof (void *));</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :     if (NULL == results_array) {</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :         ret = OMPI_ERR_OUT_OF_RESOURCE;</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :         goto exit_ERROR;</span>
<span class="lineNum">     295 </span>            :     }
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span>            :     /* setup the input file for the shared memory connection manager */
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :     input_file.file_name = sm_reg_data-&gt;file_name;</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :     input_file.size = sm_reg_data-&gt;size;</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :     input_file.size_ctl_structure = 0;</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :     input_file.data_seg_alignment = BASESMUMA_CACHE_LINE_SIZE;</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :     input_file.mpool_size = sm_reg_data-&gt;size;</span>
<span class="lineNum">     303 </span>            : 
<span class="lineNum">     304 </span>            :     /* call the connection manager and map my shared memory peers' file
<span class="lineNum">     305 </span>            :      */
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :     ret = bcol_basesmuma_smcm_allgather_connection(</span>
<span class="lineNum">     307 </span>            :         sm_bcol,
<span class="lineNum">     308 </span>            :         sm_bcol-&gt;super.sbgp_partner_module,
<span class="lineNum">     309 </span>            :         &amp;(cs-&gt;sm_connections_list),
<span class="lineNum">     310 </span>            :         &amp;(sm_bcol-&gt;payload_backing_files_info),
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :         sm_bcol-&gt;super.sbgp_partner_module-&gt;group_comm,</span>
<span class="lineNum">     312 </span>            :         input_file, cs-&gt;payload_base_fname,
<span class="lineNum">     313 </span>            :         false);
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :     if( OMPI_SUCCESS != ret ) {</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :         goto exit_ERROR;</span>
<span class="lineNum">     316 </span>            :     }
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            :     /* now we exchange offset info - don't assume symmetric virtual memory
<span class="lineNum">     320 </span>            :      */
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :     mem_offset = (void *) ((uintptr_t) ml_block-&gt;block-&gt;base_addr -</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :                            (uintptr_t) cs-&gt;sm_payload_structs-&gt;data_addr);</span>
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span>            :     /* call into the exchange offsets function */
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :     ret=comm_allgather_pml(&amp;mem_offset, results_array, sizeof (void *), MPI_BYTE,</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :                            sm_bcol_module-&gt;super.sbgp_partner_module-&gt;my_index,</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :                            sm_bcol_module-&gt;super.sbgp_partner_module-&gt;group_size,</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :                            sm_bcol_module-&gt;super.sbgp_partner_module-&gt;group_list,</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :                            sm_bcol_module-&gt;super.sbgp_partner_module-&gt;group_comm);</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :     if( OMPI_SUCCESS != ret ) {</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :         goto exit_ERROR;</span>
<span class="lineNum">     333 </span>            :     }
<span class="lineNum">     334 </span>            : 
<span class="lineNum">     335 </span>            :     /* convert memory offset to virtual address in current rank */
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :     leading_dim = pload_mgmt-&gt;size_of_group;</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :     loop_limit =  ml_block-&gt;num_banks*ml_block-&gt;num_buffers_per_bank;</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :     for (i=0;i&lt; sm_bcol_module-&gt;super.sbgp_partner_module-&gt;group_size;i++) {</span>
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span>            :         /* get the base pointer */
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :         int array_id=SM_ARRAY_INDEX(leading_dim,0,i);</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :         if( i == sm_bcol_module-&gt;super.sbgp_partner_module-&gt;my_index) {</span>
<span class="lineNum">     343 </span>            :             /* me */
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :             base_ptr=cs-&gt;sm_payload_structs-&gt;map_addr;</span>
<span class="lineNum">     345 </span>            :         } else {
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :             base_ptr=sm_bcol_module-&gt;payload_backing_files_info[i]-&gt;</span>
<span class="lineNum">     347 </span>            :                 sm_mmap-&gt;map_addr;
<span class="lineNum">     348 </span>            :         }
<span class="lineNum">     349 </span>            : 
<span class="lineNum">     350 </span>            :         /* first, set the pointer to the control struct */
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :         pload_mgmt-&gt;data_buffs[array_id].ctl_struct=(mca_bcol_basesmuma_header_t *)</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :             (uintptr_t)(((uint64_t)(uintptr_t)results_array[array_id])+(uint64_t)(uintptr_t)base_ptr);</span>
<span class="lineNum">     353 </span>            :         /* second, calculate where to set the data pointer */
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :         pload_mgmt-&gt;data_buffs[array_id].payload=(void *)</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :             (uintptr_t)((uint64_t)(uintptr_t) pload_mgmt-&gt;data_buffs[array_id].ctl_struct +</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :                         (uint64_t)(uintptr_t) data_offset);</span>
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :         for( buf_id = 1 ; buf_id &lt; loop_limit ; buf_id++ ) {</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :             int array_id_m1=SM_ARRAY_INDEX(leading_dim,(buf_id-1),i);</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :             array_id=SM_ARRAY_INDEX(leading_dim,buf_id,i);</span>
<span class="lineNum">     361 </span>            :             /* now, play the same game as above
<span class="lineNum">     362 </span>            :              *
<span class="lineNum">     363 </span>            :              * first, set the control struct's position */
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :             pload_mgmt-&gt;data_buffs[array_id].ctl_struct=(mca_bcol_basesmuma_header_t *)</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :                 (uintptr_t)(((uint64_t)(uintptr_t)(pload_mgmt-&gt;data_buffs[array_id_m1].ctl_struct) +</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :                              (uint64_t)(uintptr_t)ml_block-&gt;size_buffer));</span>
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span>            :             /* second, set the payload pointer */
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :             pload_mgmt-&gt;data_buffs[array_id].payload =(void *)</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :                 (uintptr_t)((uint64_t)(uintptr_t) pload_mgmt-&gt;data_buffs[array_id].ctl_struct +</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :                             (uint64_t)(uintptr_t) data_offset);</span>
<span class="lineNum">     372 </span>            :         }
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span>            :     }
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span>            :     /* done with the index array */
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :     free (results_array);</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :     results_array = NULL;</span>
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span>            :     /* initialize my control structures!! */
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :     my_idx = sm_bcol_module-&gt;super.sbgp_partner_module-&gt;my_index;</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :     leading_dim = sm_bcol_module-&gt;super.sbgp_partner_module-&gt;group_size;</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :     for( buf_id = 0; buf_id &lt; loop_limit; buf_id++){</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :         array_id = SM_ARRAY_INDEX(leading_dim,buf_id,my_idx);</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :         ctl_ptr = pload_mgmt-&gt;data_buffs[array_id].ctl_struct;</span>
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span>            :         /* initialize the data structures */
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :         for( j = 0; j &lt; SM_BCOLS_MAX; j++){</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :             for( i = 0; i &lt; NUM_SIGNAL_FLAGS; i++){</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :                 ctl_ptr-&gt;flags[i][j] = -1;</span>
<span class="lineNum">     391 </span>            :             }
<span class="lineNum">     392 </span>            :         }
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :         ctl_ptr-&gt;sequence_number = -1;</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :         ctl_ptr-&gt;src = -1;</span>
<span class="lineNum">     395 </span>            :     }
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span>            :     /* setup the data structures needed for releasing the payload
<span class="lineNum">     401 </span>            :      * buffers back to the ml level
<span class="lineNum">     402 </span>            :      */
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :     for( i=0 ; i &lt; (int) ml_block-&gt;num_banks ; i++ ) {</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :         sm_bcol-&gt;colls_with_user_data.</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :             ctl_buffs_mgmt[i].nb_barrier_desc.ml_memory_block_descriptor=</span>
<span class="lineNum">     406 </span>            :             ml_block;
<span class="lineNum">     407 </span>            :     }
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :     ml_mem-&gt;num_banks = ml_block-&gt;num_banks;</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :     ml_mem-&gt;bank_release_counter = calloc(ml_block-&gt;num_banks, sizeof(uint32_t));</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :     ml_mem-&gt;num_buffers_per_bank = ml_block-&gt;num_buffers_per_bank;</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :     ml_mem-&gt;size_buffer = ml_block-&gt;size_buffer;</span>
<span class="lineNum">     413 </span>            :     /* pointer to ml level descriptor */
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :     ml_mem-&gt;ml_mem_desc = ml_block;</span>
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :     if (OMPI_SUCCESS != init_nb_coll_buff_desc(&amp;ml_mem-&gt;nb_coll_desc,</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :                                                ml_block-&gt;block-&gt;base_addr,</span>
<span class="lineNum">     418 </span>            :                                                ml_mem-&gt;num_banks,
<span class="lineNum">     419 </span>            :                                                ml_mem-&gt;num_buffers_per_bank,
<span class="lineNum">     420 </span>            :                                                ml_mem-&gt;size_buffer,
<span class="lineNum">     421 </span>            :                                                data_offset,
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :                                                sm_bcol_module-&gt;super.sbgp_partner_module-&gt;group_size,</span>
<span class="lineNum">     423 </span>            :                                                sm_bcol_module-&gt;pow_k)) {
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :         BASESMUMA_VERBOSE(10, (&quot;Failed to allocate memory descriptors for storing state of non-blocking collectives\n&quot;));</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :         return OMPI_ERROR;</span>
<span class="lineNum">     427 </span>            :     }
<span class="lineNum">     428 </span>            : 
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :     return OMPI_SUCCESS;</span>
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span>            : exit_ERROR:
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :     if (NULL != results_array) {</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :         free(results_array);</span>
<span class="lineNum">     434 </span>            :     }
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :     return ret;</span>
<span class="lineNum">     436 </span>            : }
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span>            : #endif
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span>            : 
<span class="lineNum">     442 </span>            : /* Basesmuma interface function used for buffer release */
<span class="lineNum">     443 </span>            : #if 0
<span class="lineNum">     444 </span>            : /* gvm
<span class="lineNum">     445 </span>            :  * A collective operation calls this routine to release the payload buffer.
<span class="lineNum">     446 </span>            :  * All processes in the shared memory sub-group of a bcol should call the non-blocking
<span class="lineNum">     447 </span>            :  * barrier on the last payload buffer of a memory bank. On the completion
<span class="lineNum">     448 </span>            :  * of the non-blocking barrier, the ML callback is called which is responsible
<span class="lineNum">     449 </span>            :  * for recycling the memory bank.
<span class="lineNum">     450 </span>            :  */
<span class="lineNum">     451 </span>            : mca_bcol_basesmuma_module_t *sm_bcol_module
<span class="lineNum">     452 </span>            : int bcol_basesmuma_free_payload_buff(
<span class="lineNum">     453 </span>            :     struct mca_bcol_base_memory_block_desc_t *block,
<span class="lineNum">     454 </span>            :     sm_buffer_mgmt *ctl_mgmt,
<span class="lineNum">     455 </span>            :     uint64_t buff_id)
<span class="lineNum">     456 </span>            : {
<span class="lineNum">     457 </span>            :     /* local variables */
<span class="lineNum">     458 </span>            :     int ret = OMPI_SUCCESS;
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span>            :     memory_bank = BANK_FROM_BUFFER_IDX(buff_id);
<span class="lineNum">     461 </span>            :     ctl_mgmt-&gt;ctl_buffs_mgmt[memory_bank].n_buffs_freed++;
<span class="lineNum">     462 </span>            : 
<span class="lineNum">     463 </span>            :     OPAL_THREAD_ADD32(&amp;(ctl_mgmt-&gt;ctl_buffs_mgmt[memory_bank].n_buffs_freed),1);
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span>            :     if (ctl_mgmt-&gt;ctl_buffs_mgmt[memory_bank].n_buffs_freed == block-&gt;size_buffers_bank){
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span>            :         /* start non-blocking barrier */
<span class="lineNum">     468 </span>            :         bcol_basesmuma_rd_nb_barrier_init_admin(
<span class="lineNum">     469 </span>            :             &amp;(ctl_mgmt-&gt;ctl_buffs_mgmt[memory_bank].nb_barrier_desc));
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span>            :         if (NB_BARRIER_DONE !=
<span class="lineNum">     472 </span>            :             ctl_mgmt-&gt;ctl_buffs_mgmt[memory_bank].
<span class="lineNum">     473 </span>            :             nb_barrier_desc.collective_phase){
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span>            :             /* progress the barrier */
<span class="lineNum">     476 </span>            :             opal_progress();
<span class="lineNum">     477 </span>            :         }
<span class="lineNum">     478 </span>            :         else{
<span class="lineNum">     479 </span>            :             /* free the buffer - i.e. initiate callback to ml level */
<span class="lineNum">     480 </span>            :             block-&gt;ml_release_cb(block,memory_bank);
<span class="lineNum">     481 </span>            :         }
<span class="lineNum">     482 </span>            :     }
<span class="lineNum">     483 </span>            :     return ret;
<span class="lineNum">     484 </span>            : }
<span class="lineNum">     485 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
