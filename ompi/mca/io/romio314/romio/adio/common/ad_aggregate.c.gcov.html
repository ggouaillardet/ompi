<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - master-ibm-intel-check - ompi/mca/io/romio314/romio/adio/common/ad_aggregate.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../../index.html">top level</a> - <a href="index.html">ompi/mca/io/romio314/romio/adio/common</a> - ad_aggregate.c<span style="font-size: 80%;"> (source / <a href="ad_aggregate.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">master-ibm-intel-check</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">122</td>
            <td class="headerCovTableEntry">170</td>
            <td class="headerCovTableEntryLo">71.8 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2015-08-03 17:10:23</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">4</td>
            <td class="headerCovTableEntry">4</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr><td><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil ; -*- */</a>
<span class="lineNum">       2 </span>            : /*
<span class="lineNum">       3 </span>            :  *   Copyright (C) 1997-2001 University of Chicago.
<span class="lineNum">       4 </span>            :  *   See COPYRIGHT notice in top-level directory.
<span class="lineNum">       5 </span>            :  */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #include &quot;adio.h&quot;
<span class="lineNum">       8 </span>            : #include &quot;adio_extern.h&quot;
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : #ifdef AGGREGATION_PROFILE
<span class="lineNum">      11 </span>            : #include &quot;mpe.h&quot;
<span class="lineNum">      12 </span>            : #endif
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            : #undef AGG_DEBUG
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : /* This file contains four functions:
<span class="lineNum">      17 </span>            :  *
<span class="lineNum">      18 </span>            :  * ADIOI_Calc_aggregator()
<span class="lineNum">      19 </span>            :  * ADIOI_Calc_file_domains()
<span class="lineNum">      20 </span>            :  * ADIOI_Calc_my_req()
<span class="lineNum">      21 </span>            :  * ADIOI_Calc_others_req()
<span class="lineNum">      22 </span>            :  *
<span class="lineNum">      23 </span>            :  * The last three of these were originally in ad_read_coll.c, but they are
<span class="lineNum">      24 </span>            :  * also shared with ad_write_coll.c.  I felt that they were better kept with
<span class="lineNum">      25 </span>            :  * the rest of the shared aggregation code.
<span class="lineNum">      26 </span>            :  */
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : /* Discussion of values available from above:
<span class="lineNum">      29 </span>            :  *
<span class="lineNum">      30 </span>            :  * ADIO_Offset st_offsets[0..nprocs-1]
<span class="lineNum">      31 </span>            :  * ADIO_Offset end_offsets[0..nprocs-1]
<span class="lineNum">      32 </span>            :  *    These contain a list of start and end offsets for each process in
<span class="lineNum">      33 </span>            :  *    the communicator.  For example, an access at loc 10, size 10 would
<span class="lineNum">      34 </span>            :  *    have a start offset of 10 and end offset of 19.
<span class="lineNum">      35 </span>            :  * int nprocs
<span class="lineNum">      36 </span>            :  *    number of processors in the collective I/O communicator
<span class="lineNum">      37 </span>            :  * ADIO_Offset min_st_offset
<span class="lineNum">      38 </span>            :  * ADIO_Offset fd_start[0..nprocs_for_coll-1]
<span class="lineNum">      39 </span>            :  *    starting location of &quot;file domain&quot;; region that a given process will
<span class="lineNum">      40 </span>            :  *    perform aggregation for (i.e. actually do I/O)
<span class="lineNum">      41 </span>            :  * ADIO_Offset fd_end[0..nprocs_for_coll-1]
<span class="lineNum">      42 </span>            :  *    start + size - 1 roughly, but it can be less, or 0, in the case of
<span class="lineNum">      43 </span>            :  *    uneven distributions
<span class="lineNum">      44 </span>            :  */
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span>            : /* ADIOI_Calc_aggregator()
<span class="lineNum">      47 </span>            :  *
<span class="lineNum">      48 </span>            :  * The intention here is to implement a function which provides basically
<span class="lineNum">      49 </span>            :  * the same functionality as in Rajeev's original version of
<span class="lineNum">      50 </span>            :  * ADIOI_Calc_my_req().  He used a ceiling division approach to assign the
<span class="lineNum">      51 </span>            :  * file domains, and we use the same approach here when calculating the
<span class="lineNum">      52 </span>            :  * location of an offset/len in a specific file domain.  Further we assume
<span class="lineNum">      53 </span>            :  * this same distribution when calculating the rank_index, which is later
<span class="lineNum">      54 </span>            :  *  used to map to a specific process rank in charge of the file domain.
<span class="lineNum">      55 </span>            :  *
<span class="lineNum">      56 </span>            :  * A better (i.e. more general) approach would be to use the list of file
<span class="lineNum">      57 </span>            :  * domains only.  This would be slower in the case where the
<span class="lineNum">      58 </span>            :  * original ceiling division was used, but it would allow for arbitrary
<span class="lineNum">      59 </span>            :  * distributions of regions to aggregators.  We'd need to know the
<span class="lineNum">      60 </span>            :  * nprocs_for_coll in that case though, which we don't have now.
<span class="lineNum">      61 </span>            :  *
<span class="lineNum">      62 </span>            :  * Note a significant difference between this function and Rajeev's old code:
<span class="lineNum">      63 </span>            :  * this code doesn't necessarily return a rank in the range
<span class="lineNum">      64 </span>            :  * 0..nprocs_for_coll; instead you get something in 0..nprocs.  This is a
<span class="lineNum">      65 </span>            :  * result of the rank mapping; any set of ranks in the communicator could be
<span class="lineNum">      66 </span>            :  * used now.
<span class="lineNum">      67 </span>            :  *
<span class="lineNum">      68 </span>            :  * Returns an integer representing a rank in the collective I/O communicator.
<span class="lineNum">      69 </span>            :  *
<span class="lineNum">      70 </span>            :  * The &quot;len&quot; parameter is also modified to indicate the amount of data
<a name="71"><span class="lineNum">      71 </span>            :  * actually available in this file domain.</a>
<span class="lineNum">      72 </span>            :  */
<span class="lineNum">      73 </span><span class="lineCov">     576000 : int ADIOI_Calc_aggregator(ADIO_File fd,</span>
<span class="lineNum">      74 </span>            :                          ADIO_Offset off,
<span class="lineNum">      75 </span>            :                          ADIO_Offset min_off,
<span class="lineNum">      76 </span>            :                          ADIO_Offset *len,
<span class="lineNum">      77 </span>            :                          ADIO_Offset fd_size,
<span class="lineNum">      78 </span>            :                          ADIO_Offset *fd_start,
<span class="lineNum">      79 </span>            :                          ADIO_Offset *fd_end)
<span class="lineNum">      80 </span>            : {
<span class="lineNum">      81 </span>            :     int rank_index, rank;
<span class="lineNum">      82 </span>            :     ADIO_Offset avail_bytes;
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span>            :     ADIOI_UNREFERENCED_ARG(fd_start);
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span>            :     /* get an index into our array of aggregators */
<span class="lineNum">      87 </span><span class="lineCov">     576000 :     rank_index = (int) ((off - min_off + fd_size)/ fd_size - 1);</span>
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span><span class="lineCov">     576000 :     if (fd-&gt;hints-&gt;striping_unit &gt; 0) {</span>
<span class="lineNum">      90 </span>            :         /* wkliao: implementation for file domain alignment
<span class="lineNum">      91 </span>            :            fd_start[] and fd_end[] have been aligned with file lock
<span class="lineNum">      92 </span>            :            boundaries when returned from ADIOI_Calc_file_domains() so cannot
<span class="lineNum">      93 </span>            :            just use simple arithmatic as above */
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :         rank_index = 0;</span>
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :         while (off &gt; fd_end[rank_index]) rank_index++;</span>
<span class="lineNum">      96 </span>            :     }
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            :     /* we index into fd_end with rank_index, and fd_end was allocated to be no
<span class="lineNum">      99 </span>            :      * bigger than fd-&gt;hins-&gt;cb_nodes.   If we ever violate that, we're
<span class="lineNum">     100 </span>            :      * overrunning arrays.  Obviously, we should never ever hit this abort */
<span class="lineNum">     101 </span><span class="lineCov">     576000 :     if (rank_index &gt;= fd-&gt;hints-&gt;cb_nodes || rank_index &lt; 0) {</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :         FPRINTF(stderr, &quot;Error in ADIOI_Calc_aggregator(): rank_index(%d) &gt;= fd-&gt;hints-&gt;cb_nodes (%d) fd_size=%lld off=%lld\n&quot;,</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :                         rank_index,fd-&gt;hints-&gt;cb_nodes,fd_size,off);</span>
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :         MPI_Abort(MPI_COMM_WORLD, 1);</span>
<span class="lineNum">     105 </span>            :     }
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span>            :     /* remember here that even in Rajeev's original code it was the case that
<span class="lineNum">     108 </span>            :      * different aggregators could end up with different amounts of data to
<span class="lineNum">     109 </span>            :      * aggregate.  here we use fd_end[] to make sure that we know how much
<span class="lineNum">     110 </span>            :      * data this aggregator is working with.
<span class="lineNum">     111 </span>            :      *
<span class="lineNum">     112 </span>            :      * the +1 is to take into account the end vs. length issue.
<span class="lineNum">     113 </span>            :      */
<span class="lineNum">     114 </span><span class="lineCov">     576000 :     avail_bytes = fd_end[rank_index] + 1 - off;</span>
<span class="lineNum">     115 </span><span class="lineCov">     576000 :     if (avail_bytes &lt; *len) {</span>
<span class="lineNum">     116 </span>            :         /* this file domain only has part of the requested contig. region */
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :         *len = avail_bytes;</span>
<span class="lineNum">     118 </span>            :     }
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span>            :     /* map our index to a rank */
<span class="lineNum">     121 </span>            :     /* NOTE: FOR NOW WE DON'T HAVE A MAPPING...JUST DO 0..NPROCS_FOR_COLL */
<span class="lineNum">     122 </span><span class="lineCov">     576000 :     rank = fd-&gt;hints-&gt;ranklist[rank_index];</span>
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span><span class="lineCov">     576000 :     return rank;</span>
<a name="125"><span class="lineNum">     125 </span>            : }</a>
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span><span class="lineCov">     144144 : void ADIOI_Calc_file_domains(ADIO_Offset *st_offsets, ADIO_Offset</span>
<span class="lineNum">     128 </span>            :                              *end_offsets, int nprocs, int nprocs_for_coll,
<span class="lineNum">     129 </span>            :                              ADIO_Offset *min_st_offset_ptr,
<span class="lineNum">     130 </span>            :                              ADIO_Offset **fd_start_ptr, ADIO_Offset
<span class="lineNum">     131 </span>            :                              **fd_end_ptr, int min_fd_size,
<span class="lineNum">     132 </span>            :                              ADIO_Offset *fd_size_ptr,
<span class="lineNum">     133 </span>            :                              int striping_unit)
<span class="lineNum">     134 </span>            : {
<span class="lineNum">     135 </span>            : /* Divide the I/O workload among &quot;nprocs_for_coll&quot; processes. This is
<span class="lineNum">     136 </span>            :    done by (logically) dividing the file into file domains (FDs); each
<span class="lineNum">     137 </span>            :    process may directly access only its own file domain. */
<span class="lineNum">     138 </span>            : 
<span class="lineNum">     139 </span>            :     ADIO_Offset min_st_offset, max_end_offset, *fd_start, *fd_end, fd_size;
<span class="lineNum">     140 </span>            :     int i;
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span>            : #ifdef AGGREGATION_PROFILE
<span class="lineNum">     143 </span>            :     MPE_Log_event (5004, 0, NULL);
<span class="lineNum">     144 </span>            : #endif
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span>            : #ifdef AGG_DEBUG
<span class="lineNum">     147 </span>            :     FPRINTF(stderr, &quot;ADIOI_Calc_file_domains: %d aggregator(s)\n&quot;,
<span class="lineNum">     148 </span>            :             nprocs_for_coll);
<span class="lineNum">     149 </span>            : #endif
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span>            : /* find min of start offsets and max of end offsets of all processes */
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span><span class="lineCov">     144144 :     min_st_offset = st_offsets[0];</span>
<span class="lineNum">     154 </span><span class="lineCov">     144144 :     max_end_offset = end_offsets[0];</span>
<span class="lineNum">     155 </span>            : 
<span class="lineNum">     156 </span><span class="lineCov">     480480 :     for (i=1; i&lt;nprocs; i++) {</span>
<span class="lineNum">     157 </span><span class="lineCov">     336336 :         min_st_offset = ADIOI_MIN(min_st_offset, st_offsets[i]);</span>
<span class="lineNum">     158 </span><span class="lineCov">     336336 :         max_end_offset = ADIOI_MAX(max_end_offset, end_offsets[i]);</span>
<span class="lineNum">     159 </span>            :     }
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            : /* determine the &quot;file domain (FD)&quot; of each process, i.e., the portion of
<span class="lineNum">     162 </span>            :    the file that will be &quot;owned&quot; by each process */
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            : /* partition the total file access range equally among nprocs_for_coll
<span class="lineNum">     165 </span>            :    processes */
<span class="lineNum">     166 </span><span class="lineCov">     288288 :     fd_size = ((max_end_offset - min_st_offset + 1) + nprocs_for_coll -</span>
<span class="lineNum">     167 </span><span class="lineCov">     144144 :                1)/nprocs_for_coll;</span>
<span class="lineNum">     168 </span>            :     /* ceiling division as in HPF block distribution */
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span>            :     /* Tweak the file domains so that no fd is smaller than a threshold.  We
<span class="lineNum">     171 </span>            :      * have to strike a balance between efficency and parallelism: somewhere
<span class="lineNum">     172 </span>            :      * between 10k processes sending 32-byte requests and one process sending a
<span class="lineNum">     173 </span>            :      * 320k request is a (system-dependent) sweet spot */
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span><span class="lineCov">     144144 :     if (fd_size &lt; min_fd_size)</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :         fd_size = min_fd_size;</span>
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span><span class="lineCov">     144144 :     *fd_start_ptr = (ADIO_Offset *)</span>
<span class="lineNum">     179 </span><span class="lineCov">     144144 :         ADIOI_Malloc(nprocs_for_coll*sizeof(ADIO_Offset));</span>
<span class="lineNum">     180 </span><span class="lineCov">     144144 :     *fd_end_ptr = (ADIO_Offset *)</span>
<span class="lineNum">     181 </span><span class="lineCov">     144144 :         ADIOI_Malloc(nprocs_for_coll*sizeof(ADIO_Offset));</span>
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span><span class="lineCov">     144144 :     fd_start = *fd_start_ptr;</span>
<span class="lineNum">     184 </span><span class="lineCov">     144144 :     fd_end = *fd_end_ptr;</span>
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span>            :     /* Wei-keng Liao: implementation for fild domain alignment to nearest file
<span class="lineNum">     187 </span>            :      * lock boundary (as specified by striping_unit hint).  Could also
<span class="lineNum">     188 </span>            :      * experiment with other alignment strategies here */
<span class="lineNum">     189 </span><span class="lineCov">     144144 :     if (striping_unit &gt; 0) {</span>
<span class="lineNum">     190 </span>            :         ADIO_Offset end_off;
<span class="lineNum">     191 </span>            :         int         rem_front, rem_back;
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            :         /* align fd_end[0] to the nearest file lock boundary */
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :         fd_start[0] = min_st_offset;</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :         end_off     = fd_start[0] + fd_size;</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :         rem_front   = end_off % striping_unit;</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :         rem_back    = striping_unit - rem_front;</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :         if (rem_front &lt; rem_back)</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :                 end_off -= rem_front;</span>
<span class="lineNum">     200 </span>            :         else
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :                 end_off += rem_back;</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :         fd_end[0] = end_off - 1;</span>
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span>            :         /* align fd_end[i] to the nearest file lock boundary */
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :         for (i=1; i&lt;nprocs_for_coll; i++) {</span>
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :             fd_start[i] = fd_end[i-1] + 1;</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :             end_off     = min_st_offset + fd_size * (i+1);</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :             rem_front   = end_off % striping_unit;</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :             rem_back    = striping_unit - rem_front;</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :             if (rem_front &lt; rem_back)</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :                     end_off -= rem_front;</span>
<span class="lineNum">     212 </span>            :             else
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :                     end_off += rem_back;</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :             fd_end[i] = end_off - 1;</span>
<span class="lineNum">     215 </span>            :         }
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :         fd_end[nprocs_for_coll-1] = max_end_offset;</span>
<span class="lineNum">     217 </span>            :     }
<span class="lineNum">     218 </span>            :     else { /* no hints set: do things the 'old' way */
<span class="lineNum">     219 </span><span class="lineCov">     144144 :         fd_start[0] = min_st_offset;</span>
<span class="lineNum">     220 </span><span class="lineCov">     144144 :         fd_end[0] = min_st_offset + fd_size - 1;</span>
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span><span class="lineCov">     144144 :         for (i=1; i&lt;nprocs_for_coll; i++) {</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :             fd_start[i] = fd_end[i-1] + 1;</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :             fd_end[i] = fd_start[i] + fd_size - 1;</span>
<span class="lineNum">     225 </span>            :         }
<span class="lineNum">     226 </span>            :     }
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span>            : /* take care of cases in which the total file access range is not
<span class="lineNum">     229 </span>            :    divisible by the number of processes. In such cases, the last
<span class="lineNum">     230 </span>            :    process, or the last few processes, may have unequal load (even 0).
<span class="lineNum">     231 </span>            :    For example, a range of 97 divided among 16 processes.
<span class="lineNum">     232 </span>            :    Note that the division is ceiling division. */
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span><span class="lineCov">     288288 :     for (i=0; i&lt;nprocs_for_coll; i++) {</span>
<span class="lineNum">     235 </span><span class="lineCov">     144144 :         if (fd_start[i] &gt; max_end_offset)</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :             fd_start[i] = fd_end[i] = -1;</span>
<span class="lineNum">     237 </span><span class="lineCov">     144144 :         if (fd_end[i] &gt; max_end_offset)</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :             fd_end[i] = max_end_offset;</span>
<span class="lineNum">     239 </span>            :     }
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span><span class="lineCov">     144144 :     *fd_size_ptr = fd_size;</span>
<span class="lineNum">     242 </span><span class="lineCov">     144144 :     *min_st_offset_ptr = min_st_offset;</span>
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span>            : #ifdef AGGREGATION_PROFILE
<span class="lineNum">     245 </span>            :     MPE_Log_event (5005, 0, NULL);
<span class="lineNum">     246 </span>            : #endif
<span class="lineNum">     247 </span><span class="lineCov">     144144 : }</span>
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span>            : /* ADIOI_Calc_my_req() - calculate what portions of the access requests
<span class="lineNum">     251 </span>            :  * of this process are located in the file domains of various processes
<a name="252"><span class="lineNum">     252 </span>            :  * (including this one)</a>
<span class="lineNum">     253 </span>            :  */
<span class="lineNum">     254 </span><span class="lineCov">     144144 : void ADIOI_Calc_my_req(ADIO_File fd, ADIO_Offset *offset_list, ADIO_Offset *len_list,</span>
<span class="lineNum">     255 </span>            :                        int contig_access_count, ADIO_Offset
<span class="lineNum">     256 </span>            :                        min_st_offset, ADIO_Offset *fd_start,
<span class="lineNum">     257 </span>            :                        ADIO_Offset *fd_end, ADIO_Offset fd_size,
<span class="lineNum">     258 </span>            :                        int nprocs,
<span class="lineNum">     259 </span>            :                        int *count_my_req_procs_ptr,
<span class="lineNum">     260 </span>            :                        int **count_my_req_per_proc_ptr,
<span class="lineNum">     261 </span>            :                        ADIOI_Access **my_req_ptr,
<span class="lineNum">     262 </span>            :                        int **buf_idx_ptr)
<span class="lineNum">     263 </span>            : /* Possibly reconsider if buf_idx's are ok as int's, or should they be aints/offsets?
<span class="lineNum">     264 </span>            :    They are used as memory buffer indices so it seems like the 2G limit is in effect */
<span class="lineNum">     265 </span>            : {
<span class="lineNum">     266 </span>            :     int *count_my_req_per_proc, count_my_req_procs, *buf_idx;
<span class="lineNum">     267 </span>            :     int i, l, proc;
<span class="lineNum">     268 </span>            :     ADIO_Offset fd_len, rem_len, curr_idx, off;
<span class="lineNum">     269 </span>            :     ADIOI_Access *my_req;
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            : #ifdef AGGREGATION_PROFILE
<span class="lineNum">     272 </span>            :     MPE_Log_event (5024, 0, NULL);
<span class="lineNum">     273 </span>            : #endif
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span><span class="lineCov">     144144 :     *count_my_req_per_proc_ptr = (int *) ADIOI_Calloc(nprocs,sizeof(int));</span>
<span class="lineNum">     276 </span><span class="lineCov">     144144 :     count_my_req_per_proc = *count_my_req_per_proc_ptr;</span>
<span class="lineNum">     277 </span>            : /* count_my_req_per_proc[i] gives the no. of contig. requests of this
<span class="lineNum">     278 </span>            :    process in process i's file domain. calloc initializes to zero.
<span class="lineNum">     279 </span>            :    I'm allocating memory of size nprocs, so that I can do an
<span class="lineNum">     280 </span>            :    MPI_Alltoall later on.*/
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span><span class="lineCov">     144144 :     buf_idx = (int *) ADIOI_Malloc(nprocs*sizeof(int));</span>
<span class="lineNum">     283 </span>            : /* buf_idx is relevant only if buftype_is_contig.
<span class="lineNum">     284 </span>            :    buf_idx[i] gives the index into user_buf where data received
<span class="lineNum">     285 </span>            :    from proc. i should be placed. This allows receives to be done
<span class="lineNum">     286 </span>            :    without extra buffer. This can't be done if buftype is not contig. */
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span>            :     /* initialize buf_idx to -1 */
<span class="lineNum">     289 </span><span class="lineCov">     144144 :     for (i=0; i &lt; nprocs; i++) buf_idx[i] = -1;</span>
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span>            :     /* one pass just to calculate how much space to allocate for my_req;
<span class="lineNum">     292 </span>            :      * contig_access_count was calculated way back in ADIOI_Calc_my_off_len()
<span class="lineNum">     293 </span>            :      */
<span class="lineNum">     294 </span><span class="lineCov">     432144 :     for (i=0; i &lt; contig_access_count; i++) {</span>
<span class="lineNum">     295 </span>            :         /* short circuit offset/len processing if len == 0
<span class="lineNum">     296 </span>            :          *      (zero-byte  read/write */
<span class="lineNum">     297 </span><span class="lineCov">     288000 :         if (len_list[i] == 0)</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">     299 </span><span class="lineCov">     288000 :         off = offset_list[i];</span>
<span class="lineNum">     300 </span><span class="lineCov">     288000 :         fd_len = len_list[i];</span>
<span class="lineNum">     301 </span>            :         /* note: we set fd_len to be the total size of the access.  then
<span class="lineNum">     302 </span>            :          * ADIOI_Calc_aggregator() will modify the value to return the
<span class="lineNum">     303 </span>            :          * amount that was available from the file domain that holds the
<span class="lineNum">     304 </span>            :          * first part of the access.
<span class="lineNum">     305 </span>            :          */
<span class="lineNum">     306 </span><span class="lineCov">     288000 :         proc = ADIOI_Calc_aggregator(fd, off, min_st_offset, &amp;fd_len, fd_size,</span>
<span class="lineNum">     307 </span>            :                                      fd_start, fd_end);
<span class="lineNum">     308 </span><span class="lineCov">     288000 :         count_my_req_per_proc[proc]++;</span>
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span>            :         /* figure out how much data is remaining in the access (i.e. wasn't
<span class="lineNum">     311 </span>            :          * part of the file domain that had the starting byte); we'll take
<span class="lineNum">     312 </span>            :          * care of this data (if there is any) in the while loop below.
<span class="lineNum">     313 </span>            :          */
<span class="lineNum">     314 </span><span class="lineCov">     288000 :         rem_len = len_list[i] - fd_len;</span>
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span><span class="lineCov">     576000 :         while (rem_len != 0) {</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :             off += fd_len; /* point to first remaining byte */</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :             fd_len = rem_len; /* save remaining size, pass to calc */</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :             proc = ADIOI_Calc_aggregator(fd, off, min_st_offset, &amp;fd_len,</span>
<span class="lineNum">     320 </span>            :                                          fd_size, fd_start, fd_end);
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :             count_my_req_per_proc[proc]++;</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :             rem_len -= fd_len; /* reduce remaining length by amount from fd */</span>
<span class="lineNum">     324 </span>            :         }
<span class="lineNum">     325 </span>            :     }
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span>            : /* now allocate space for my_req, offset, and len */
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span><span class="lineCov">     144144 :     *my_req_ptr = (ADIOI_Access *)</span>
<span class="lineNum">     330 </span><span class="lineCov">     144144 :         ADIOI_Malloc(nprocs*sizeof(ADIOI_Access));</span>
<span class="lineNum">     331 </span><span class="lineCov">     144144 :     my_req = *my_req_ptr;</span>
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span><span class="lineCov">     144144 :     count_my_req_procs = 0;</span>
<span class="lineNum">     334 </span><span class="lineCov">     624624 :     for (i=0; i &lt; nprocs; i++) {</span>
<span class="lineNum">     335 </span><span class="lineCov">     480480 :         if (count_my_req_per_proc[i]) {</span>
<span class="lineNum">     336 </span><span class="lineCov">     288288 :             my_req[i].offsets = (ADIO_Offset *)</span>
<span class="lineNum">     337 </span><span class="lineCov">     144144 :                 ADIOI_Malloc(count_my_req_per_proc[i] * sizeof(ADIO_Offset));</span>
<span class="lineNum">     338 </span><span class="lineCov">     288288 :             my_req[i].lens =</span>
<span class="lineNum">     339 </span><span class="lineCov">     144144 :                 ADIOI_Malloc(count_my_req_per_proc[i] * sizeof(ADIO_Offset));</span>
<span class="lineNum">     340 </span><span class="lineCov">     144144 :             count_my_req_procs++;</span>
<span class="lineNum">     341 </span>            :         }
<span class="lineNum">     342 </span><span class="lineCov">     480480 :         my_req[i].count = 0;  /* will be incremented where needed</span>
<span class="lineNum">     343 </span>            :                                       later */
<span class="lineNum">     344 </span>            :     }
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span>            : /* now fill in my_req */
<span class="lineNum">     347 </span><span class="lineCov">     144144 :     curr_idx = 0;</span>
<span class="lineNum">     348 </span><span class="lineCov">     432144 :     for (i=0; i&lt;contig_access_count; i++) {</span>
<span class="lineNum">     349 </span>            :         /* short circuit offset/len processing if len == 0
<span class="lineNum">     350 </span>            :          *      (zero-byte  read/write */
<span class="lineNum">     351 </span><span class="lineCov">     288000 :         if (len_list[i] == 0)</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">     353 </span><span class="lineCov">     288000 :         off = offset_list[i];</span>
<span class="lineNum">     354 </span><span class="lineCov">     288000 :         fd_len = len_list[i];</span>
<span class="lineNum">     355 </span><span class="lineCov">     288000 :         proc = ADIOI_Calc_aggregator(fd, off, min_st_offset, &amp;fd_len, fd_size,</span>
<span class="lineNum">     356 </span>            :                                      fd_start, fd_end);
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span>            :         /* for each separate contiguous access from this process */
<span class="lineNum">     359 </span><span class="lineCov">     288000 :         if (buf_idx[proc] == -1)</span>
<span class="lineNum">     360 </span>            :   {
<span class="lineNum">     361 </span><span class="lineCov">     144144 :     ADIOI_Assert(curr_idx == (int) curr_idx);</span>
<span class="lineNum">     362 </span><span class="lineCov">     144144 :     buf_idx[proc] = (int) curr_idx;</span>
<span class="lineNum">     363 </span>            :   }
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span><span class="lineCov">     288000 :         l = my_req[proc].count;</span>
<span class="lineNum">     366 </span><span class="lineCov">     288000 :         curr_idx += fd_len;</span>
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span><span class="lineCov">     288000 :         rem_len = len_list[i] - fd_len;</span>
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span>            :         /* store the proc, offset, and len information in an array
<span class="lineNum">     371 </span>            :          * of structures, my_req. Each structure contains the
<span class="lineNum">     372 </span>            :          * offsets and lengths located in that process's FD,
<span class="lineNum">     373 </span>            :          * and the associated count.
<span class="lineNum">     374 </span>            :          */
<span class="lineNum">     375 </span><span class="lineCov">     288000 :         my_req[proc].offsets[l] = off;</span>
<span class="lineNum">     376 </span><span class="lineCov">     288000 :         my_req[proc].lens[l] = fd_len;</span>
<span class="lineNum">     377 </span><span class="lineCov">     288000 :         my_req[proc].count++;</span>
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span><span class="lineCov">     576000 :         while (rem_len != 0) {</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :             off += fd_len;</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :             fd_len = rem_len;</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :             proc = ADIOI_Calc_aggregator(fd, off, min_st_offset, &amp;fd_len,</span>
<span class="lineNum">     383 </span>            :                                          fd_size, fd_start, fd_end);
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :             if (buf_idx[proc] == -1)</span>
<span class="lineNum">     386 </span>            :       {
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :         ADIOI_Assert(curr_idx == (int) curr_idx);</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :         buf_idx[proc] = (int) curr_idx;</span>
<span class="lineNum">     389 </span>            :       }
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :             l = my_req[proc].count;</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :             curr_idx += fd_len;</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :             rem_len -= fd_len;</span>
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :             my_req[proc].offsets[l] = off;</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :             my_req[proc].lens[l] = fd_len;</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :             my_req[proc].count++;</span>
<span class="lineNum">     398 </span>            :         }
<span class="lineNum">     399 </span>            :     }
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span>            : #ifdef AGG_DEBUG
<span class="lineNum">     402 </span>            :     for (i=0; i&lt;nprocs; i++) {
<span class="lineNum">     403 </span>            :         if (count_my_req_per_proc[i] &gt; 0) {
<span class="lineNum">     404 </span>            :             FPRINTF(stdout, &quot;data needed from %d (count = %d):\n&quot;, i,
<span class="lineNum">     405 </span>            :                     my_req[i].count);
<span class="lineNum">     406 </span>            :             for (l=0; l &lt; my_req[i].count; l++) {
<span class="lineNum">     407 </span>            :                 FPRINTF(stdout, &quot;   off[%d] = %lld, len[%d] = %d\n&quot;, l,
<span class="lineNum">     408 </span>            :                         my_req[i].offsets[l], l, my_req[i].lens[l]);
<span class="lineNum">     409 </span>            :             }
<span class="lineNum">     410 </span>            :         FPRINTF(stdout, &quot;buf_idx[%d] = 0x%x\n&quot;, i, buf_idx[i]);
<span class="lineNum">     411 </span>            :         }
<span class="lineNum">     412 </span>            :     }
<span class="lineNum">     413 </span>            : #endif
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span><span class="lineCov">     144144 :     *count_my_req_procs_ptr = count_my_req_procs;</span>
<span class="lineNum">     416 </span><span class="lineCov">     144144 :     *buf_idx_ptr = buf_idx;</span>
<span class="lineNum">     417 </span>            : #ifdef AGGREGATION_PROFILE
<span class="lineNum">     418 </span>            :     MPE_Log_event (5025, 0, NULL);
<span class="lineNum">     419 </span>            : #endif
<span class="lineNum">     420 </span><span class="lineCov">     144144 : }</span>
<span class="lineNum">     421 </span>            : 
<a name="422"><span class="lineNum">     422 </span>            : </a>
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span><span class="lineCov">     144144 : void ADIOI_Calc_others_req(ADIO_File fd, int count_my_req_procs,</span>
<span class="lineNum">     425 </span>            :                                 int *count_my_req_per_proc,
<span class="lineNum">     426 </span>            :                                 ADIOI_Access *my_req,
<span class="lineNum">     427 </span>            :                                 int nprocs, int myrank,
<span class="lineNum">     428 </span>            :                                 int *count_others_req_procs_ptr,
<span class="lineNum">     429 </span>            :                                 ADIOI_Access **others_req_ptr)
<span class="lineNum">     430 </span>            : {
<span class="lineNum">     431 </span>            : /* determine what requests of other processes lie in this process's
<span class="lineNum">     432 </span>            :    file domain */
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span>            : /* count_others_req_procs = number of processes whose requests lie in
<span class="lineNum">     435 </span>            :    this process's file domain (including this process itself)
<span class="lineNum">     436 </span>            :    count_others_req_per_proc[i] indicates how many separate contiguous
<span class="lineNum">     437 </span>            :    requests of proc. i lie in this process's file domain. */
<span class="lineNum">     438 </span>            : 
<span class="lineNum">     439 </span>            :     int *count_others_req_per_proc, count_others_req_procs;
<span class="lineNum">     440 </span>            :     int i, j;
<span class="lineNum">     441 </span>            :     MPI_Request *requests;
<span class="lineNum">     442 </span>            :     MPI_Status *statuses;
<span class="lineNum">     443 </span>            :     ADIOI_Access *others_req;
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span>            : /* first find out how much to send/recv and from/to whom */
<span class="lineNum">     446 </span>            : #ifdef AGGREGATION_PROFILE
<span class="lineNum">     447 </span>            :     MPE_Log_event (5026, 0, NULL);
<span class="lineNum">     448 </span>            : #endif
<span class="lineNum">     449 </span><span class="lineCov">     144144 :     count_others_req_per_proc = (int *) ADIOI_Malloc(nprocs*sizeof(int));</span>
<span class="lineNum">     450 </span>            : 
<span class="lineNum">     451 </span><span class="lineCov">     144144 :     MPI_Alltoall(count_my_req_per_proc, 1, MPI_INT,</span>
<span class="lineNum">     452 </span>            :                  count_others_req_per_proc, 1, MPI_INT, fd-&gt;comm);
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span><span class="lineCov">     144144 :     *others_req_ptr = (ADIOI_Access *)</span>
<span class="lineNum">     455 </span><span class="lineCov">     144144 :         ADIOI_Malloc(nprocs*sizeof(ADIOI_Access));</span>
<span class="lineNum">     456 </span><span class="lineCov">     144144 :     others_req = *others_req_ptr;</span>
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span><span class="lineCov">     144144 :     count_others_req_procs = 0;</span>
<span class="lineNum">     459 </span><span class="lineCov">     624624 :     for (i=0; i&lt;nprocs; i++) {</span>
<span class="lineNum">     460 </span><span class="lineCov">     480480 :         if (count_others_req_per_proc[i]) {</span>
<span class="lineNum">     461 </span><span class="lineCov">     144144 :             others_req[i].count = count_others_req_per_proc[i];</span>
<span class="lineNum">     462 </span><span class="lineCov">     288288 :             others_req[i].offsets = (ADIO_Offset *)</span>
<span class="lineNum">     463 </span><span class="lineCov">     144144 :                 ADIOI_Malloc(count_others_req_per_proc[i]*sizeof(ADIO_Offset));</span>
<span class="lineNum">     464 </span><span class="lineCov">     288288 :             others_req[i].lens =</span>
<span class="lineNum">     465 </span><span class="lineCov">     144144 :                 ADIOI_Malloc(count_others_req_per_proc[i]*sizeof(ADIO_Offset));</span>
<span class="lineNum">     466 </span><span class="lineCov">     288288 :             others_req[i].mem_ptrs = (MPI_Aint *)</span>
<span class="lineNum">     467 </span><span class="lineCov">     144144 :                 ADIOI_Malloc(count_others_req_per_proc[i]*sizeof(MPI_Aint));</span>
<span class="lineNum">     468 </span><span class="lineCov">     144144 :             count_others_req_procs++;</span>
<span class="lineNum">     469 </span>            :         }
<span class="lineNum">     470 </span><span class="lineCov">     336336 :         else others_req[i].count = 0;</span>
<span class="lineNum">     471 </span>            :     }
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span>            : /* now send the calculated offsets and lengths to respective processes */
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span><span class="lineCov">     144144 :     requests = (MPI_Request *)</span>
<span class="lineNum">     476 </span><span class="lineCov">     144144 :         ADIOI_Malloc(1+2*(count_my_req_procs+count_others_req_procs)*sizeof(MPI_Request));</span>
<span class="lineNum">     477 </span>            : /* +1 to avoid a 0-size malloc */
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span><span class="lineCov">     144144 :     j = 0;</span>
<span class="lineNum">     480 </span><span class="lineCov">     624624 :     for (i=0; i&lt;nprocs; i++) {</span>
<span class="lineNum">     481 </span><span class="lineCov">     480480 :         if (others_req[i].count) {</span>
<span class="lineNum">     482 </span><span class="lineCov">     288288 :             MPI_Irecv(others_req[i].offsets, others_req[i].count,</span>
<span class="lineNum">     483 </span><span class="lineCov">     144144 :                       ADIO_OFFSET, i, i+myrank, fd-&gt;comm, &amp;requests[j]);</span>
<span class="lineNum">     484 </span><span class="lineCov">     144144 :             j++;</span>
<span class="lineNum">     485 </span><span class="lineCov">     432432 :             MPI_Irecv(others_req[i].lens, others_req[i].count,</span>
<span class="lineNum">     486 </span><span class="lineCov">     288288 :                       ADIO_OFFSET, i, i+myrank+1, fd-&gt;comm, &amp;requests[j]);</span>
<span class="lineNum">     487 </span><span class="lineCov">     144144 :             j++;</span>
<span class="lineNum">     488 </span>            :         }
<span class="lineNum">     489 </span>            :     }
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span><span class="lineCov">     624624 :     for (i=0; i &lt; nprocs; i++) {</span>
<span class="lineNum">     492 </span><span class="lineCov">     480480 :         if (my_req[i].count) {</span>
<span class="lineNum">     493 </span><span class="lineCov">     288288 :             MPI_Isend(my_req[i].offsets, my_req[i].count,</span>
<span class="lineNum">     494 </span><span class="lineCov">     144144 :                       ADIO_OFFSET, i, i+myrank, fd-&gt;comm, &amp;requests[j]);</span>
<span class="lineNum">     495 </span><span class="lineCov">     144144 :             j++;</span>
<span class="lineNum">     496 </span><span class="lineCov">     432432 :             MPI_Isend(my_req[i].lens, my_req[i].count,</span>
<span class="lineNum">     497 </span><span class="lineCov">     288288 :                       ADIO_OFFSET, i, i+myrank+1, fd-&gt;comm, &amp;requests[j]);</span>
<span class="lineNum">     498 </span><span class="lineCov">     144144 :             j++;</span>
<span class="lineNum">     499 </span>            :         }
<span class="lineNum">     500 </span>            :     }
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span><span class="lineCov">     144144 :     if (j) {</span>
<span class="lineNum">     503 </span><span class="lineCov">     144144 :         statuses = (MPI_Status *) ADIOI_Malloc(j * sizeof(MPI_Status));</span>
<span class="lineNum">     504 </span><span class="lineCov">     144144 :         MPI_Waitall(j, requests, statuses);</span>
<span class="lineNum">     505 </span><span class="lineCov">     144144 :         ADIOI_Free(statuses);</span>
<span class="lineNum">     506 </span>            :     }
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span><span class="lineCov">     144144 :     ADIOI_Free(requests);</span>
<span class="lineNum">     509 </span><span class="lineCov">     144144 :     ADIOI_Free(count_others_req_per_proc);</span>
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span><span class="lineCov">     144144 :     *count_others_req_procs_ptr = count_others_req_procs;</span>
<span class="lineNum">     512 </span>            : #ifdef AGGREGATION_PROFILE
<span class="lineNum">     513 </span>            :     MPE_Log_event (5027, 0, NULL);
<span class="lineNum">     514 </span>            : #endif
<span class="lineNum">     515 </span><span class="lineCov">     144144 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
