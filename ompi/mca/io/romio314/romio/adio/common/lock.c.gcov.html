<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - master-ibm-intel-check - ompi/mca/io/romio314/romio/adio/common/lock.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../../index.html">top level</a> - <a href="index.html">ompi/mca/io/romio314/romio/adio/common</a> - lock.c<span style="font-size: 80%;"> (source / <a href="lock.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">master-ibm-intel-check</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">16</td>
            <td class="headerCovTableEntry">25</td>
            <td class="headerCovTableEntryLo">64.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2015-08-03 17:10:23</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr><td><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil ; -*- */</a>
<span class="lineNum">       2 </span>            : /*
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  *   Copyright (C) 1997 University of Chicago.
<span class="lineNum">       5 </span>            :  *   See COPYRIGHT notice in top-level directory.
<span class="lineNum">       6 </span>            :  */
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            : #include &quot;adio.h&quot;
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : #ifdef ROMIO_NTFS
<span class="lineNum">      11 </span>            : /* This assumes that lock will always remain in the common directory and
<span class="lineNum">      12 </span>            :  * that the ntfs directory will always be called ad_ntfs. */
<span class="lineNum">      13 </span>            : #include &quot;..\ad_ntfs\ad_ntfs.h&quot;
<span class="lineNum">      14 </span>            : int ADIOI_Set_lock(FDTYPE fd, int cmd, int type, ADIO_Offset offset, int whence,
<span class="lineNum">      15 </span>            :              ADIO_Offset len)
<span class="lineNum">      16 </span>            : {
<span class="lineNum">      17 </span>            :     static char myname[] = &quot;ADIOI_Set_lock&quot;;
<span class="lineNum">      18 </span>            :     int ret_val, error_code = MPI_SUCCESS;
<span class="lineNum">      19 </span>            :     OVERLAPPED Overlapped;
<span class="lineNum">      20 </span>            :     DWORD dwFlags;
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            :     ADIOI_UNREFERENCED_ARG(whence);
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            :     if (len == 0) return MPI_SUCCESS;
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            :     dwFlags = type;
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            :     Overlapped.hEvent = /*0;*/CreateEvent(NULL, TRUE, FALSE, NULL);
<span class="lineNum">      29 </span>            : #ifdef HAVE_INT64
<span class="lineNum">      30 </span>            :     Overlapped.Offset = ( (DWORD) ( offset &amp; (__int64) 0xFFFFFFFF ) );
<span class="lineNum">      31 </span>            :     Overlapped.OffsetHigh = ( (DWORD) ( (offset &gt;&gt; 32) &amp; (__int64) 0xFFFFFFFF ) );
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            :     if (cmd == ADIOI_LOCK_CMD)
<span class="lineNum">      34 </span>            :     {
<span class="lineNum">      35 </span>            :         /*printf(&quot;locking %d\n&quot;, (int)fd);fflush(stdout);*/
<span class="lineNum">      36 </span>            :         ret_val = LockFileEx(fd, dwFlags, 0,
<span class="lineNum">      37 </span>            :         ( (DWORD) ( len &amp; (__int64) 0xFFFFFFFF ) ),
<span class="lineNum">      38 </span>            :         ( (DWORD) ( (len &gt;&gt; 32) &amp; (__int64) 0xFFFFFFFF ) ),
<span class="lineNum">      39 </span>            :         &amp;Overlapped);
<span class="lineNum">      40 </span>            :     }
<span class="lineNum">      41 </span>            :     else
<span class="lineNum">      42 </span>            :     {
<span class="lineNum">      43 </span>            :         /*printf(&quot;unlocking %d\n&quot;, (int)fd);fflush(stdout);*/
<span class="lineNum">      44 </span>            :         ret_val = UnlockFileEx(fd, 0,
<span class="lineNum">      45 </span>            :         ( (DWORD) ( len &amp; (__int64) 0xFFFFFFFF ) ),
<span class="lineNum">      46 </span>            :         ( (DWORD) ( (len &gt;&gt; 32) &amp; (__int64) 0xFFFFFFFF ) ),
<span class="lineNum">      47 </span>            :         &amp;Overlapped);
<span class="lineNum">      48 </span>            :     }
<span class="lineNum">      49 </span>            : #else
<span class="lineNum">      50 </span>            :     Overlapped.Offset = offset;
<span class="lineNum">      51 </span>            :     Overlapped.OffsetHigh = 0;
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span>            :     if (cmd == ADIOI_LOCK_CMD)
<span class="lineNum">      54 </span>            :     {
<span class="lineNum">      55 </span>            :         /*printf(&quot;locking %d\n&quot;, (int)fd);fflush(stdout);*/
<span class="lineNum">      56 </span>            :         ret_val = LockFileEx(fd, dwFlags, 0, len, 0, &amp;Overlapped);
<span class="lineNum">      57 </span>            :     }
<span class="lineNum">      58 </span>            :     else
<span class="lineNum">      59 </span>            :     {
<span class="lineNum">      60 </span>            :         /*printf(&quot;unlocking %d\n&quot;, (int)fd);fflush(stdout);*/
<span class="lineNum">      61 </span>            :         ret_val = UnlockFileEx(fd, 0, len, 0, &amp;Overlapped);
<span class="lineNum">      62 </span>            :     }
<span class="lineNum">      63 </span>            : #endif
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            :     if (!ret_val)
<span class="lineNum">      66 </span>            :     {
<span class="lineNum">      67 </span>            :     char errMsg[ADIOI_NTFS_ERR_MSG_MAX];
<span class="lineNum">      68 </span>            :         /*
<span class="lineNum">      69 </span>            :         FPRINTF(stderr, &quot;File locking failed in ADIOI_Set_lock.\n&quot;);
<span class="lineNum">      70 </span>            :         MPI_Abort(MPI_COMM_WORLD, 1);
<span class="lineNum">      71 </span>            :         */
<span class="lineNum">      72 </span>            :         ret_val = GetLastError();
<span class="lineNum">      73 </span>            :         if (ret_val == ERROR_IO_PENDING)
<span class="lineNum">      74 </span>            :         {
<span class="lineNum">      75 </span>            :             DWORD dummy;
<span class="lineNum">      76 </span>            :             ret_val = GetOverlappedResult(fd, &amp;Overlapped, &amp;dummy, TRUE);
<span class="lineNum">      77 </span>            :             if (ret_val)
<span class="lineNum">      78 </span>            :             {
<span class="lineNum">      79 </span>            :                 CloseHandle(Overlapped.hEvent);
<span class="lineNum">      80 </span>            :                 return MPI_SUCCESS;
<span class="lineNum">      81 </span>            :             }
<span class="lineNum">      82 </span>            :             ret_val = GetLastError();
<span class="lineNum">      83 </span>            :         }
<span class="lineNum">      84 </span>            :     ADIOI_NTFS_Strerror(ret_val, errMsg, ADIOI_NTFS_ERR_MSG_MAX);
<span class="lineNum">      85 </span>            :         error_code = MPIO_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__,
<span class="lineNum">      86 </span>            :             MPI_ERR_IO, &quot;**io&quot;, &quot;**io %s&quot;, errMsg);
<span class="lineNum">      87 </span>            :     }
<span class="lineNum">      88 </span>            :     CloseHandle(Overlapped.hEvent);
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span>            :     return error_code;
<a name="91"><span class="lineNum">      91 </span>            : }</a>
<span class="lineNum">      92 </span>            : #else
<span class="lineNum">      93 </span><span class="lineCov">       2736 : int ADIOI_Set_lock(FDTYPE fd, int cmd, int type, ADIO_Offset offset, int whence,</span>
<span class="lineNum">      94 </span>            :              ADIO_Offset len)
<span class="lineNum">      95 </span>            : {
<span class="lineNum">      96 </span><span class="lineCov">       2736 :     int err, error_code, err_count = 0, sav_errno;</span>
<span class="lineNum">      97 </span>            :     struct flock lock;
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span><span class="lineCov">       2736 :     if (len == 0) return MPI_SUCCESS;</span>
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            :     /* Depending on the compiler flags and options, struct flock
<span class="lineNum">     103 </span>            :        may not be defined with types that are the same size as
<span class="lineNum">     104 </span>            :        ADIO_Offsets.  */
<span class="lineNum">     105 </span>            : /* FIXME: This is a temporary hack until we use flock64 where
<span class="lineNum">     106 </span>            :    available. It also doesn't fix the broken Solaris header sys/types.h
<span class="lineNum">     107 </span>            :    header file, which declars off_t as a UNION ! Configure tests to
<span class="lineNum">     108 </span>            :    see if the off64_t is a union if large file support is requested;
<span class="lineNum">     109 </span>            :    if so, it does not select large file support.
<span class="lineNum">     110 </span>            : */
<span class="lineNum">     111 </span>            : #ifdef NEEDS_INT_CAST_WITH_FLOCK
<span class="lineNum">     112 </span>            :     lock.l_type   = type;
<span class="lineNum">     113 </span>            :     lock.l_start  = (int)offset;
<span class="lineNum">     114 </span>            :     lock.l_whence = whence;
<span class="lineNum">     115 </span>            :     lock.l_len    = (int)len;
<span class="lineNum">     116 </span>            : #else
<span class="lineNum">     117 </span><span class="lineCov">       2736 :     lock.l_type   = type;</span>
<span class="lineNum">     118 </span><span class="lineCov">       2736 :     lock.l_whence = whence;</span>
<span class="lineNum">     119 </span><span class="lineCov">       2736 :     lock.l_start  = offset;</span>
<span class="lineNum">     120 </span><span class="lineCov">       2736 :     lock.l_len    = len;</span>
<span class="lineNum">     121 </span>            : #endif
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span><span class="lineCov">       2736 :     sav_errno = errno; /* save previous errno in case we recover from retryable errors */</span>
<span class="lineNum">     124 </span><span class="lineCov">       2736 :     errno = 0;</span>
<span class="lineNum">     125 </span>            :     do {
<span class="lineNum">     126 </span><span class="lineCov">       2736 :         err = fcntl(fd, cmd, &amp;lock);</span>
<span class="lineNum">     127 </span>            : #ifdef USE_DBG_LOGGING
<span class="lineNum">     128 </span>            : /*      if (MPIU_DBG_SELECTED(ROMIO,TERSE)) */
<span class="lineNum">     129 </span>            :       {
<span class="lineNum">     130 </span>            :         if (err &amp;&amp; ((errno == EINTR) || (errno == EINPROGRESS)))
<span class="lineNum">     131 </span>            :         {
<span class="lineNum">     132 </span>            :           if((err_count &lt; 5) || (err_count &gt; 9995))
<span class="lineNum">     133 </span>            :           {
<span class="lineNum">     134 </span>            :             fprintf(stderr, &quot;File locking failed in ADIOI_Set_lock(fd %#X,cmd %s/%#X,type %s/%#X,whence %#X) with return value %#X and errno %#X.  Retry (%d).\n&quot;,
<span class="lineNum">     135 </span>            :                     fd,
<span class="lineNum">     136 </span>            :                     ((cmd == F_GETLK   )? &quot;F_GETLK&quot; :
<span class="lineNum">     137 </span>            :                     ((cmd == F_SETLK   )? &quot;F_SETLK&quot; :
<span class="lineNum">     138 </span>            :                     ((cmd == F_SETLKW  )? &quot;F_SETLKW&quot; : &quot;UNEXPECTED&quot;))),
<span class="lineNum">     139 </span>            :                     cmd,
<span class="lineNum">     140 </span>            :                     ((type == F_RDLCK   )? &quot;F_RDLCK&quot; :
<span class="lineNum">     141 </span>            :                     ((type == F_WRLCK   )? &quot;F_WRLCK&quot; :
<span class="lineNum">     142 </span>            :                     ((type == F_UNLCK   )? &quot;F_UNLOCK&quot; : &quot;UNEXPECTED&quot;))),
<span class="lineNum">     143 </span>            :                     type,
<span class="lineNum">     144 </span>            :                     whence, err, errno, err_count);
<span class="lineNum">     145 </span>            :           perror(&quot;ADIOI_Set_lock:&quot;);
<span class="lineNum">     146 </span>            :           fprintf(stderr,&quot;ADIOI_Set_lock:offset %#llx, length %#llx\n&quot;,(unsigned long long)offset, (unsigned long long)len);
<span class="lineNum">     147 </span>            :           }
<span class="lineNum">     148 </span>            :         }
<span class="lineNum">     149 </span>            :       }
<span class="lineNum">     150 </span>            : #endif
<span class="lineNum">     151 </span><span class="lineCov">       2736 :     } while (err &amp;&amp; ((errno == EINTR) || ((errno == EINPROGRESS) &amp;&amp; (++err_count &lt; 10000))));</span>
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span><span class="lineCov">       2736 :     if (err &amp;&amp; (errno != EBADF)) {</span>
<span class="lineNum">     154 </span>            :         /* FIXME: This should use the error message system,
<span class="lineNum">     155 </span>            :            especially for MPICH */
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :         FPRINTF(stderr, &quot;This requires fcntl(2) to be implemented. As of 8/25/2011 it is not. Generic MPICH Message: File locking failed in ADIOI_Set_lock(fd %X,cmd %s/%X,type %s/%X,whence %X) with return value %X and errno %X.\n&quot;</span>
<span class="lineNum">     157 </span>            :                   &quot;- If the file system is NFS, you need to use NFS version 3, ensure that the lockd daemon is running on all the machines, and mount the directory with the 'noac' option (no attribute caching).\n&quot;
<span class="lineNum">     158 </span>            :                   &quot;- If the file system is LUSTRE, ensure that the directory is mounted with the 'flock' option.\n&quot;,
<span class="lineNum">     159 </span>            :           fd,
<span class="lineNum">     160 </span>            :           ((cmd == F_GETLK   )? &quot;F_GETLK&quot; :
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :           ((cmd == F_SETLK   )? &quot;F_SETLK&quot; :</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :           ((cmd == F_SETLKW  )? &quot;F_SETLKW&quot; : &quot;UNEXPECTED&quot;))),</span>
<span class="lineNum">     163 </span>            :           cmd,
<span class="lineNum">     164 </span>            :           ((type == F_RDLCK   )? &quot;F_RDLCK&quot; :
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :           ((type == F_WRLCK   )? &quot;F_WRLCK&quot; :</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :           ((type == F_UNLCK   )? &quot;F_UNLOCK&quot; : &quot;UNEXPECTED&quot;))),</span>
<span class="lineNum">     167 </span>            :           type,
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :           whence, err, errno);</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :   perror(&quot;ADIOI_Set_lock:&quot;);</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :   FPRINTF(stderr,&quot;ADIOI_Set_lock:offset %llu, length %llu\n&quot;,(unsigned long long)offset, (unsigned long long)len);</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :         MPI_Abort(MPI_COMM_WORLD, 1);</span>
<span class="lineNum">     172 </span>            :     }
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span><span class="lineCov">       2736 :     if(!err)             /* report fcntl failure errno's (EBADF), otherwise */</span>
<span class="lineNum">     175 </span><span class="lineCov">       2736 :       errno = sav_errno; /* restore previous errno in case we recovered from retryable errors */</span>
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span><span class="lineCov">       2736 :     error_code = (err == 0) ? MPI_SUCCESS : MPI_ERR_UNKNOWN;</span>
<span class="lineNum">     178 </span><span class="lineCov">       2736 :     return error_code;</span>
<span class="lineNum">     179 </span>            : }
<span class="lineNum">     180 </span>            : #endif
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span>            : #if (defined(ROMIO_HFS) || defined(ROMIO_XFS))
<span class="lineNum">     183 </span>            : int ADIOI_Set_lock64(FDTYPE fd, int cmd, int type, ADIO_Offset offset,
<span class="lineNum">     184 </span>            :                      int whence,
<span class="lineNum">     185 </span>            :                      ADIO_Offset len)
<span class="lineNum">     186 </span>            : {
<span class="lineNum">     187 </span>            :     int err, error_code;
<span class="lineNum">     188 </span>            :     struct flock64 lock;
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            :     if (len == 0) return MPI_SUCCESS;
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span>            :     lock.l_type = type;
<span class="lineNum">     193 </span>            :     lock.l_start = offset;
<span class="lineNum">     194 </span>            :     lock.l_whence = whence;
<span class="lineNum">     195 </span>            :     lock.l_len = len;
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span>            :     do {
<span class="lineNum">     198 </span>            :         err = fcntl(fd, cmd, &amp;lock);
<span class="lineNum">     199 </span>            :     } while (err &amp;&amp; (errno == EINTR));
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span>            :     if (err &amp;&amp; (errno != EBADF)) {
<span class="lineNum">     202 </span>            :         FPRINTF(stderr, &quot;File locking failed in ADIOI_Set_lock64(fd %X,cmd %s/%X,type %s/%X,whence %X) with return value %X and errno %X.\n&quot;
<span class="lineNum">     203 </span>            :                   &quot;If the file system is NFS, you need to use NFS version 3, ensure that the lockd daemon is running on all the machines, and mount the directory with the 'noac' option (no attribute caching).\n&quot;,
<span class="lineNum">     204 </span>            :           fd,
<span class="lineNum">     205 </span>            :           ((cmd == F_GETLK   )? &quot;F_GETLK&quot; :
<span class="lineNum">     206 </span>            :           ((cmd == F_SETLK   )? &quot;F_SETLK&quot; :
<span class="lineNum">     207 </span>            :           ((cmd == F_SETLKW  )? &quot;F_SETLKW&quot; :
<span class="lineNum">     208 </span>            :           ((cmd == F_GETLK64 )? &quot;F_GETLK64&quot; :
<span class="lineNum">     209 </span>            :           ((cmd == F_SETLK64 )? &quot;F_SETLK64&quot; :
<span class="lineNum">     210 </span>            :           ((cmd == F_SETLKW64)? &quot;F_SETLKW64&quot; : &quot;UNEXPECTED&quot;)))))),
<span class="lineNum">     211 </span>            :           cmd,
<span class="lineNum">     212 </span>            :           ((type == F_RDLCK   )? &quot;F_RDLCK&quot; :
<span class="lineNum">     213 </span>            :           ((type == F_WRLCK   )? &quot;F_WRLCK&quot; :
<span class="lineNum">     214 </span>            :           ((type == F_UNLCK   )? &quot;F_UNLOCK&quot; : &quot;UNEXPECTED&quot;))),
<span class="lineNum">     215 </span>            :           type,
<span class="lineNum">     216 </span>            :           whence, err, errno);
<span class="lineNum">     217 </span>            :   perror(&quot;ADIOI_Set_lock64:&quot;);
<span class="lineNum">     218 </span>            :   FPRINTF(stderr,&quot;ADIOI_Set_lock:offset %llu, length %llu\n&quot;,(unsigned long long)offset, (unsigned long long)len);
<span class="lineNum">     219 </span>            :         MPI_Abort(MPI_COMM_WORLD, 1);
<span class="lineNum">     220 </span>            :     }
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span>            :     error_code = (err == 0) ? MPI_SUCCESS : MPI_ERR_UNKNOWN;
<span class="lineNum">     223 </span>            :     return error_code;
<span class="lineNum">     224 </span>            : }
<span class="lineNum">     225 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
