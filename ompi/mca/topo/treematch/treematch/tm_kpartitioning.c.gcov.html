<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - master-ibm-intel-check - ompi/mca/topo/treematch/treematch/tm_kpartitioning.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../index.html">top level</a> - <a href="index.html">ompi/mca/topo/treematch/treematch</a> - tm_kpartitioning.c<span style="font-size: 80%;"> (source / <a href="tm_kpartitioning.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">master-ibm-intel-check</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">222</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2015-08-03 17:10:23</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">12</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : #include &quot;tm_mapping.h&quot;</a>
<span class="lineNum">       2 </span>            : #include &quot;tm_mt.h&quot;
<span class="lineNum">       3 </span>            : #include &quot;tm_kpartitioning.h&quot;
<span class="lineNum">       4 </span>            : #include &lt;stdlib.h&gt;
<span class="lineNum">       5 </span>            : #include &lt;stdio.h&gt;
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #define USE_KL_KPART 0
<span class="lineNum">       8 </span>            : #if USE_KL_KPART
<span class="lineNum">       9 </span>            : #include &quot;k-partitioning.h&quot;
<span class="lineNum">      10 </span>            : #endif  /* USE_KL_KPART */
<span class="lineNum">      11 </span>            : #define KL_KPART_GREEDY_TRIALS 0
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : static int verbose_level = ERROR;
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : #define MAX_TRIALS 10
<span class="lineNum">      16 </span>            : #define USE_KL_STRATEGY 1
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : #define MIN(a,b) ((a)&lt;(b)?(a):(b))
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : int  fill_tab(int **,int *,int,int,int,int);
<span class="lineNum">      23 </span>            : void complete_com_mat(double ***,int,int);
<span class="lineNum">      24 </span>            : void complete_obj_weight(double **,int,int);
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : void allocate_vertex(int,int *,com_mat_t *,int,int *,int);
<span class="lineNum">      27 </span>            : double eval_cost(int *, com_mat_t *);
<span class="lineNum">      28 </span>            : int *kpartition_greedy(int, com_mat_t *,int,int *,int);
<span class="lineNum">      29 </span>            : constraint_t *split_constraints (int *,int,int,tm_topology_t *,int);
<span class="lineNum">      30 </span>            : com_mat_t **split_com_mat(com_mat_t *,int,int,int *);
<span class="lineNum">      31 </span>            : int **split_vertices(int *,int,int,int *);
<span class="lineNum">      32 </span>            : void FREE_tab_com_mat(com_mat_t **,int);
<span class="lineNum">      33 </span>            : void FREE_tab_local_vertices(int **,int);
<span class="lineNum">      34 </span>            : void FREE_const_tab(constraint_t *,int);
<span class="lineNum">      35 </span>            : void kpartition_build_level_topology(tree_t *,com_mat_t *,int,int,tm_topology_t *,
<span class="lineNum">      36 </span>            :                                      int *,int *,int,double *,double *);
<span class="lineNum">      37 </span>            : 
<a name="38"><span class="lineNum">      38 </span>            : </a>
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span><span class="lineNoCov">          0 : void allocate_vertex(int u, int *res, com_mat_t *com_mat, int n, int *size, int max_size)</span>
<span class="lineNum">      41 </span>            : {
<span class="lineNum">      42 </span><span class="lineNoCov">          0 :   int i,best_part=0;</span>
<span class="lineNum">      43 </span><span class="lineNoCov">          0 :   double cost, best_cost = -1;</span>
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            :   /*printf(&quot;\n&quot;);
<span class="lineNum">      46 </span>            :     print_1D_tab(res,n);*/
<span class="lineNum">      47 </span><span class="lineNoCov">          0 :   if(u&gt;=com_mat-&gt;n){</span>
<span class="lineNum">      48 </span><span class="lineNoCov">          0 :     for( i = 0 ; i &lt; n ; i++)</span>
<span class="lineNum">      49 </span><span class="lineNoCov">          0 :       if (( res[i] != -1 ) &amp;&amp; ( size[res[i]] &lt; max_size )){</span>
<span class="lineNum">      50 </span><span class="lineNoCov">          0 :         best_part = res[i];</span>
<span class="lineNum">      51 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">      52 </span>            :       }
<span class="lineNum">      53 </span>            :   }else{
<span class="lineNum">      54 </span><span class="lineNoCov">          0 :     for( i = 0 ; i &lt; n ; i++){</span>
<span class="lineNum">      55 </span><span class="lineNoCov">          0 :       if (( res[i] != -1 ) &amp;&amp; ( size[res[i]] &lt; max_size )){</span>
<span class="lineNum">      56 </span><span class="lineNoCov">          0 :         cost = (((i)&lt;com_mat-&gt;n)) ?com_mat-&gt;comm[u][i]:0;</span>
<span class="lineNum">      57 </span><span class="lineNoCov">          0 :         if (( cost &gt; best_cost)){</span>
<span class="lineNum">      58 </span><span class="lineNoCov">          0 :           best_cost = cost;</span>
<span class="lineNum">      59 </span><span class="lineNoCov">          0 :           best_part = res[i];</span>
<span class="lineNum">      60 </span>            :         }
<span class="lineNum">      61 </span>            :       }
<span class="lineNum">      62 </span>            :     }
<span class="lineNum">      63 </span>            :   }
<span class="lineNum">      64 </span>            :   /*  printf(&quot;size[%d]: %d\n&quot;,best_part, size[best_part]);*/
<span class="lineNum">      65 </span>            :   /* printf(&quot;putting(%.2f): %d -&gt; %d\n&quot;,best_cost, u, best_part); */
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span><span class="lineNoCov">          0 :   res[u] = best_part;</span>
<span class="lineNum">      68 </span><span class="lineNoCov">          0 :   size[best_part]++;</span>
<a name="69"><span class="lineNum">      69 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span><span class="lineNoCov">          0 : double eval_cost(int *partition, com_mat_t *com_mat)</span>
<span class="lineNum">      72 </span>            : {
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :   double cost = 0;</span>
<span class="lineNum">      74 </span>            :   int i,j;
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :   for( i = 0 ; i &lt; com_mat-&gt;n ; i++ )</span>
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :     for( j = i+1 ; j &lt; com_mat-&gt;n ; j++ )</span>
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :       if(partition[i] != partition[j])</span>
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :         cost += com_mat-&gt;comm[i][j];</span>
<span class="lineNum">      80 </span>            : 
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :   return cost;</span>
<a name="82"><span class="lineNum">      82 </span>            : }</a>
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span><span class="lineNoCov">          0 : int  *kpartition_greedy(int k, com_mat_t *com_mat, int n, int *constraints, int nb_constraints)</span>
<span class="lineNum">      85 </span>            : {
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :   int *res = NULL, *best_res=NULL, *size = NULL;</span>
<span class="lineNum">      87 </span>            :   int i,j,nb_trials;
<span class="lineNum">      88 </span>            :   int max_size, max_val;
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :   double cost, best_cost = -1;</span>
<span class="lineNum">      90 </span>            :   int start, end;
<span class="lineNum">      91 </span>            :   int dumb_id, nb_dumb;
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span>            : 
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :   for( nb_trials = 0 ; nb_trials &lt; MAX_TRIALS ; nb_trials++ ){</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :     res = (int *)MALLOC(sizeof(int)*n);</span>
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :     for ( i = 0 ; i &lt; n ; i ++ )</span>
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :       res[i] = -1;</span>
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :     size = (int *)CALLOC(k,sizeof(int));</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :     max_size = n/k;</span>
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span>            :     /*printf(&quot;Constraints: &quot;);print_1D_tab(constraints,nb_constraints);*/
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span>            :     /* put &quot;dumb&quot; vertices in the correct partition if there are any*/
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :     if (nb_constraints){</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :       start = 0;</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :       dumb_id = n-1;</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :       for( i = 0 ; i &lt; k ; i ++){</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :         max_val = (i+1)* (n/k);</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :         end = start;</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :         while( end &lt; nb_constraints){</span>
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :           if(constraints[end] &gt;= max_val)</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :           end++;</span>
<span class="lineNum">     117 </span>            :         }
<span class="lineNum">     118 </span>            :         /* now end - start is the number of constarints for the ith subtree
<span class="lineNum">     119 </span>            :            hence the number of dumb vertices is the differences between the
<span class="lineNum">     120 </span>            :            number of leaves of the subtree (n/k) and the number of constraints
<span class="lineNum">     121 </span>            :         */
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :         nb_dumb = n/k - (end-start);</span>
<span class="lineNum">     123 </span>            :         /*printf(&quot;max_val: %d, nb_dumb=%d, start=%d, end=%d, size=%d\n&quot;,max_val, nb_dumb, start, end, n/k);*/
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span>            :         /* dumb vertices are the one with highest indices:
<span class="lineNum">     126 </span>            :            put them in the ith partitions*/
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :         for( j = 0; j &lt; nb_dumb; j ++ ){</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :           res[dumb_id] = i;</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :           dumb_id--;</span>
<span class="lineNum">     130 </span>            :         }
<span class="lineNum">     131 </span>            :         /* increase the size of the ith partition accordingly*/
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :         size[i] += nb_dumb;</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :         start=end;</span>
<span class="lineNum">     134 </span>            :       }
<span class="lineNum">     135 </span>            :     }
<span class="lineNum">     136 </span>            :     /*printf(&quot;After dumb vertices mapping: &quot;);print_1D_tab(res,n);*/
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            :     /* choose k initial &quot;true&quot; vertices at random and put them in a different partition */
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :     for ( i = 0 ; i &lt; k ; i ++ ){</span>
<span class="lineNum">     140 </span>            :       /* if the partition is full of dumb vertices go to next partition*/
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :       if(size[i] &gt;= max_size)</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">     143 </span>            :       /* find a vertex not allready partitionned*/
<span class="lineNum">     144 </span>            :       do{
<span class="lineNum">     145 </span>            :         /* call the mersenne twister PRNG of tm_mt.c*/
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :         j =  genrand_int32() % n;</span>
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :       } while ( res[j] != -1 );</span>
<span class="lineNum">     148 </span>            :       /* allocate and update size of partition*/
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :       res[j] = i;</span>
<span class="lineNum">     150 </span>            :       /* printf(&quot;random: %d -&gt; %d\n&quot;,j,i); */
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :       size[i]++;</span>
<span class="lineNum">     152 </span>            :     }
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span>            :     /* allocate each unaloacted vertices in the partition that maximize the communication*/
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :     for( i = 0 ;  i &lt; n ; i ++)</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :       if( res[i] == -1)</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :         allocate_vertex(i, res, com_mat, n, size, max_size);</span>
<span class="lineNum">     158 </span>            : 
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :     cost = eval_cost(res,com_mat);</span>
<span class="lineNum">     160 </span>            :     /*print_1D_tab(res,n);
<span class="lineNum">     161 </span>            :     printf(&quot;cost=%.2f\n&quot;,cost);*/
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :     if((cost&lt;best_cost) || (best_cost == -1)){</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :       best_cost=cost;</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :       FREE(best_res);</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :       best_res=res;</span>
<span class="lineNum">     166 </span>            :     }else
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :       FREE(res);</span>
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :     FREE(size);</span>
<span class="lineNum">     170 </span>            :   }
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            :   /*print_1D_tab(best_res,n);
<span class="lineNum">     173 </span>            :   printf(&quot;best_cost=%.2f\n&quot;,best_cost);
<span class="lineNum">     174 </span>            :   */
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :   return best_res;</span>
<a name="176"><span class="lineNum">     176 </span>            : }</a>
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span><span class="lineNoCov">          0 : int *kpartition(int k, com_mat_t *com_mat, int n, int *constraints, int nb_constraints)</span>
<span class="lineNum">     179 </span>            : {
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :   int *res= NULL;</span>
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :   if( n%k != 0){</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :     if(verbose_level &gt;= ERROR)</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :       fprintf(stderr,&quot;Error: Cannot partition %d elements in %d parts\n&quot;,n,k);</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">     186 </span>            :   }
<span class="lineNum">     187 </span>            : 
<span class="lineNum">     188 </span>            :   /* if(USE_KL_KPART) */
<span class="lineNum">     189 </span>            :   /*   res = kPartitioning(comm, n, k, constraints, nb_constraints, KL_KPART_GREEDY_TRIALS); */
<span class="lineNum">     190 </span>            :   /* else */
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :     res = kpartition_greedy(k, com_mat, n, constraints, nb_constraints);</span>
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :   return res;</span>
<a name="194"><span class="lineNum">     194 </span>            : }</a>
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span><span class="lineNoCov">          0 : constraint_t *split_constraints (int *constraints, int nb_constraints, int k, tm_topology_t *topology, int depth)</span>
<span class="lineNum">     197 </span>            : {
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :   constraint_t *const_tab = NULL;</span>
<span class="lineNum">     199 </span>            :   int nb_leaves, start, end;
<span class="lineNum">     200 </span>            :   int i;
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :   const_tab = (constraint_t *)CALLOC(k,sizeof(constraint_t));</span>
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span>            :   /* nb_leaves is the number of leaves of the current subtree
<span class="lineNum">     205 </span>            :      this will help to detremine where to split constraints and how to shift values
<span class="lineNum">     206 </span>            :   */
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :   nb_leaves = compute_nb_leaves_from_level( depth + 1, topology );</span>
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span>            : /* split the constraints into k sub-constraints
<span class="lineNum">     210 </span>            :      each sub-contraints 'i' contains constraints of value in [i*nb_leaves,(i+1)*nb_leaves[
<span class="lineNum">     211 </span>            :    */
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :   start = 0;</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :   for( i = 0; i &lt; k; i++ ){</span>
<span class="lineNum">     214 </span>            :     /*returns the indice in contsraints that contains the smallest value not copied
<span class="lineNum">     215 </span>            :       end is used to compute the number of copied elements (end-size) and is used as the next staring indices*/
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :     end = fill_tab(&amp;(const_tab[i].constraints), constraints, nb_constraints,start, (i+1) * nb_leaves, i * nb_leaves);</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :     const_tab[i].length = end-start;</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :     const_tab[i].id = i;</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :     start = end;</span>
<span class="lineNum">     220 </span>            :   }
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :   return const_tab;</span>
<span class="lineNum">     223 </span>            : }
<a name="224"><span class="lineNum">     224 </span>            : </a>
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span><span class="lineNoCov">          0 : com_mat_t **split_com_mat(com_mat_t *com_mat, int n, int k, int *partition)</span>
<span class="lineNum">     227 </span>            : {
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :   com_mat_t **res = NULL, *sub_com_mat;</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :   double **sub_mat = NULL;</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :   int *perm = NULL;</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :   int cur_part, i, ii, j, jj, m = n/k, s;</span>
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :   res = (com_mat_t**)MALLOC(k*sizeof(com_mat_t *));</span>
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :   if(verbose_level &gt;= DEBUG){</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :     printf(&quot;Partition: &quot;); print_1D_tab(partition,n);</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :     display_tab(com_mat-&gt;comm,com_mat-&gt;n);</span>
<span class="lineNum">     239 </span>            :   }
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :   perm  = (int*)MALLOC(sizeof(int)*m);</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :   for( cur_part = 0 ; cur_part &lt; k ; cur_part ++ ){</span>
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span>            :     /* build perm such that submat[i][j] correspond to com_mat[perm[i]][perm[j]] according to the partition*/
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :     s = 0;</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :     for( j = 0; j &lt; com_mat-&gt;n; j ++) /* check only non zero element of of com_mat*/</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :       if ( partition[j] == cur_part )</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :         perm[s++] = j;</span>
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span>            :     /* s is now the size of the non zero sub matrix for this partition*/
<span class="lineNum">     251 </span>            :     /* built a sub-matrix for partition cur_part*/
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :     sub_mat = (double **) MALLOC(sizeof(double *) * s);</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :     for( i = 0 ; i &lt; s ; i++)</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :       sub_mat[i] = (double *) MALLOC(sizeof(double ) * s);</span>
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span>            :     /* build the sub_mat corresponding to the partiion cur_part*/
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :     for ( i = 0 ; i &lt; s ; i ++){</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :       ii = perm[i];</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :       for( j = i ; j &lt; s ; j ++){</span>
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :         jj = perm[j];</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :         sub_mat[i][j] = com_mat-&gt;comm[ii][jj];</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :         sub_mat[j][i] = sub_mat[i][j];</span>
<span class="lineNum">     263 </span>            :       }
<span class="lineNum">     264 </span>            :     }
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :     sub_com_mat = (com_mat_t *)malloc(sizeof(com_mat_t));</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :     sub_com_mat -&gt; n = s;</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :     sub_com_mat -&gt; comm = sub_mat;</span>
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            :     /*  printf(&quot;\n\npartition:%d\n&quot;,cur_part);display_tab(sub_mat,m);*/
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span>            :     /* assign the sub_mat to the result*/
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :     res[cur_part] = sub_com_mat;</span>
<span class="lineNum">     275 </span>            :   }
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :   FREE(perm);</span>
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :   return res;</span>
<a name="280"><span class="lineNum">     280 </span>            : }</a>
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span><span class="lineNoCov">          0 : int **split_vertices( int *vertices, int n, int k, int *partition)</span>
<span class="lineNum">     283 </span>            : {
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :   int **res = NULL, *sub_vertices = NULL;</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :   int m = n/k;</span>
<span class="lineNum">     286 </span>            :   int i, j, cur_part;
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span>            :   /*allocate resuts*/
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :   res = (int**) MALLOC(sizeof(int*) * k);</span>
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :   if(verbose_level &gt;= DEBUG){</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :     printf(&quot;Partition: &quot;);print_1D_tab(partition,n);</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :     printf(&quot;Vertices id: &quot;);print_1D_tab(vertices,n);</span>
<span class="lineNum">     295 </span>            :   }
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span>            :   /*split the vertices tab of the partition cur_part  to the sub_vertices tab*/
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :   for( cur_part = 0; cur_part &lt; k ; cur_part ++){</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :     sub_vertices = (int*) MALLOC(sizeof(int) * m);</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :     i = 0;</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :     for( j = 0; j &lt; n; j ++)</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :       if ( partition[j] == cur_part )</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :         sub_vertices[i++] = vertices[j];</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :     res[cur_part] = sub_vertices;</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :     if(verbose_level &gt;= DEBUG){</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :       printf(&quot;partition %d: &quot;,cur_part);print_1D_tab(sub_vertices,m);</span>
<span class="lineNum">     307 </span>            :     }
<span class="lineNum">     308 </span>            :   }
<span class="lineNum">     309 </span>            :   /*exit(-1);*/
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :   return res;</span>
<a name="311"><span class="lineNum">     311 </span>            : }</a>
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span><span class="lineNoCov">          0 : void FREE_tab_com_mat(com_mat_t **mat,int k)</span>
<span class="lineNum">     314 </span>            : {
<span class="lineNum">     315 </span>            :   int i,j;
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :   if( !mat )</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :   for ( i = 0 ; i &lt; k ; i ++){</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :     for ( j = 0 ; j &lt; mat[i]-&gt;n ; j ++)</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :       FREE( mat[i]-&gt;comm[j] );</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :     FREE( mat[i]-&gt;comm );</span>
<span class="lineNum">     323 </span>            :   }
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :   FREE(mat);</span>
<a name="325"><span class="lineNum">     325 </span>            : }</a>
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span><span class="lineNoCov">          0 : void FREE_tab_local_vertices(int **mat, int k)</span>
<span class="lineNum">     328 </span>            : {
<span class="lineNum">     329 </span>            :   int i; /* m=n/k; */
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :   if( !mat )</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :   for ( i = 0 ; i &lt; k ; i ++){</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :     FREE( mat[i] );</span>
<span class="lineNum">     335 </span>            :   }
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :   FREE(mat);</span>
<span class="lineNum">     337 </span>            : }
<a name="338"><span class="lineNum">     338 </span>            : </a>
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span><span class="lineNoCov">          0 : void FREE_const_tab(constraint_t *const_tab, int k)</span>
<span class="lineNum">     341 </span>            : {
<span class="lineNum">     342 </span>            :   int i;
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :   if( !const_tab )</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :   for(i = 0; i &lt; k; i++){</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :     if(const_tab[i].length)</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :       FREE(const_tab[i].constraints);</span>
<span class="lineNum">     350 </span>            :   }
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :   FREE(const_tab);</span>
<a name="353"><span class="lineNum">     353 </span>            : }</a>
<span class="lineNum">     354 </span>            : 
<span class="lineNum">     355 </span><span class="lineNoCov">          0 : void kpartition_build_level_topology(tree_t *cur_node, com_mat_t *com_mat, int N, int depth,</span>
<span class="lineNum">     356 </span>            :                                      tm_topology_t *topology, int *local_vertices,
<span class="lineNum">     357 </span>            :                                      int *constraints, int nb_constraints,
<span class="lineNum">     358 </span>            :                                      double *obj_weight, double *comm_speed)
<span class="lineNum">     359 </span>            : {
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :   com_mat_t **tab_com_mat = NULL; /* table of comunication matrix. We will have k of such comunication matrix, one for each subtree */</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :   int k = topology-&gt;arity[depth];</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :   tree_t **tab_child = NULL;</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :   int *partition = NULL;</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :   int **tab_local_vertices = NULL;</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :   constraint_t *const_tab = NULL;</span>
<span class="lineNum">     366 </span>            :   int i;
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :   verbose_level = get_verbose_level();</span>
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span>            :   /* if we are at the bottom of the tree set cur_node
<span class="lineNum">     370 </span>            :    and return*/
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :   if ( depth == topology-&gt;nb_levels - 1 ){</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :     if(verbose_level&gt;=DEBUG)</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :       printf(&quot;id : %d, com_mat= %p\n&quot;,local_vertices[0], (void *)com_mat-&gt;comm);</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :     set_node(cur_node,NULL, 0, NULL, local_vertices[0], 0, NULL, depth);</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     376 </span>            :   }
<span class="lineNum">     377 </span>            : 
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span>            :   /* partition the com_matrix in k partitions*/
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :   partition = kpartition(topology-&gt;arity[depth], com_mat, N, constraints, nb_constraints);</span>
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span>            :   /* split the communication matrix in k parts according to the partition just found above */
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :   tab_com_mat = split_com_mat( com_mat, N, k, partition);</span>
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span>            :   /* split the local vertices in k parts according to the partition just found above */
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :   tab_local_vertices = split_vertices( local_vertices, N, k, partition);</span>
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span>            :   /* construct a tab of constraints of  size k: one for each partitions*/
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :   const_tab = split_constraints (constraints, nb_constraints, k, topology, depth);</span>
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span>            :   /* create the table of k nodes of the resulting sub-tree */
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :   tab_child = (tree_t **) CALLOC (k,sizeof(tree_t));</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :   for( i = 0 ; i &lt; k ; i++){</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :     tab_child[i] = (tree_t *) MALLOC(sizeof(tree_t));</span>
<span class="lineNum">     395 </span>            :   }
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span>            :   /* for each child, proceeed recursively*/
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :   for( i = 0 ; i &lt; k ; i++){</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :     tab_child[i]-&gt;id = i;</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :     kpartition_build_level_topology ( tab_child[i], tab_com_mat[i], N/k, depth + 1,</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :                                       topology, tab_local_vertices[i],</span>
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :                                       const_tab[i].constraints, const_tab[i].length,</span>
<span class="lineNum">     403 </span>            :                                       obj_weight, comm_speed);
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :     tab_child[i]-&gt;parent = cur_node;</span>
<span class="lineNum">     405 </span>            :   }
<span class="lineNum">     406 </span>            : 
<span class="lineNum">     407 </span>            :   /* link the node with its child */
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :   set_node( cur_node, tab_child, k, NULL, cur_node-&gt;id, 0, NULL, depth);</span>
<span class="lineNum">     409 </span>            : 
<span class="lineNum">     410 </span>            :   /* FREE local data*/
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :   FREE(partition);</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :   FREE_tab_com_mat(tab_com_mat,k);</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :   FREE_tab_local_vertices(tab_local_vertices,k);</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :   FREE_const_tab(const_tab,k);</span>
<span class="lineNum">     415 </span>            : }
<a name="416"><span class="lineNum">     416 </span>            : </a>
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span><span class="lineNoCov">          0 : tree_t *kpartition_build_tree_from_topology(tm_topology_t *topology,double **comm,int N, int *constraints, int nb_constraints, double *obj_weight, double *com_speed)</span>
<span class="lineNum">     419 </span>            : {
<span class="lineNum">     420 </span>            :   int depth,i, K;
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :   tree_t *root = NULL;</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :   int *local_vertices = NULL;</span>
<span class="lineNum">     423 </span>            :   int nb_cores;
<span class="lineNum">     424 </span>            :   com_mat_t com_mat;
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :   verbose_level = get_verbose_level();</span>
<span class="lineNum">     427 </span>            : 
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :   if(verbose_level&gt;=INFO)</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :     printf(&quot;Number of constraints: %d\n&quot;, nb_constraints);</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :   printf(&quot;Number of constraints: %d, N=%d\n&quot;, nb_constraints, N);</span>
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :   nb_cores=nb_processing_units(topology);</span>
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :   if((constraints == NULL) &amp;&amp; (nb_constraints != 0)){</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :     if(verbose_level&gt;=ERROR)</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :       fprintf(stderr,&quot;size of constraint table not zero while constraint tab is NULL\n&quot;);</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">     438 </span>            :   }
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :   if((constraints != NULL) &amp;&amp; (nb_constraints &gt; nb_cores)){</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :     if(verbose_level&gt;=ERROR)</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :       fprintf(stderr,&quot;size of constraint table (%d) is greater than the number of cores (%d)\n&quot;, nb_constraints, nb_cores);</span>
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">     444 </span>            :   }
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :   depth = 0;</span>
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span>            :   /* if we have more cores than processes add new dumb process to the com matrix*/
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :   if((K=nb_cores - N)&gt;0){</span>
<span class="lineNum">     450 </span>            :     /* add K element to the object weight*/
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :     complete_obj_weight(&amp;obj_weight,N,K);</span>
<span class="lineNum">     452 </span>            :     /* display_tab(tab,N+K);*/
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :   } else if( K &lt; 0){</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :     if(verbose_level&gt;=ERROR)</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :       fprintf(stderr,&quot;Not enough cores!\n&quot;);</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">     457 </span>            :   }
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :   com_mat.comm = comm;</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :   com_mat.n    = N;</span>
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span>            :   /*
<span class="lineNum">     463 </span>            :      local_vertices is the array of vertices that can be used
<span class="lineNum">     464 </span>            :      the min(N,nb_contraints) 1st element are number from 0 to N
<span class="lineNum">     465 </span>            :      the last ones have value -1
<span class="lineNum">     466 </span>            :      the value of this array will be used to number the leaves of the tree_t tree
<span class="lineNum">     467 </span>            :      that start at &quot;root&quot;
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span>            :      min(N,nb_contraints) is used to takle the case where thre is less processes than constraints
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span>            :    */
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :   local_vertices = (int*) MALLOC (sizeof(int) * (K+N));</span>
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :   for( i = 0 ; i &lt; MIN(N,nb_constraints) ; i++)</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :     local_vertices[i] = i;</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :   for( i = MIN(N,nb_constraints) ;i &lt; N + K ; i++)</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :     local_vertices[i] = -1;</span>
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span>            :   /* we assume all objects have the same arity*/
<span class="lineNum">     481 </span>            :   /* assign the root of the tree*/
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :   root = (tree_t*) MALLOC (sizeof(tree_t));</span>
<span class="lineNum">     483 </span>            : 
<span class="lineNum">     484 </span>            : 
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            :   /*build the tree downward from the root*/
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :   kpartition_build_level_topology(root, &amp;com_mat, N+K,  depth, topology, local_vertices,</span>
<span class="lineNum">     488 </span>            :                                         constraints, nb_constraints, obj_weight, com_speed);
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span>            :   /*print_1D_tab(local_vertices,K+N);*/
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :   if(verbose_level&gt;=INFO)</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :     printf(&quot;Build (bottom-up) tree done!\n&quot;);</span>
<span class="lineNum">     493 </span>            : 
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :   FREE(local_vertices);</span>
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span>            :   /* tell the system it is a constraint tree, this is usefull for freeing pointers*/
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :   root-&gt;constraint = 1;</span>
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :   return root;</span>
<span class="lineNum">     503 </span>            : }
<span class="lineNum">     504 </span>            : 
<span class="lineNum">     505 </span>            : 
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
